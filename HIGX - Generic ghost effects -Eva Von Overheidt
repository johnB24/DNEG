set cut_paste_input [stack 0]
version 12.1 v5
BackdropNode {
 inputs 0
 name BackdropNode46
 tile_color 0x4c4c4cff
 label "GENERIC COMP GHOST FX"
 note_font "Bitstream Vera Sans Bold"
 note_font_size 200
 selected true
 xpos 8046
 ypos 31639
 bdwidth 5971
 bdheight 1826
 z_order -1
 addUserKnob {20 BagAndTag}
 addUserKnob {6 partOfRebuildScript l "This node is part of the rebuild script DO NOT DELETE" -STARTLINE +DISABLED}
 partOfRebuildScript true
}
BackdropNode {
 inputs 0
 name BackdropNode56
 tile_color 0x4c4c4cff
 label "GENERIC COMP GHOST FX"
 note_font "Bitstream Vera Sans Bold"
 note_font_size 200
 selected true
 xpos 8046
 ypos 31639
 bdwidth 5971
 bdheight 1826
 z_order -1
 addUserKnob {20 BagAndTag}
 addUserKnob {6 partOfRebuildScript l "This node is part of the rebuild script DO NOT DELETE" -STARTLINE +DISABLED}
 partOfRebuildScript true
}
BackdropNode {
 inputs 0
 name BackdropNode52
 tile_color 0x2d2d2dff
 label "PRECOMP 03"
 note_font_size 42
 selected true
 xpos 11034
 ypos 31967
 bdwidth 708
 bdheight 1111
 addUserKnob {20 BagAndTag}
 addUserKnob {6 partOfRebuildScript l "This node is part of the rebuild script DO NOT DELETE" -STARTLINE +DISABLED}
 partOfRebuildScript true
}
BackdropNode {
 inputs 0
 name BackdropNode54
 tile_color 0x2d2d2dff
 label "PRECOMP 01"
 note_font_size 42
 selected true
 xpos 8373
 ypos 31954
 bdwidth 950
 bdheight 1131
 addUserKnob {20 BagAndTag}
 addUserKnob {6 partOfRebuildScript l "This node is part of the rebuild script DO NOT DELETE" -STARTLINE +DISABLED}
 partOfRebuildScript true
}
BackdropNode {
 inputs 0
 name BackdropNode55
 tile_color 0x2d2d2dff
 label "PRECOMP 02"
 note_font_size 42
 selected true
 xpos 9761
 ypos 31923
 bdwidth 963
 bdheight 1191
 addUserKnob {20 BagAndTag}
 addUserKnob {6 partOfRebuildScript l "This node is part of the rebuild script DO NOT DELETE" -STARTLINE +DISABLED}
 partOfRebuildScript true
}
BackdropNode {
 inputs 0
 name BackdropNode58
 tile_color 0x2d2d2dff
 label "PRECOMP 04"
 note_font_size 42
 selected true
 xpos 12025
 ypos 31960
 bdwidth 1112
 bdheight 1164
 addUserKnob {20 BagAndTag}
 addUserKnob {6 partOfRebuildScript l "This node is part of the rebuild script DO NOT DELETE" -STARTLINE +DISABLED}
 partOfRebuildScript true
}
BackdropNode {
 inputs 0
 name BackdropNode66
 tile_color 0x4c4c4cff
 label "Additional fractals \nfemale dancer"
 note_font_size 42
 selected true
 xpos 14317
 ypos 31625
 bdwidth 1137
 bdheight 1923
 addUserKnob {20 BagAndTag}
 addUserKnob {6 partOfRebuildScript l "This node is part of the rebuild script DO NOT DELETE" -STARTLINE +DISABLED}
 partOfRebuildScript true
}
BackdropNode {
 inputs 0
 name BackdropNode68
 tile_color 0x2d2d2dff
 label "PRECOMP 03"
 note_font_size 42
 selected true
 xpos 11034
 ypos 31967
 bdwidth 708
 bdheight 1111
 addUserKnob {20 BagAndTag}
 addUserKnob {6 partOfRebuildScript l "This node is part of the rebuild script DO NOT DELETE" -STARTLINE +DISABLED}
 partOfRebuildScript true
}
BackdropNode {
 inputs 0
 name BackdropNode69
 tile_color 0x2d2d2dff
 label "PRECOMP 04"
 note_font_size 42
 selected true
 xpos 12025
 ypos 31960
 bdwidth 1112
 bdheight 1164
 addUserKnob {20 BagAndTag}
 addUserKnob {6 partOfRebuildScript l "This node is part of the rebuild script DO NOT DELETE" -STARTLINE +DISABLED}
 partOfRebuildScript true
}
BackdropNode {
 inputs 0
 name BackdropNode74
 tile_color 0x2d2d2dff
 label "PRECOMP 01"
 note_font_size 42
 selected true
 xpos 8373
 ypos 31954
 bdwidth 950
 bdheight 1131
 addUserKnob {20 BagAndTag}
 addUserKnob {6 partOfRebuildScript l "This node is part of the rebuild script DO NOT DELETE" -STARTLINE +DISABLED}
 partOfRebuildScript true
}
BackdropNode {
 inputs 0
 name BackdropNode75
 tile_color 0x2d2d2dff
 label "PRECOMP 02"
 note_font_size 42
 selected true
 xpos 9761
 ypos 31923
 bdwidth 963
 bdheight 1191
 addUserKnob {20 BagAndTag}
 addUserKnob {6 partOfRebuildScript l "This node is part of the rebuild script DO NOT DELETE" -STARTLINE +DISABLED}
 partOfRebuildScript true
}
StickyNote {
 inputs 0
 name StickyNote5
 label "part D"
 note_font_size 50
 selected true
 xpos 8085
 ypos 31907
 addUserKnob {20 BagAndTag}
 addUserKnob {6 partOfRebuildScript l "This node is part of the rebuild script DO NOT DELETE" -STARTLINE +DISABLED}
 partOfRebuildScript true
}
push $cut_paste_input
Camera2 {
 translate {5 0.1 0.07756583}
 rotate {0 87.69209641 0}
 name Camera22
 selected true
 xpos 8554
 ypos 32499
 addUserKnob {20 Ivy}
 addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.toolbox.v1.nodes.docs', fromlist=\['open_docs_name']).open_docs_name('IvyTab')" +STARTLINE}
 addUserKnob {26 divider4 l "" +STARTLINE}
 addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
 _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
 addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
 addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
 addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
 _expressions {{curve}}
 addUserKnob {26 divider0 l "" +STARTLINE}
 addUserKnob {20 dbinfo l "DB Info" n 1}
 dbinfo 0
 addUserKnob {1 twig_dnuuid l "Twig Id"}
 addUserKnob {1 stalk_dnuuid l "Stalk Id"}
 addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
 addUserKnob {1 leaf_dnuuid l "Leaf Id"}
 addUserKnob {26 divider1 l "" +STARTLINE}
 addUserKnob {1 twigtype l "Twig Type"}
 addUserKnob {1 leaf_label l Leaf}
 addUserKnob {1 ivy_version l Version}
 addUserKnob {43 ivy_notes l Notes}
 addUserKnob {26 divider2 l "" +STARTLINE}
 addUserKnob {1 build_label l "Build Label"}
 addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
}
Group {
 inputs 0
 name Point_Grid10
 tile_color 0x434343ff
 note_font_color 0x7dadf9ff
 selected true
 xpos 8822
 ypos 32091
 addUserKnob {20 User}
 addUserKnob {26 text l "" +STARTLINE T "Point Grid v1.0\n\nThis node generates a grid.\nAs it is defined in a non-euclidian space, \nmost of the shaders and wire or facet rendering won't work. "}
 addUserKnob {26 ""}
 addUserKnob {41 size_x l "Number of Points" T CONTROLER.size_x}
 addUserKnob {41 size_y l "" -STARTLINE T CONTROLER.size_y}
 addUserKnob {41 size_z l "" -STARTLINE T CONTROLER.size_z}
 addUserKnob {18 Position}
 Position {0 0 0}
 addUserKnob {6 Position_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Position_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Position_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {18 Scale}
 Scale {2 4 2}
 addUserKnob {6 Scale_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Scale_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Scale_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
}
 NoOp {
  inputs 0
  name CONTROLER
  xpos 224
  ypos -62
  addUserKnob {20 User}
  addUserKnob {3 VoxelDensity}
  VoxelDensity {{ceil(pow(size_x*size_y*size_z,1/3))}}
  addUserKnob {3 size_x l "Voxel Grid Size"}
  size_x 140
  addUserKnob {3 size_y l "" -STARTLINE}
  size_y 100
  addUserKnob {3 size_z l "" -STARTLINE}
  size_z 130
 }
 Crop {
  inputs 0
  box {0 0 {ceil(sqrt(pow(parent.CONTROLER.VoxelDensity,3)))} {sqrt(pow(parent.CONTROLER.VoxelDensity,3))}}
  reformat true
  crop false
  name Crop3
  xpos 372
  ypos -108
 }
 BlinkScript {
  recompileCount 9
  ProgramGroup 1
  KernelDescription "2 \"InvertKernel\" iterate pixelWise 21048e0522d3524e03cb582229852f2e33dbe569cd86686b92f460148f8700cf 2 \"src\" Read Point \"dst\" Write Point 1 \"Cube Size\" Int 3 IAAAACAAAAAgAAAAAAAAAA== 1 \"cube_size\" 3 1 0"
  kernelSource "kernel InvertKernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;  \n  Image<eWrite> dst;\n\n  param:\n    int3 cube_size;\n\n  local:\n    \n\n  void define() \{\n    defineParam(cube_size, \"Cube Size\", int3(32,32,32));\n  \}\n\n  void init() \{\n    \n  \}\n\n  void process(int2 pos) \{\n    int t_offset = (pos.x+(pos.y*src.bounds.width()));\n    float4 position;\n    float maxSize = max(max(cube_size.x,cube_size.y),cube_size.z);\n\n    position.x = fmod(t_offset,cube_size.x)/float(cube_size.x-1);\n    position.y = fmod(int(t_offset/cube_size.x),cube_size.y)/float(cube_size.y-1);\n    position.z = fmod(int(t_offset/(cube_size.x*cube_size.y)),cube_size.z)/float(cube_size.z-1);\n    position.w = 1-min(fmod(int(t_offset/(cube_size.x*cube_size.y*cube_size.z)),maxSize),1.0f);\n\n    dst() = float4(position.x*position.w,position.y*position.w,position.z*position.w,position.w);\n   \}\n\};\n\n"
  rebuild ""
  "InvertKernel_Cube Size" {{parent.CONTROLER.size_x} {parent.CONTROLER.size_y} {parent.CONTROLER.size_z}}
  rebuild_finalise ""
  name BlinkScript8
  selected true
  xpos 372
  ypos -79
 }
 Grade {
  add -0.5
  black_clamp false
  name Grade1
  xpos 372
  ypos -47
 }
 Grade {
  white {{parent.Scale.r} {parent.Scale.g} {parent.Scale.b} 0.9}
  add {{parent.Position.r} {parent.Position.g} {parent.Position.b} 0}
  black_clamp false
  name Grade2
  xpos 372
  ypos -26
 }
add_layer {pos pos.red pos.green pos.blue pos.alpha}
 Shuffle {
  red white
  green white
  blue white
  black red
  white green
  red2 blue
  green2 alpha
  out2 pos
  name Shuffle1
  xpos 372
  ypos -2
 }
 ModifyMetaData {
  metadata {
   {set pointrender/n_points "\[expr \[value parent.size_x]*\[value parent.size_y] *\[value parent.size_z]]"}
   {set pointrender/gen_type 3}
  }
  name SetMetaData
  xpos 372
  ypos 22
 }
 Grade {
  white {{1/((parent.size_x*parent.size_y*parent.size_z)/200000)}}
  black_clamp false
  name Grade9
  xpos 372
  ypos 46
 }
 Crop {
  box {0 0 {ceil(sqrt(pow(parent.CONTROLER.VoxelDensity,3)))} {sqrt(pow(parent.CONTROLER.VoxelDensity,3))}}
  crop false
  name Crop1
  xpos 372
  ypos 70
 }
 Output {
  name Output1
  xpos 372
  ypos 149
 }
end_group
Group {
 name Fractal22
 tile_color 0x434343ff
 note_font_color 0x7dadf9ff
 selected true
 xpos 8822
 ypos 32165
 addUserKnob {20 User t test}
 addUserKnob {26 _1 l "" +STARTLINE T "Point Fractal 1.0\n"}
 addUserKnob {26 devider_noise l "<b><font color=#7DADF9>Noise Settings</font><b>"}
 addUserKnob {6 Noise_Absolute l Absolute t "Negative values in the noise offset is made positive." +STARTLINE}
 addUserKnob {3 Noise_Octaves l Octaves}
 Noise_Octaves 8
 addUserKnob {7 Noise_Gain l Gain}
 Noise_Gain 0.3
 addUserKnob {7 Noise_Lacunarity l Lacunarity R 0 4}
 Noise_Lacunarity 1.18
 addUserKnob {18 Amplitude}
 Amplitude 0.39
 addUserKnob {6 Amplitude_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Amplitude_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Amplitude_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Amplitude_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {3 Itterations}
 Itterations 5
 addUserKnob {26 invis_devider_noise l "" +STARTLINE T " "}
 addUserKnob {26 Devider_Frequency l "<b><font color=#7DADF9>Freq Control</font><b>"}
 addUserKnob {19 Freq_Offset l "General Offset" t "This is like a 3D translation, letting you move the current noise pattern in the X, Y, Z and W (4th dimention)" R 0 10}
 Freq_Offset {0 0 0 0}
 addUserKnob {6 Freq_Offset_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_Offset_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_Offset_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_Offset_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_Offset_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 Freq_GeneralScale l "Genral Scale" t "This lets you control the scale of each individual noise axis."}
 Freq_GeneralScale {1 1 1 1}
 addUserKnob {6 Freq_GeneralScale_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_GeneralScale_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_GeneralScale_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_GeneralScale_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_GeneralScale_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {26 invis_devider_freq l "" +STARTLINE T " "}
 addUserKnob {19 Freq_EvolveLow l "Evolve Low" t "This lets you evolve (auto animate) the noise in a particular direction. The \"Low\" part means that this only affects the low frequencies.\n\nTo avoid a \"scrolling\" effect you can use the 4th dimention to break up the spatial cohearence." R 0 10}
 Freq_EvolveLow {3 0 0 0.5}
 addUserKnob {6 Freq_EvolveLow_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveLow_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveLow_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveLow_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveLow_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleLow_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 Freq_EvolveHigh l "Evolve High" t "This lets you evolve (auto animate) the noise in a particular direction. The \"High\" part means that this only affects the high frequencies.\n\nTo avoid a \"scrolling\" effect you can use the 4th dimention to break up the spatial cohearence."}
 Freq_EvolveHigh {0.9 0 -1 1}
 addUserKnob {6 Freq_EvolveHigh_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveHigh_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveHigh_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveHigh_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveHigh_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {26 invis_devider_freq2 l "" +STARTLINE T " "}
 addUserKnob {19 Freq_ScaleLow l "Scale Low" t "This lets you scale the noise in a particular axis. The \"Low\" part means that this only affects the low frequencies."}
 Freq_ScaleLow {2 0.5 2 2}
 addUserKnob {6 Freq_ScaleLow_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleLow_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleLow_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleLow_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleLow_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 Freq_ScaleHigh l "Scale High" t "This lets you scale the noise in a particular axis. The \"High\" part means that this only affects the high frequencies."}
 Freq_ScaleHigh {2 2 2 2}
 addUserKnob {6 Freq_ScaleHigh_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleHigh_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleHigh_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleHigh_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleHigh_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {26 invis_devider_freq3 l "" +STARTLINE T " "}
 addUserKnob {26 Curve l "<b><font color=#7DADF9>Curve Noise</font><b>"}
 addUserKnob {6 CurveNoise_Enable l Enable t "Adds a gamma curve to the noise intensity making noise near the \"Offset\" value more flat. This is a experimental feature." +STARTLINE}
 addUserKnob {6 CurveNoise_Invert l Invert t "Inverts the effect of the curved noise." -STARTLINE}
 addUserKnob {7 CurveGain l "Curve Gain" R -10 10}
 CurveGain 3
 addUserKnob {7 CurveOffset R -2 2}
 addUserKnob {26 gabgen l "" +STARTLINE T "\n"}
 addUserKnob {26 info_mask l "<b><font color=#7DADF9>Mask</font><b>"}
 addUserKnob {41 maskChannelMask l "" t "If a node is connected to the mask input, this will let you mask off the effect of the noise.\nIts recommended that you use the Point_Texture node to ensure a correct aspect and size." -STARTLINE T Merge1.maskChannelMask}
 addUserKnob {41 inject -STARTLINE T Merge1.inject}
 addUserKnob {41 invert_mask l invert -STARTLINE T Merge1.invert_mask}
 addUserKnob {41 fringe -STARTLINE T Merge1.fringe}
 addUserKnob {41 mix T Merge1.mix}
}
 Input {
  inputs 0
  name InputMask
  xpos -714
  ypos 207
  number 1
 }
 Reformat {
  type "to box"
  box_width {{parent.InputFormat.box.r}}
  box_height {{parent.InputFormat.box.t}}
  box_fixed true
  resize distort
  name Reformat2
  xpos -714
  ypos 306
 }
 Shuffle {
  name Shuffle3
  xpos -714
  ypos 330
 }
 Input {
  inputs 0
  name InputData
  xpos -582
  ypos 73
 }
 Dot {
  name Dot1
  xpos -548
  ypos 114
 }
set N1bc0b800 [stack 0]
 Shuffle {
  in pos
  name Shuffle1
  xpos -470
  ypos 110
 }
 BlinkScript {
  kernelSourceFile /Users/madshagbarth/Github/Nuke-Private/Blink/PointRender/Modify/Fractal_v06.cpp
  recompileCount 60
  ProgramGroup 1
  KernelDescription "2 \"Noise4D\" iterate pixelWise d54284af3e5573ad197bef9032773e8653de2cad590694fcc9fd5af993e97da3 2 \"src\" Read Point \"dst\" Write Point 17 \"absNoise\" Bool 1 AA== \"curveNoise\" Bool 1 AA== \"curveInvert\" Bool 1 AA== \"curveGain\" Float 1 AACAPw== \"curveOffset\" Float 1 AACAPw== \"Octaves\" Int 1 CgAAAA== \"Gain\" Float 1 AAAAPw== \"Lacunarity\" Float 1 AAAAQA== \"Gamma\" Float 1 AAAAPw== \"amplitude\" Float 3 AAAAPwAAAD8AAAA/AAAAAA== \"itterations\" Int 1 AQAAAA== \"Offset\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"Scale\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"suboffset\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"topoffset\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"subscale\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"topscale\" Float 4 AACAPwAAgD8AAIA/AACAPw== 17 \"absNoise\" 1 1 \"curveNoise\" 1 1 \"curveInvert\" 1 1 \"curveGain\" 1 1 \"curveOffset\" 1 1 \"octaves\" 1 1 \"gain\" 1 1 \"lacunarity\" 1 1 \"gamma\" 1 1 \"amplitude\" 3 1 \"itterations\" 1 1 \"offset\" 4 1 \"scale\" 4 1 \"suboffset\" 4 1 \"topoffset\" 4 1 \"subscale\" 4 1 \"topscale\" 4 1 0"
  kernelSource "//Based on https://github.com/Draradech/csworldgen/blob/master/simplexnoise.cpp\n//Ported by Mads Hagbarth Lund 2014\n\n/* Copyright (c) 2007-2012 Eliot Eshelman\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n\nint fastfloor( const float x ) \{ return x > 0 ? (int) x : (int) x - 1; \}\ninline float raw_noise_4d( const float x, const float y, const float z, const float w ) \n\{\nint simplex\[64]\[4] = \{\n    \{0,1,2,3\},\{0,1,3,2\},\{0,0,0,0\},\{0,2,3,1\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{1,2,3,0\},\n    \{0,2,1,3\},\{0,0,0,0\},\{0,3,1,2\},\{0,3,2,1\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{1,3,2,0\},\n    \{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\n    \{1,2,0,3\},\{0,0,0,0\},\{1,3,0,2\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{2,3,0,1\},\{2,3,1,0\},\n    \{1,0,2,3\},\{1,0,3,2\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{2,0,3,1\},\{0,0,0,0\},\{2,1,3,0\},\n    \{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\n    \{2,0,1,3\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{3,0,1,2\},\{3,0,2,1\},\{0,0,0,0\},\{3,1,2,0\},\n    \{2,1,0,3\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{3,1,0,2\},\{0,0,0,0\},\{3,2,0,1\},\{3,2,1,0\}\n\};\n    int perm\[512] = \{\n        151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,\n        8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,\n        35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,\n        134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,\n        55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208, 89,\n        18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,\n        250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,\n        189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,\n        172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,\n        228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,\n        107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,\n        138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180,\n\n        151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,\n        8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,\n        35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,\n        134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,\n        55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208, 89,\n        18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,\n        250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,\n        189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,\n        172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,\n        228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,\n        107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,\n        138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180\n    \};\n   int grad4\[32]\[4]= \{\n    \{0,1,1,1\},  \{0,1,1,-1\},  \{0,1,-1,1\},  \{0,1,-1,-1\},\n    \{0,-1,1,1\}, \{0,-1,1,-1\}, \{0,-1,-1,1\}, \{0,-1,-1,-1\},\n    \{1,0,1,1\},  \{1,0,1,-1\},  \{1,0,-1,1\},  \{1,0,-1,-1\},\n    \{-1,0,1,1\}, \{-1,0,1,-1\}, \{-1,0,-1,1\}, \{-1,0,-1,-1\},\n    \{1,1,0,1\},  \{1,1,0,-1\},  \{1,-1,0,1\},  \{1,-1,0,-1\},\n    \{-1,1,0,1\}, \{-1,1,0,-1\}, \{-1,-1,0,1\}, \{-1,-1,0,-1\},\n    \{1,1,1,0\},  \{1,1,-1,0\},  \{1,-1,1,0\},  \{1,-1,-1,0\},\n    \{-1,1,1,0\}, \{-1,1,-1,0\}, \{-1,-1,1,0\}, \{-1,-1,-1,0\}\n   \};\n    float F4 = (sqrt(5.0f)-1.0f)/4.0f;\n    float G4 = (5.0f-sqrt(5.0f))/20.0f;\n    float n0, n1, n2, n3, n4;\n    float s = (x + y + z + w) * F4;\n    int i = fastfloor(x + s);\n    int j = fastfloor(y + s);\n    int k = fastfloor(z + s);\n    int l = fastfloor(w + s);\n    float t = (i + j + k + l) * G4;\n    float X0 = i - t;\n    float Y0 = j - t;\n    float Z0 = k - t;\n    float W0 = l - t;\n\n    float x0 = x - X0;\n    float y0 = y - Y0;\n    float z0 = z - Z0;\n    float w0 = w - W0;\n    int c1 = (x0 > y0) ? 32 : 0;\n    int c2 = (x0 > z0) ? 16 : 0;\n    int c3 = (y0 > z0) ? 8 : 0;\n    int c4 = (x0 > w0) ? 4 : 0;\n    int c5 = (y0 > w0) ? 2 : 0;\n    int c6 = (z0 > w0) ? 1 : 0;\n    int c = c1 + c2 + c3 + c4 + c5 + c6;\n\n    int i1, j1, k1, l1;\n    int i2, j2, k2, l2;\n    int i3, j3, k3, l3;\n    i1 = simplex\[c]\[0]>=3 ? 1 : 0;\n    j1 = simplex\[c]\[1]>=3 ? 1 : 0;\n    k1 = simplex\[c]\[2]>=3 ? 1 : 0;\n    l1 = simplex\[c]\[3]>=3 ? 1 : 0;\n    i2 = simplex\[c]\[0]>=2 ? 1 : 0;\n    j2 = simplex\[c]\[1]>=2 ? 1 : 0;\n    k2 = simplex\[c]\[2]>=2 ? 1 : 0;\n    l2 = simplex\[c]\[3]>=2 ? 1 : 0;\n    i3 = simplex\[c]\[0]>=1 ? 1 : 0;\n    j3 = simplex\[c]\[1]>=1 ? 1 : 0;\n    k3 = simplex\[c]\[2]>=1 ? 1 : 0;\n    l3 = simplex\[c]\[3]>=1 ? 1 : 0;\n    float x1 = x0 - i1 + G4;\n    float y1 = y0 - j1 + G4;\n    float z1 = z0 - k1 + G4;\n    float w1 = w0 - l1 + G4;\n    float x2 = x0 - i2 + 2.0*G4;\n    float y2 = y0 - j2 + 2.0*G4;\n    float z2 = z0 - k2 + 2.0*G4;\n    float w2 = w0 - l2 + 2.0*G4;\n    float x3 = x0 - i3 + 3.0*G4;\n    float y3 = y0 - j3 + 3.0*G4;\n    float z3 = z0 - k3 + 3.0*G4;\n    float w3 = w0 - l3 + 3.0*G4;\n    float x4 = x0 - 1.0 + 4.0*G4;\n    float y4 = y0 - 1.0 + 4.0*G4;\n    float z4 = z0 - 1.0 + 4.0*G4;\n    float w4 = w0 - 1.0 + 4.0*G4;\n    int ii = i & 255;\n    int jj = j & 255;\n    int kk = k & 255;\n    int ll = l & 255;\n    int gi0 = perm\[ii+perm\[jj+perm\[kk+perm\[ll]]]] % 32;\n    int gi1 = perm\[ii+i1+perm\[jj+j1+perm\[kk+k1+perm\[ll+l1]]]] % 32;\n    int gi2 = perm\[ii+i2+perm\[jj+j2+perm\[kk+k2+perm\[ll+l2]]]] % 32;\n    int gi3 = perm\[ii+i3+perm\[jj+j3+perm\[kk+k3+perm\[ll+l3]]]] % 32;\n    int gi4 = perm\[ii+1+perm\[jj+1+perm\[kk+1+perm\[ll+1]]]] % 32;\n    float t0 = 0.6 - x0*x0 - y0*y0 - z0*z0 - w0*w0;\n    if(t0<0) n0 = 0.0;\n    else \{\n        t0 *= t0;\n        n0 = t0 * t0 * dot(float4(grad4\[gi0]\[0],grad4\[gi0]\[2],grad4\[gi0]\[3],grad4\[gi0]\[3]), float4(x0, y0, z0, w0));\n    \}\n    float t1 = 0.6 - x1*x1 - y1*y1 - z1*z1 - w1*w1;\n    if(t1<0) n1 = 0.0;\n    else \{\n        t1 *= t1;\n        n1 = t1 * t1 * dot(float4(grad4\[gi1]\[0],grad4\[gi1]\[2],grad4\[gi1]\[3],grad4\[gi1]\[3]), float4(x1, y1, z1, w1));\n    \}\n    float t2 = 0.6 - x2*x2 - y2*y2 - z2*z2 - w2*w2;\n    if(t2<0) n2 = 0.0;\n    else \{\n        t2 *= t2;\n        n2 = t2 * t2 * dot(float4(grad4\[gi2]\[0],grad4\[gi2]\[2],grad4\[gi2]\[3],grad4\[gi2]\[3]), float4(x2, y2, z2, w2));\n    \}\n    float t3 = 0.6 - x3*x3 - y3*y3 - z3*z3 - w3*w3;\n    if(t3<0) n3 = 0.0;\n    else \{\n        t3 *= t3;\n        n3 = t3 * t3 * dot(float4(grad4\[gi3]\[0],grad4\[gi3]\[2],grad4\[gi3]\[3],grad4\[gi3]\[3]), float4(x3, y3, z3, w3));\n    \}\n    float t4 = 0.6 - x4*x4 - y4*y4 - z4*z4 - w4*w4;\n    if(t4<0) n4 = 0.0;\n    else \{\n        t4 *= t4;\n        n4 = t4 * t4 * dot(float4(grad4\[gi4]\[0],grad4\[gi4]\[2],grad4\[gi4]\[3],grad4\[gi4]\[3]), float4(x4, y4, z4, w4));\n    \}\n    return 27.0 * (n0 + n1 + n2 + n3 + n4);\n\}\n\n\n\n\nkernel Noise4D : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n  Image<eWrite, eAccessPoint> dst;\nparam:\n    bool absNoise;\n    bool curveNoise;\n    bool curveInvert;\n    float curveGain;\n    float curveOffset;\n    int octaves;\n    float gain;\n    float lacunarity;\n    float gamma;\n    float3 amplitude;\n    int itterations;\n    float4 offset;\n    float4 scale;\n    float4 suboffset;\n    float4 topoffset;\n    float4 subscale;\n    float4 topscale;\n\n\n  void define() \{\n        defineParam (absNoise, \"absNoise\", false);    \n        defineParam (curveNoise, \"curveNoise\", false);    \n        defineParam (curveInvert, \"curveInvert\", false);   \n        defineParam (curveGain, \"curveGain\", 1.0f);\n        defineParam (curveOffset, \"curveOffset\", 1.0f);\n        defineParam (octaves, \"Octaves\", 10);\n        defineParam (gain, \"Gain\", 0.5f);\n        defineParam (lacunarity, \"Lacunarity\", 2.0f);\n        defineParam (gamma, \"Gamma\", 0.5f);\n        defineParam (amplitude, \"amplitude\", float3(0.5f));\n        defineParam (itterations, \"itterations\", 1);\n        defineParam(offset, \"Offset\", float4(0.0f, 0.0f, 0.0f,0.0f));\n        defineParam(scale, \"Scale\", float4(1.0f, 1.0f, 1.0f,1.0f));\n        defineParam(suboffset, \"suboffset\", float4(1.0f, 1.0f, 1.0f,1.0f));\n        defineParam(topoffset, \"topoffset\", float4(1.0f, 1.0f, 1.0f,1.0f));\n        defineParam(subscale, \"subscale\", float4(1.0f, 1.0f, 1.0f,1.0f));\n        defineParam(topscale, \"topscale\", float4(1.0f, 1.0f, 1.0f,1.0f));        \n  \}\n\nfloat octave_noise_4d( const float octaves, const float persistence, const float scale, const float x, const float y, const float z, const float w ) \n\{\n    float total = 0.0f;\n    float current;\n    float last = 1.0f;\n    float frequency = scale;\n    float amplitude = 1.0f;\n    float maxAmplitude = 0.0f;\n    float4 Tempoffset;\n    float4 Tempscale;\n\n\n    for( int i=0; i < octaves; i++ ) \{\n\n        /*\n        if (i == 0) \{\n            total += (float)raw_noise_4d( (x+suboffset.x) * frequency, (y+suboffset.y) * frequency, (z+suboffset.z) * frequency, (w+suboffset.w) * frequency ) * amplitude;\n        \}\n        else if (i == octaves-1) \{\n            total += (float)raw_noise_4d( (x+topoffset.x) * frequency, (y+topoffset.y) * frequency, (z+topoffset.z) * frequency, (w+topoffset.w) * frequency ) * amplitude;\n        \}\n        else \{\n            total += (float)raw_noise_4d( x * frequency, y * frequency, z * frequency, w * frequency ) * amplitude;\n        \}\n        */\n\n\n        Tempscale = (topscale * (i/(octaves-1.0f)))+(subscale * (1-(i/(octaves-1.0f))));       \n        Tempoffset = (topoffset * (i/(octaves-1.0f)))+(suboffset * (1-(i/(octaves-1.0f))));\n        current = (float)raw_noise_4d(   ((x*Tempscale.x)+Tempoffset.x) * frequency, \n                                        ((y*Tempscale.y)+Tempoffset.y) * frequency, \n                                        ((z*Tempscale.z)+Tempoffset.z) * frequency, \n                                        ((w*Tempscale.w)+Tempoffset.w) * frequency \n                                        ) * amplitude;\n        if (i == 0 && curveNoise)\{\n            if (curveInvert)\{\n                last = 0.5f-current;  \n            \}\n            else\{\n                last = current;  \n            \}\n               \n        \}\n        current = curveNoise?current*((last+curveOffset)*curveGain):current;\n        total += absNoise?fabs(current):current;\n        frequency *= 2.0f;\n        maxAmplitude += amplitude;\n        amplitude *= persistence;\n\n    \}\n    return float(total / maxAmplitude);\n\}\n\n\n\n\n  void process() \{\n    float4 srcSample = float4(src(0),src(1),src(2),src(3));\n    float sampleR,sampleG,sampleB;\n    for( int i=0; i < itterations; i++ ) \{\n        sampleR = (float)octave_noise_4d(float(octaves), gain, lacunarity, ( srcSample.x * scale.x ) + offset.x, ( srcSample.y * scale.y ) + offset.y,  ( srcSample.z * scale.z ) + offset.z, ( srcSample.w * scale.w ) + offset.w) * amplitude.x;\n        sampleG = (float)octave_noise_4d(float(octaves), gain, lacunarity, ( srcSample.x * scale.x ) + offset.x, ( srcSample.y * scale.y ) + offset.y,  ( srcSample.z * scale.z ) + offset.z, ( srcSample.w * scale.w ) + offset.w - 100.0f) * amplitude.y;\n        sampleB = (float)octave_noise_4d(float(octaves), gain, lacunarity, ( srcSample.x * scale.x ) + offset.x, ( srcSample.y * scale.y ) + offset.y,  ( srcSample.z * scale.z ) + offset.z, ( srcSample.w * scale.w ) + offset.w + 200.0f) * amplitude.z;\n        srcSample = float4(srcSample.x+sampleR,srcSample.y+sampleG,srcSample.z+sampleB,srcSample.w);\n    \}\n    dst() = float4(srcSample.x,srcSample.y,srcSample.z,1.0f);\n\}\n\};"
  rebuild ""
  Noise4D_curveNoise {{parent.CurveNoise_Enable}}
  Noise4D_curveInvert {{parent.CurveNoise_Invert}}
  Noise4D_curveGain {{parent.CurveGain}}
  Noise4D_curveOffset {{parent.CurveOffset}}
  Noise4D_Octaves {{parent.Noise_Octaves}}
  Noise4D_Gain {{parent.Noise_Gain}}
  Noise4D_Lacunarity {{parent.Noise_Lacunarity}}
  Noise4D_Gamma 0.79
  Noise4D_amplitude {{parent.Amplitude.r} {parent.Amplitude.g} {parent.Amplitude.b}}
  Noise4D_itterations {{parent.Itterations}}
  Noise4D_Offset {{parent.Freq_Offset} {parent.Freq_Offset} {parent.Freq_Offset} {parent.Freq_Offset}}
  Noise4D_Scale {{parent.Freq_GeneralScale} {parent.Freq_GeneralScale} {parent.Freq_GeneralScale} {parent.Freq_GeneralScale}}
  Noise4D_suboffset {{(frame*parent.Freq_EvolveLow.r)/50} {(frame*parent.Freq_EvolveLow.g)/50} {(frame*parent.Freq_EvolveLow.b)/50} {(frame*parent.Freq_EvolveLow.a)/50}}
  Noise4D_topoffset {{(frame*parent.Freq_EvolveHigh.r)/10} {(frame*parent.Freq_EvolveHigh.g)/10} {(frame*parent.Freq_EvolveHigh.b)/10} {(frame*parent.Freq_EvolveHigh.a)/10}}
  Noise4D_subscale {{parent.Freq_ScaleLow} {parent.Freq_ScaleLow} {parent.Freq_ScaleLow} {parent.Freq_ScaleLow}}
  Noise4D_topscale {{parent.Freq_ScaleHigh} {parent.Freq_ScaleHigh} {parent.Freq_ScaleHigh} {parent.Freq_ScaleHigh}}
  rebuild_finalise ""
  name Noise4D1
  selected true
  xpos -470
  ypos 177
 }
 Expression {
  expr0 abs(r)
  expr1 abs(g)
  expr2 abs(b)
  name Expression2
  xpos -470
  ypos 259
  disable {{!parent.Noise_Absolute}}
 }
 Shuffle {
  out pos
  name Shuffle2
  xpos -470
  ypos 330
 }
push $N1bc0b800
 Merge2 {
  inputs 2+1
  operation copy
  bbox B
  Achannels {pos.red pos.green pos.blue -pos.alpha}
  Bchannels {pos.red pos.green pos.blue -pos.alpha}
  output {pos.red pos.green pos.blue -pos.alpha}
  maskChannelMask -rgba.alpha
  name Merge1
  xpos -582
  ypos 326
 }
 Output {
  name Output1
  xpos -582
  ypos 497
 }
push $N1bc0b800
 Crop {
  box {0 0 {width} {height}}
  reformat true
  crop false
  name InputFormat
  xpos -713
  ypos 111
 }
end_group
set N403e6320 [stack 0]
Dot {
 name Dot5
 selected true
 xpos 8729
 ypos 32170
}
push $N403e6320
Dot {
 name Dot53
 selected true
 xpos 8856
 ypos 32347
}
Group {
 inputs 2
 name Point_OffsetShader11
 tile_color 0x434343ff
 note_font_color 0x55ffffff
 selected true
 xpos 8695
 ypos 32343
 addUserKnob {20 User}
 addUserKnob {26 info l "" +STARTLINE T "Point Offset Shader v1.0\n\nCalcualtes the distance between 2 point sets.\nThis can for example be used to see the difference between the original generator\nand the modified one."}
 addUserKnob {26 devider_general l "<b><font color=#70EE70>General</font><b>"}
 addUserKnob {7 Gain}
 Gain 3
 addUserKnob {7 Offset R -0.5 0.5}
 Offset -0.1
 addUserKnob {6 Absolute +STARTLINE}
 Absolute true
 addUserKnob {6 Reverse +STARTLINE}
}
 BackdropNode {
  inputs 0
  name BackdropNode1
  tile_color 0x388e8e00
  label Offset
  note_font_size 42
  xpos -591
  ypos 304
  bdwidth 224
  bdheight 161
 }
 Input {
  inputs 0
  name Input2
  xpos -438
  ypos 40
  number 1
 }
 Shuffle {
  in pos
  name Shuffle1
  xpos -438
  ypos 120
 }
 Dot {
  name Dot4
  xpos -404
  ypos 285
 }
 Dot {
  name Dot1
  xpos -404
  ypos 392
 }
 Input {
  inputs 0
  name Input1
  xpos -580
  ypos 50
 }
 Shuffle {
  in pos
  name Shuffle5
  xpos -580
  ypos 120
 }
 Dot {
  name Dot3
  xpos -546
  ypos 256
 }
 MergeExpression {
  inputs 2
  temp_name0 xd
  temp_expr0 A.red-B.red
  temp_name1 yd
  temp_expr1 A.green-B.green
  temp_name2 zd
  temp_expr2 A.blue-B.blue
  temp_name3 Distance
  temp_expr3 "sqrt(xd*xd + yd*yd + zd*zd)"
  expr0 Distance
  expr1 Distance
  expr2 Distance
  name Distance
  xpos -584
  ypos 388
 }
 Grade {
  add {{parent.Offset}}
  black_clamp false
  name Grade3
  xpos -584
  ypos 412
 }
 Grade {
  white {{parent.Gain}}
  black_clamp {{!parent.Absolute}}
  name Grade1
  xpos -584
  ypos 436
 }
 Expression {
  expr0 abs(r)
  expr1 abs(g)
  expr2 abs(b)
  name Expression1
  xpos -584
  ypos 459
  disable {{!parent.Absolute}}
 }
 Expression {
  expr0 max(0,1-r)
  expr1 max(0,1-r)
  expr2 max(0,1-r)
  name Expression2
  selected true
  xpos -584
  ypos 483
  disable {{!parent.Reverse}}
 }
 Group {
  name SoftLook_NF1
  xpos -584
  ypos 650
  disable true
  addUserKnob {20 User}
  addUserKnob {26 Info l "" +STARTLINE T "SoftLook\nby Mads Hagbarth Lund - 2016"}
  addUserKnob {26 ""}
  addUserKnob {7 Add R 0 4}
  Add 1.14
  addUserKnob {7 Offset R 0 4}
  Offset 0.86
 }
  Input {
   inputs 0
   name Input1
   xpos -248
   ypos 500
  }
set N40393120 [stack 0]
  Expression {
   expr0 r/(r+parent.Offset)*parent.Add
   expr1 g/(g+parent.Offset)*parent.Add
   expr2 b/(b+parent.Offset)*parent.Add
   expr3 a/(a+parent.Offset)*parent.Add
   name Expression1
   selected true
   xpos -339
   ypos 576
  }
push $N40393120
  ShuffleCopy {
   inputs 2
   red red
   green green
   blue blue
   alpha alpha2
   name ShuffleCopy1
   xpos -248
   ypos 576
  }
  Output {
   name Output1
   xpos -248
   ypos 651
  }
 end_group
 Output {
  name Output1
  xpos -584
  ypos 686
 }
end_group
Grade {
 white 1.3
 multiply {0.6887242198 0.9288096428 1 1}
 gamma {0.2101119161 0.3576882482 1 1}
 name Grade59
 selected true
 xpos 8695
 ypos 32425
}
Group {
 inputs 2
 name Point_Render10
 tile_color 0x434343ff
 note_font_color 0x7dadf9ff
 selected true
 xpos 8695
 ypos 32519
 addUserKnob {20 User l "Point Render" t dd}
 addUserKnob {26 info_header l "" +STARTLINE T "Point Render v1.0"}
 addUserKnob {26 devider_general l "<b><font color=#7DADF9>General</font><b>"}
 addUserKnob {4 RenderMode l "Render Mode" t "Some generators support multiple render modes other than just point rendering. This should be considered a experimental feature, but can be used to great effect.\n\nIn the Render Settings tab you can find more controls relating to Wire and Facet rendering modes.\n\nNote that Facet Render can be slow when really close to a object. " M {"Point Render" "Wire Render" "Facet Render (experimental)" "" "" ""}}
 addUserKnob {7 FocalLength l "Focal Length" t "The point render does not take the focal length from the input camera, so if you want to match it to a camera you should link the focal length from the camera to this." R 0 200}
 FocalLength 20
 addUserKnob {7 horizontalApeture l "Horiz Apeture" R 0 100}
 horizontalApeture 24.576
 addUserKnob {7 AlphaMultiplier l Exposure t "This is a general exposure modifier that lets you adjust the overall brightness of the render." R 0 2}
 AlphaMultiplier 0.15
 addUserKnob {6 UseOcclusionMap l "Use Occlusion Map" t "Enable the Occlusion map input. This lets you use a depth map as a holdout.\n\nNote:\nThe Red channal should contain the depth (absolute distance, not 1/depth)\nThe Alpha channal must be 1 for the areas that you want to holdout." +STARTLINE}
 addUserKnob {26 devider_cc l "<b><font color=#7DADF9>Preview</font><b>"}
 addUserKnob {6 FastPreview l "Fast Preview" t "Reduce the number of points for a quick preview of the final render." +STARTLINE}
 addUserKnob {6 HighlightCompression l "Hilight Compression" t "Compresses the highlights to make it easier to see bright details." +STARTLINE}
 addUserKnob {7 HighlightCeiling l "Highlight Ceiling" t "Adjust the cealing for the highlight compression." R 1 10}
 HighlightCeiling 1.15
 addUserKnob {7 Compression t "The compression amount." -STARTLINE R 0 5}
 Compression 1
 addUserKnob {26 devider_format l "<b><font color=#7DADF9>Format</font><b>"}
 addUserKnob {41 format l "output format" T Settings_Format.format}
 addUserKnob {20 WireRender l "Render Settings"}
 addUserKnob {26 devider_wirerender l "<b><font color=#7DADF9>Wire Rendering</font><b>"}
 addUserKnob {4 wire_type l "Connection Mode" t "*Normal\nConnect lines between the local neigbours of the 2d position map\n\n*Nearest\nConnect lines to the nearest points (in 3D space). This mode is limited to 100x100 points for performence reasons!" M {Normal Nearest "" "" "" "" "" "" "" ""}}
 addUserKnob {26 text l "Normal Mode Wires" T " "}
 addUserKnob {6 connect_x l x t "Connect wires in the (uv) X axis." -STARTLINE}
 connect_x true
 addUserKnob {6 connect_xy l xy t "Connect wires in the (uv) XY axis." -STARTLINE}
 connect_xy true
 addUserKnob {6 connect_y l y t "Connect wires in the (uv) Y axis." -STARTLINE}
 connect_y true
 addUserKnob {6 connect_aux l aux t "If you input a vector map into the Aux input for this node, and enable this option, you will get a wire from each point along that vector." -STARTLINE}
 addUserKnob {7 wire_maxdistance l "Max Distance" t "The maximum distance that the wires connect." R 0 10}
 wire_maxdistance 6
 addUserKnob {7 wire_Threshold l "Distance Threshold" t "Control the max distance threshold" R 0 2}
 wire_Threshold 0.5
 addUserKnob {3 wire_connections l "Max Connections" t "The maximum number of connections (Not Yet Implemented)"}
 wire_connections 4
 addUserKnob {7 maxSamples l "Max Line Samples" t "The maximum length of a line. Once a line is longer than this, it will start break up. \nThis can also be used as a creative effect if you set it low, try setting it to 10 in wire mode to get dotted lines" R 0 10000}
 maxSamples 10000
 addUserKnob {7 lineoffset l "Line Offset" t "Expand or contract the lines."}
 lineoffset 1
 addUserKnob {7 inGain l "In Gain" t "Gain the brightness of the in-point of the lines"}
 inGain 1
 addUserKnob {7 outGain l "Out Gain" t "Gain the brightness of the out-point of the lines" -STARTLINE}
 outGain 1
 addUserKnob {26 devider_facet l "<b><font color=#7DADF9>Facet Rendering</font><b>"}
 addUserKnob {4 renderMode l "Render Mode" t "Pick the desidered render mode." M {Diffuse "Local ST" Normal "Facing Ratio" UV ST "View Normal" "World Position" "" ""}}
 addUserKnob {6 facet_flatShading l "Flat Shading" t "Flat shading" +STARTLINE}
 addUserKnob {6 facet_depth l "Depth Buffer" t "Enable depth sorting to avoid additive surfaces." -STARTLINE}
 addUserKnob {6 facet_front l "Front Face" t "Render front facing facets" +STARTLINE}
 facet_front true
 addUserKnob {6 facet_backface l "Back Face" t "Render backfacing faces" -STARTLINE}
 facet_backface true
 addUserKnob {26 _1 l "<b><font color=#7DADF9>Other</font><b>"}
 addUserKnob {6 CloseX l "Close X" t "On spheres or round objects this closes the loop" +STARTLINE}
 addUserKnob {6 CloseY l "Close Y" t "On spheres or round objects this closes the loop" -STARTLINE}
 addUserKnob {20 Fog_1 l Fog}
 addUserKnob {26 Devider_Fog l "<b><font color=#7DADF9>Fog</font><b>"}
 addUserKnob {6 Fog t "Fog reduces the brightness of poins far from the camera." +STARTLINE}
 addUserKnob {7 FogNear l "Fog Near" R 0 200}
 FogNear 3
 addUserKnob {7 FogFar l "Fog Far" R 0 200}
 FogFar 10
 addUserKnob {7 FogExponent l "Fog Exponent" R 0 8}
 FogExponent 8
 addUserKnob {20 DepthOfField l "Depth of Field"}
 addUserKnob {26 devider_dof l "<b><font color=#7DADF9>Depth Of Field</font><b>"}
 addUserKnob {6 dof_enable l Enable +STARTLINE}
 addUserKnob {7 dof_focaldepth l "Focal Depth" R 0 40}
 dof_focaldepth 5
 addUserKnob {7 dof_dof l "Depth of Field" R 0 10}
 dof_dof 2
 addUserKnob {7 dof_maxSize l "Max Size"}
 dof_maxSize 0.5
 addUserKnob {7 dof_Aspect l "Aspect Ratio"}
 dof_Aspect 1
 addUserKnob {7 dof_bias l Bias R -3 3}
 dof_bias -0.2
 addUserKnob {4 Dof_Quality l Quality M {Low Medium High Extreme}}
 addUserKnob {20 MotionBlur}
 addUserKnob {26 devider_MotionBlur l "<b><font color=#7DADF9>Motion Blur</font><b>"}
 addUserKnob {6 mb_enable l Enable +STARTLINE}
 mb_enable true
 addUserKnob {6 Fast l "Fast (Interpolated)" -STARTLINE}
 Fast true
 addUserKnob {3 Samples}
 Samples 4
 addUserKnob {7 Shutter R 0 2}
 Shutter 0.5
 addUserKnob {4 pulldown l "Shutter Offset" M {Centered Start End ""}}
 addUserKnob {20 preview_3d l "3D Preview"}
 addUserKnob {6 Enable3DPreview l "Enable 3D Preview" t "Display a preview of the points in the Nuke 3D view." +STARTLINE}
 addUserKnob {41 pointSize l "point size" T PreviewNode.pointSize}
 addUserKnob {41 detail l "point detail" T PreviewNode.detail}
}
 BackdropNode {
  inputs 0
  name BackdropNode1
  tile_color 0x388e8e00
  label "Output Format Manager"
  note_font_size 22
  xpos -1491
  ypos 149
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode10
  tile_color 0x388e8e00
  label "AUX Input"
  note_font_size 22
  xpos -385
  ypos 178
  bdwidth 207
  bdheight 178
 }
 BackdropNode {
  inputs 0
  name BackdropNode11
  tile_color 0x388e8e00
  label "Point Render"
  note_font_size 22
  xpos -96
  ypos 99
  bdwidth 198
  bdheight 135
 }
 BackdropNode {
  inputs 0
  name BackdropNode12
  tile_color 0x388e8e00
  label "Normal Generator\nFor Vertex Normals"
  note_font_size 22
  xpos -616
  ypos 243
  bdwidth 191
  bdheight 122
 }
 BackdropNode {
  inputs 0
  name BackdropNode13
  tile_color 0x388e8e00
  label "Ensure output format"
  note_font_size 22
  xpos -622
  ypos -41
  bdwidth 198
  bdheight 135
 }
 BackdropNode {
  inputs 0
  name BackdropNode14
  tile_color 0x388e8e00
  label "Motion Blur"
  note_font_size 22
  xpos -85
  ypos 526
  bdwidth 193
  bdheight 91
 }
 BackdropNode {
  inputs 0
  name BackdropNode15
  tile_color 0x388e8e00
  label "Soft Preview"
  note_font_size 22
  xpos -83
  ypos 414
  bdwidth 191
  bdheight 94
 }
 BackdropNode {
  inputs 0
  name BackdropNode16
  tile_color 0x388e8e00
  label "Final format"
  note_font_size 22
  xpos -84
  ypos 295
  bdwidth 192
  bdheight 95
 }
 BackdropNode {
  inputs 0
  name BackdropNode17
  tile_color 0x388e8e00
  label "No Clue =)"
  note_font_size 22
  xpos -385
  ypos -41
  bdwidth 160
  bdheight 87
 }
 BackdropNode {
  inputs 0
  name BackdropNode2
  tile_color 0x388e8e00
  label Motionblur
  note_font_size 22
  xpos -672
  ypos -781
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode3
  tile_color 0x388e8e00
  label "Fast Preview"
  note_font_size 22
  xpos -669
  ypos -971
  bdwidth 254
  bdheight 138
 }
 BackdropNode {
  inputs 0
  name BackdropNode4
  tile_color 0x388e8e00
  label "Nearest Wire Mode Clamp"
  note_font_size 22
  xpos -666
  ypos -1184
  bdwidth 253
  bdheight 111
 }
 BackdropNode {
  inputs 0
  name BackdropNode5
  tile_color 0x388e8e00
  label Occlution
  note_font_size 22
  xpos 208
  ypos 27
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode6
  tile_color 0x388e8e00
  label "Input Camera Container"
  note_font_size 22
  xpos -1215
  ypos 148
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode7
  tile_color 0x388e8e00
  label "3D Preview"
  note_font_size 22
  xpos -88
  ypos -45
  bdwidth 207
  bdheight 102
 }
 BackdropNode {
  inputs 0
  name BackdropNode8
  tile_color 0x388e8e00
  label "Input Format Manager"
  note_font_size 22
  xpos -526
  ypos -459
  bdwidth 208
  bdheight 97
 }
 BackdropNode {
  inputs 0
  name BackdropNode9
  tile_color 0x388e8e00
  label FOG
  note_font_size 22
  xpos -602
  ypos -253
  bdwidth 370
  bdheight 152
 }
 Input {
  inputs 0
  name InputPointData
  xpos -584
  ypos -1321
 }
 Dot {
  name Dot4
  xpos -550
  ypos -1234
 }
set N4025cfe0 [stack 0]
 Reformat {
  type "to box"
  box_width 100
  box_height 100
  box_fixed true
  scale 0.1
  resize fill
  filter impulse
  black_outside true
  name Reformat5
  xpos -584
  ypos -906
  disable {{!parent.FastPreview==1}}
 }
 Grade {
  white 10
  name Grade2
  xpos -584
  ypos -874
  disable {{!parent.FastPreview}}
 }
 Dot {
  name Dot2
  xpos -550
  ypos -712
 }
set N40282430 [stack 0]
 Group {
  name FrameHold3
  tile_color 0xb0a45dff
  label "(frame \[value first_frames])"
  xpos -501
  ypos -719
  disable {{1-parent.mb_enable}}
  addUserKnob {20 User}
  addUserKnob {3 first_frames l "first frame"}
  first_frames {{frame+1}}
  addUserKnob {41 increment T FrameHold2.increment}
  addUserKnob {22 SetCurrentFrame l "Set This Frame" T "nuke.thisNode()\[\"first_frames\"].setValue(nuke.frame())" +STARTLINE}
 }
  Input {
   inputs 0
   name Input1
   xpos -7
   ypos -154
  }
  FrameHold {
   first_frame {{parent.knob.first_frames}}
   name FrameHold2
   xpos -7
   ypos -114
  }
  Output {
   name Output1
   xpos -7
   ypos -14
  }
 end_group
 Dot {
  name Dot6
  xpos -467
  ypos -659
 }
push $N40282430
 Group {
  name FrameHold2
  tile_color 0xb0a45dff
  label "(frame \[value first_frames])"
  xpos -660
  ypos -719
  disable {{1-parent.mb_enable}}
  addUserKnob {20 User}
  addUserKnob {3 first_frames l "first frame"}
  first_frames {{frame}}
  addUserKnob {41 increment T FrameHold2.increment}
  addUserKnob {22 SetCurrentFrame l "Set This Frame" T "nuke.thisNode()\[\"first_frames\"].setValue(nuke.frame())" +STARTLINE}
 }
  Input {
   inputs 0
   name Input1
   xpos -7
   ypos -154
  }
  FrameHold {
   first_frame {{parent.knob.first_frames}}
   name FrameHold2
   xpos -7
   ypos -114
  }
  Output {
   name Output1
   xpos -7
   ypos -14
  }
 end_group
 Dot {
  name Dot5
  xpos -626
  ypos -659
 }
 Dissolve {
  inputs 2
  which {{frame-floor(frame)}}
  name Dissolve1
  xpos -582
  ypos -666
  disable {{1-parent.mb_enable}}
 }
push $N40282430
 Switch {
  inputs 2
  which {{parent.Fast}}
  name Switch2
  xpos -582
  ypos -619
 }
 Dot {
  name DataFetch
  label "data fetch\t"
  note_font_color 0xff21ff
  xpos -550
  ypos -513
  addUserKnob {20 User}
  addUserKnob {3 n_particles l "Number of Particles"}
  n_particles {{"\[metadata pointrender/n_points]"}}
  addUserKnob {3 gentype l "Type Of Generator"}
  gentype {{"\[metadata pointrender/gen_type]"}}
  addUserKnob {26 info l "" -STARTLINE T "0 = unknown, 1 = Card, 2 = Sphere, 3 = Grid"}
 }
set N4013d0a0 [stack 0]
 Dot {
  name Dot3
  xpos -635
  ypos -513
 }
 Dot {
  name Dot1
  xpos -635
  ypos 676
 }
 Input {
  inputs 0
  name InputOcclution
  xpos 238
  ypos 75
  number 2
 }
 Constant {
  inputs 0
  channels rgb
  color 1
  name Empty
  xpos 371
  ypos 139
 }
 Switch {
  inputs 2
  which {{parent.UseOcclusionMap}}
  name Switch1
  xpos 238
  ypos 163
 }
 Input {
  inputs 0
  name Aux
  xpos -324
  ypos 214
  number 3
 }
 Reformat {
  type "to box"
  format "1280 720 0 0 1280 720 1 HD_720"
  box_width {{input.width>Settings_Format.format.width?input.width:Settings_Format.format.width}}
  box_height {{input.height>Settings_Format.format.height?input.height:Settings_Format.format.height}}
  box_fixed true
  resize none
  center false
  filter impulse
  black_outside true
  name Reformat2
  xpos -324
  ypos 238
 }
 Crop {
  box {0 0 {input.width} {input.height}}
  name Crop1
  xpos -324
  ypos 275
 }
push $N4013d0a0
 Shuffle {
  in pos
  name Shuffle1
  xpos -584
  ypos -192
 }
set N68f951e0 [stack 0]
 Reformat {
  type "to box"
  format "1280 720 0 0 1280 720 1 HD_720"
  box_width {{input.width>Settings_Format.format.width?input.width:Settings_Format.format.width}}
  box_height {{input.height>Settings_Format.format.height?input.height:Settings_Format.format.height}}
  box_fixed true
  resize none
  center false
  filter impulse
  black_outside true
  name Reformat4
  xpos -584
  ypos 18
 }
 Crop {
  box {0 0 {input.width} {input.height}}
  name Crop2
  xpos -584
  ypos 48
 }
 Dot {
  name Dot8
  xpos -550
  ypos 166
 }
set N68fc0100 [stack 0]
 Group {
  name Point_Normal2
  tile_color 0x434343ff
  note_font_color 0x55ffffff
  xpos -584
  ypos 311
  disable {{!(renderMode==2&&RenderMode==2)}}
  addUserKnob {20 User}
  addUserKnob {26 info l "" +STARTLINE T "Point Normal v1.0"}
  addUserKnob {26 devider_general l "<b><font color=#7DADF9>General</font><b>"}
  addUserKnob {26 info_1 l "" +STARTLINE T "well, not much to do here =)"}
 }
  Input {
   inputs 0
   name Input1
   xpos 389
   ypos 207
  }
  Shuffle {
   in pos
   name Shuffle1
   xpos 389
   ypos 294
  }
  BlinkScript {
   kernelSourceFile /Users/madshagbarth/Github/Nuke-Private/Blink/PointRender/Modify/BasicLight.cpp
   recompileCount 69
   ProgramGroup 1
   KernelDescription "2 \"PointRender3D\" iterate pixelWise d5452fe7b684561fcfa5182d0c789025a037cc4fe4474c24e065e3fa53fcd8ce 2 \"ppos\" Read Random \"dst\" Write Point 9 \"cam_Matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== \"focallength\" Float 1 AAA4QQ== \"hapeture\" Float 1 ppvEQQ== \"format\" Int 2 AAgAAAAIAAA= \"Zoom\" Float 1 AACAPw== \"half Lambert\" Bool 1 AQ== \"light Mode\" Int 1 AAAAAA== \"light_position\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"light_color\" Float 3 AACAPwAAgD8AAIA/AAAAAA== 9 \"cam_Matrix\" 16 1 \"cam_Focal\" 1 1 \"cam_Hapeture\" 1 1 \"WHformat\" 2 1 \"zoom\" 1 1 \"halfLambert\" 1 1 \"lightMode\" 1 1 \"lightPos\" 3 1 \"lightcolor\" 3 1 10 \"vRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"pRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"tRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"vWorld\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"canvasWidth\" Float 1 1 AAAAAA== \"canvasHeight\" Float 1 1 AAAAAA== \"matrixData\" Float 1 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cameraToWorld\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"worldToCamera\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"namount\" Float 1 1 AAAAAA=="
   kernelSource "inline float Frac(float a_X)\n\{\n    return a_X-floor(a_X);\n\}\n\ninline float Fmax(float a_X,float b_X,float c_X)\n\{\n    return max(c_X,max(a_X,b_X));\n\}\ninline float Fmin(float a_X,float b_X,float c_X)\n\{\n    return min(c_X,min(a_X,b_X));\n\}\n\ninline float saturate(float _in)\n\{\n    return max(0.0f,min(1.0f,_in));\n\}\n\ninline float3 reflect(float3 incidence,float3 normal)\n\{\n  return incidence - 2.f * dot(incidence, normal) * normal;\n\}\n\n//This function is used to multiply a float3 by a matrix4x4\ninline float3 multVecMatrix( float3 src, float4x4 matrix)\n\{\n    float   x,y,z,w;\n    \n    x = src\[0]*matrix\[0]\[0] + src\[1]*matrix\[1]\[0] +\n    src\[2]*matrix\[2]\[0] + matrix\[3]\[0];\n    y = src\[0]*matrix\[0]\[1] + src\[1]*matrix\[1]\[1] +\n    src\[2]*matrix\[2]\[1] + matrix\[3]\[1];\n    z = src\[0]*matrix\[0]\[2] + src\[1]*matrix\[1]\[2] +\n    src\[2]*matrix\[2]\[2] + matrix\[3]\[2];\n    w = src\[0]*matrix\[0]\[3] + src\[1]*matrix\[1]\[3] +\n    src\[2]*matrix\[2]\[3] + matrix\[3]\[3];\n    \n    return float3(x/w, y/w, z/w);\n\}\n\n//This function is used to calculate the screenspace coordinates.\ninline bool computePixelCoordinates( \n    const float3 pWorld, \n    float3 &pRaster, \n    const float4x4 &worldToCamera, \n    const float &canvasWidth, \n    const float &canvasHeight, \n    const int &imageWidth, \n    const int &imageHeight\n) \n\{ \n    float3 pCamera; \n    pCamera = multVecMatrix(pWorld, worldToCamera); \n    float2 pScreen; \n    pScreen.x = pCamera.x / -pCamera.z; \n    pScreen.y = pCamera.y / -pCamera.z; \n    if (fabs(pScreen.x) > canvasWidth || fabs(pScreen.y) > canvasHeight) \n         return false; \n    float2 pNDC; \n    pNDC.x = (pScreen.x + canvasWidth * 0.5f) / canvasWidth; \n    pNDC.y = (pScreen.y + canvasHeight * 0.5f) / canvasHeight; \n    pRaster.x = (pNDC.x * imageWidth); \n    pRaster.y = ((pNDC.y) * imageHeight); \n    pRaster.z = -pCamera.z; \n    if (pRaster.x < 0.0f || pRaster.x > imageWidth || \n       pRaster.y < 0.0f || pRaster.y > imageHeight) \{\n       return false;  \n    \}\n    return true;\n\} \n\n\n\nkernel PointRender3D : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessRandom, eEdgeClamped> ppos;    //The point position map\n  Image<eWrite> dst;                 //the output image\n\n  param: //Parameters available to the user\n    float4x4 cam_Matrix;    //The world matrix of the camera\n    float cam_Focal;        //The focal length of the camera\n    float cam_Hapeture;     //The horizontal apeture of the camera\n    int2 WHformat;          //The format of the output image\n    float zoom;             //A \"post\" zoom function\n    bool halfLambert;\n    int lightMode;\n    float3 lightPos;\n    float3 lightcolor;\n\n\n  local: //Local variables\n    float3 vRaster;\n    float3 pRaster;\n    float3 tRaster;    \n    float3 vWorld;\n    float canvasWidth;\n    float canvasHeight; \n    float matrixData\[4]\[4];\n    float4x4 cameraToWorld;\n    float4x4 worldToCamera;\n    float namount; //dither amount\n\n\n  void define() \{\n    defineParam(cam_Matrix, \"cam_Matrix\", float4x4( 1.0f,0.0f,0.0f,0.0f,\n                                                    0.0f,1.0f,0.0f,0.0f,\n                                                    0.0f,0.0f,1.0f,0.0f,\n                                                    0.0f,0.0f,0.0f,1.0f));\n    defineParam(cam_Focal,      \"focallength\", 11.5f);\n    defineParam(cam_Hapeture,      \"hapeture\", 24.576f);\n    defineParam(WHformat,      \"format\", int2(2048,2048));\n    defineParam(zoom, \"Zoom\", 1.0f);\n    defineParam(halfLambert, \"half Lambert\", true);\n    defineParam(lightMode, \"light Mode\", 0);\n    defineParam(lightPos,      \"light_position\", float3(0,0,0));  \n    defineParam(lightcolor,      \"light_color\", float3(1.0,1.0,1.0)); \n  \}\n\n\n  //The init() function is run before any calls to process().\n  void init() \{\n    canvasWidth = ((cam_Hapeture)/cam_Focal);\n    canvasHeight = ((cam_Hapeture)/cam_Focal)*float(float(WHformat.y)/float(WHformat.x)); \n    float matrixData\[] = \{cam_Matrix\[0]\[0], cam_Matrix\[1]\[0], cam_Matrix\[2]\[0], cam_Matrix\[3]\[0], \n                          cam_Matrix\[0]\[1], cam_Matrix\[1]\[1], cam_Matrix\[2]\[1], cam_Matrix\[3]\[1], \n                          cam_Matrix\[0]\[2], cam_Matrix\[1]\[2], cam_Matrix\[2]\[2], cam_Matrix\[3]\[2], \n                          cam_Matrix\[0]\[3], cam_Matrix\[1]\[3], cam_Matrix\[2]\[3], cam_Matrix\[3]\[3]\};\n    cameraToWorld.setArray(matrixData); //This is a workaround. Due to the buggy matrix implementation, we pass the matrix on from another structure.\n    worldToCamera = cameraToWorld.invert();\n    namount = 0.0001; //dither amount\n  \}\n\n\n\nfloat3 Reconsile3D(float3 _PointPos)\{\n    vWorld = float3(_PointPos.x,_PointPos.y,_PointPos.z)*(zoom);\n    int ret = computePixelCoordinates(vWorld, tRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1]);\n    return tRaster;\n\}\n\n\n\n//-------------------------------------\n// Facet_Render\n//-------------------------------------\n//This function is used to calculate what triangels to draw\nfloat3 facet_render(int2 pos, float3 _vWorld)\{\n\n    float3 screen_pos = Reconsile3D(_vWorld);\n    bool insideX = ppos.bounds.inside(pos.x+1,pos.y );\n    bool insideY = ppos.bounds.inside(pos.x,pos.y-1 );\n    bool insideYtop = ppos.bounds.inside(pos.x,pos.y+1);\n    float2 fpos = float2(pos.x,pos.y);\n    float3 V1_Pos,V2_Pos,V1_wPos,V2_wPos;\n    float4 V0_Sample,V1_Sample,V2_Sample;\n    float3 normal0,normal1,normal2;\n\n    //for area calculation\n    float area;\n    float3 V0,V1,V2;\n    float3 output = float3(0.0f);\n  if (insideX) \{\n    V2_Sample = ppos(pos.x+1,pos.y);\n    V2_wPos = float3(V2_Sample.x,V2_Sample.y,V2_Sample.z);\n    V2_Pos = Reconsile3D(V2_wPos);\n    if (V2_Sample.w != 0.0f) \{ \n\n      if (insideY) \{\n        V1_Sample = ppos(pos.x+1,pos.y-1);\n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (V1_Sample.w != 0.0f) \{ \n            float3 Normal = CalculateVertexNormals(_vWorld,V2_wPos,V1_wPos);\n\n            //Calculate Area for density:\n            V0 = screen_pos;\n            V1 = V1_Pos;\n            V2 = V2_Pos;\n            V0.z = 1.0f / V0.z, V1.z = 1.0f / V1.z, V2.z = 1.0f / V2.z; \n            area = length(V0-V1)+length(V0-V2)+length(V1-V2);\n\n          //write output\n          output +=  float3(Normal.x,Normal.y,Normal.z);\n        \}\n      \}\n      if (insideYtop) \{\n        V1_Sample = ppos(pos.x,pos.y+1);\n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (V1_Sample.w != 0.0f) \{ \n          float3 Normal = CalculateVertexNormals(_vWorld,V1_wPos,V2_wPos);\n\n            //Calculate Area for density:\n            V0 = screen_pos;\n            V1 = V1_Pos;\n            V2 = V2_Pos;\n            V0.z = 1.0f / V0.z, V1.z = 1.0f / V1.z, V2.z = 1.0f / V2.z; \n            area = length(V0-V1)+length(V0-V2)+length(V1-V2);\n\n          output += float3(Normal.x,Normal.y,Normal.z);\n\n        \}\n      \}\n    \}\n  \}\n  return output;\n\}\n\n\n\nfloat3 CalculateSurfaceNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat3 CalculateVertexNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 hitNormal = cross((V1 - V0),(V2 - V0)); \n        return hitNormal;\n\}\n\n\n\n//-------------------------------------\n// Process\n//-------------------------------------\n  void process(int2 pos) \{\n    float3 output = float3(0.0f);\n    float4 _sample = ppos(pos.x,pos.y); //Get the XYZ Coordinates\n    float3 point_pos = float3(_sample.x,_sample.y,_sample.z);\n    if (_sample.w != 0.0f) \{  //No need to process if there is no data.\n      dst() = float4(0.0f);\n      output+=facet_render(pos,float3(_sample.x,_sample.y,_sample.z))*2.0f;\n      _sample = ppos(pos.x-1,pos.y); //Get the XYZ Coordinates\n      output+=facet_render(int2(pos.x-1,pos.y),float3(_sample.x,_sample.y,_sample.z));\n\n      _sample = ppos(pos.x-1,pos.y+1); //Get the XYZ Coordinates\n      output+=facet_render(int2(pos.x-1,pos.y+1),float3(_sample.x,_sample.y,_sample.z));\n\n      _sample = ppos(pos.x,pos.y-1); //Get the XYZ Coordinates\n      output+=facet_render(int2(pos.x,pos.y-1),float3(_sample.x,_sample.y,_sample.z));\n\n      output = normalize(output);\n      float3 normal = -output;\n\n      \n\n\n      dst() = float4(normal.x,normal.y,normal.z,1.0f);\n    \}\n  \} //----> process\n\};\n"
   rebuild ""
   "PointRender3D_half Lambert" false
   "PointRender3D_light Mode" {{parent.LightFalloff}}
   PointRender3D_light_position {{parent.Axis1.translate} {parent.Axis1.translate} {parent.Axis1.translate}}
   PointRender3D_light_color {{parent.LightColor} {parent.LightColor} {parent.LightColor}}
   rebuild_finalise ""
   name BlinkScript1
   xpos 389
   ypos 344
  }
  Grade {
   multiply 0.5
   add 0.5
   black_clamp false
   name Grade1
   xpos 389
   ypos 376
   disable true
  }
  Output {
   name Output1
   xpos 389
   ypos 459
  }
  Axis2 {
   inputs 0
   translate {0.5 0.5 0.5}
   name Axis1
   xpos 661
   ypos 318
   addUserKnob {20 Ivy}
   addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.toolbox.v1.nodes.docs', fromlist=\['open_docs_name']).open_docs_name('IvyTab')" +STARTLINE}
   addUserKnob {26 divider4 l "" +STARTLINE}
   addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
   _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
   addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
   addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
   addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
   _expressions {{curve}}
   addUserKnob {26 divider0 l "" +STARTLINE}
   addUserKnob {20 dbinfo l "DB Info" n 1}
   dbinfo 0
   addUserKnob {1 twig_dnuuid l "Twig Id"}
   addUserKnob {1 stalk_dnuuid l "Stalk Id"}
   addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
   addUserKnob {1 leaf_dnuuid l "Leaf Id"}
   addUserKnob {26 divider1 l "" +STARTLINE}
   addUserKnob {1 twigtype l "Twig Type"}
   addUserKnob {1 leaf_label l Leaf}
   addUserKnob {1 ivy_version l Version}
   addUserKnob {43 ivy_notes l Notes}
   addUserKnob {26 divider2 l "" +STARTLINE}
   addUserKnob {1 build_label l "Build Label"}
   addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
  }
 end_group
 Switch {
  inputs 2
  which {{parent.connect_aux}}
  name Switch3
  xpos -324
  ypos 311
 }
push $N68f951e0
 Expression {
  temp_name0 xd
  temp_expr0 red-Camera1.world_matrix.3
  temp_name1 yd
  temp_expr1 green-Camera1.world_matrix.7
  temp_name2 zd
  temp_expr2 blue-Camera1.world_matrix.11
  temp_name3 Distance
  temp_expr3 "sqrt(xd*xd + yd*yd + zd*zd)"
  expr0 Distance
  expr1 Distance
  expr2 Distance
  expr3 Distance
  name Expression1
  xpos -456
  ypos -192
 }
 Grade {
  channels rgba
  blackpoint {{parent.FogFar}}
  whitepoint {{parent.FogNear}}
  gamma {{1/(parent.FogExponent+0.000000001)}}
  white_clamp true
  name Grade1
  xpos -456
  ypos -168
 }
push $N4013d0a0
 Dot {
  name Dot7
  xpos -307
  ypos -513
 }
 Merge2 {
  inputs 2
  operation multiply
  name Merge1
  xpos -341
  ypos -168
  disable {{!parent.Fog}}
 }
 Shuffle {
  name Shuffle3
  xpos -341
  ypos 8
 }
set N68e76530 [stack 0]
push $N68fc0100
 BlinkScript {
  inputs 4
  kernelSourceFile /Users/madshagbarth/Github/Nuke-Private/Blink/PointRender/Render/3D_PointRender_v15.cpp
  recompileCount 792
  ProgramGroup 1
  KernelDescription "2 \"PointRender3D\" iterate pixelWise e0ecbbf4cba39730471d23bc9f9ec846fcae1bbb869971a11b15641cf6fd5620 5 \"ppos\" Read Random \"src\" Read Random \"normals\" Read Random \"occlusion\" Read Random \"dst\" Write Random 48 \"cam_Matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== \"focallength\" Float 1 AAA4QQ== \"hapeture\" Float 1 ppvEQQ== \"format\" Int 2 AAgAAAAIAAA= \"vertexformat\" Int 2 CgAAAAoAAAA= \"Zoom\" Float 1 AACAPw== \"Filtering Method\" Int 1 AQAAAA== \"_alphaMultiplier\" Float 1 AACAPw== \"_pointRender\" Bool 1 AQ== \"_wireRender\" Bool 1 AQ== \"_facetRender\" Bool 1 AQ== \"_maxLDistance\" Float 1 AACAPw== \"_maxLConnections\" Int 1 AQAAAA== \"_maxPlexType\" Int 1 AAAAAA== \"_plexLinedefXY\" Bool 1 AA== \"_plexLinedefX\" Bool 1 AA== \"_plexLinedefY\" Bool 1 AA== \"_plexLinedefXtoY\" Bool 1 AA== \"_plexLinedefAUX\" Bool 1 AA== \"_plexConnectX\" Bool 1 AA== \"_plexConnectY\" Bool 1 AA== \"_L_gamma\" Float 1 AACAPw== \"Enable Depth of Field\" Bool 1 AA== \"samples\" Int 1 AwAAAA== \"rings\" Int 1 BQAAAA== \"focalDepth\" Float 1 AACAPw== \"_depthOfField\" Float 1 AACAQA== \"_depthMult\" Float 1 zczMPQ== \"_maxDofSize\" Float 1 AAAAQQ== \"dof_aspect\" Float 1 AACAPw== \"dof_threshold\" Float 1 AACAPw== \"dof_gain\" Float 1 AAAAAA== \"dof_bias\" Float 1 AAAAwA== \"dof_fringe\" Float 1 AAAAAA== \"_flatshading\" Bool 1 AQ== \"_backfacing\" Bool 1 AQ== \"_frontfacing\" Bool 1 AQ== \"_vertexMode\" Int 1 AAAAAA== \"_depthBuffer\" Bool 1 AQ== \"_texoffset\" Float 2 AAAAPwAAAD8= \"_pointSize\" Int 1 AQAAAA== \"_gaussigma\" Float 1 AACAPw== \"_depthOcclusion\" Bool 1 AQ== \"depthMultiplier\" Float 1 AACAPw== \"_maxLineSteps\" Float 1 AAB6RQ== \"_lineOffset\" Float 1 AACAPw== \"_lineInMultiplier\" Float 1 AACAPw== \"_lineOutMultiplier\" Float 1 AACAPw== 48 \"cam_Matrix\" 16 1 \"cam_Focal\" 1 1 \"cam_Hapeture\" 1 1 \"WHformat\" 2 1 \"Vformat\" 2 1 \"zoom\" 1 1 \"_filtering\" 1 1 \"_alphaMultiplier\" 1 1 \"_pointRender\" 1 1 \"_wireRender\" 1 1 \"_facetRender\" 1 1 \"_maxPlexDistance\" 1 1 \"_maxPlexConnections\" 1 1 \"_maxPlexType\" 1 1 \"_plexLinedefXY\" 1 1 \"_plexLinedefX\" 1 1 \"_plexLinedefY\" 1 1 \"_plexLinedefXtoY\" 1 1 \"_plexLinedefAUX\" 1 1 \"_plexConnectX\" 1 1 \"_plexConnectY\" 1 1 \"_plex_gamma\" 1 1 \"_dof_enable\" 1 1 \"_dof_samples\" 1 1 \"_dof_rings\" 1 1 \"focalDepth\" 1 1 \"_depthOfField\" 1 1 \"_depthMult\" 1 1 \"_maxDofSize\" 1 1 \"dof_aspect\" 1 1 \"dof_threshold\" 1 1 \"dof_gain\" 1 1 \"dof_bias\" 1 1 \"dof_fringe\" 1 1 \"_flatshading\" 1 1 \"_backfacing\" 1 1 \"_frontfacing\" 1 1 \"_vertexMode\" 1 1 \"_depthBuffer\" 1 1 \"_texoffset\" 2 1 \"_pointSize\" 1 1 \"_gaussigma\" 1 1 \"_depthOcclusion\" 1 1 \"depthMultiplier\" 1 1 \"_maxLineSteps\" 1 1 \"_lineOffset\" 1 1 \"_lineInMultiplier\" 1 1 \"_lineOutMultiplier\" 1 1 10 \"max_line_connections\" Int 1 1 AAAAAA== \"vRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"pRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"tRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"vWorld\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"canvasWidth\" Float 1 1 AAAAAA== \"canvasHeight\" Float 1 1 AAAAAA== \"matrixData\" Float 1 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cameraToWorld\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"worldToCamera\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "//Some basic generic functions.\ninline float Frac(float a_X)\n\{\n    return a_X-floor(a_X);\n\}\n\ninline float3 Cross(float3 A,float3 B)\n\{\n    return float3(A.y*B.z - A.z*B.y,A.z*B.x - A.x*B.z,A.x*B.y - A.y*B.x);\n\}\n\ninline float Fmax(float a_X,float b_X,float c_X)\n\{\n    return max(c_X,max(a_X,b_X));\n\}\ninline float Fmin(float a_X,float b_X,float c_X)\n\{\n    return min(c_X,min(a_X,b_X));\n\}     \n\ninline float3 mix(float3 _X,float3 _Y,float _A)\{\n  return _X*(1.0f-_A)+_Y*_A;\n\}\ninline float mix(float _X,float _Y,float _A)\{\n  return _X*(1.0f-_A)+_Y*_A;\n\}                                                                                              \n\n//This function is used to multiply a float3 by a matrix4x4\ninline float3 multVecMatrix( float3 src, float4x4 matrix)\n\{\n    float   x,y,z,w;\n\n    x = src\[0]*matrix\[0]\[0] + src\[1]*matrix\[1]\[0] +\n    src\[2]*matrix\[2]\[0] + matrix\[3]\[0];\n    y = src\[0]*matrix\[0]\[1] + src\[1]*matrix\[1]\[1] +\n    src\[2]*matrix\[2]\[1] + matrix\[3]\[1];\n    z = src\[0]*matrix\[0]\[2] + src\[1]*matrix\[1]\[2] +\n    src\[2]*matrix\[2]\[2] + matrix\[3]\[2];\n    w = src\[0]*matrix\[0]\[3] + src\[1]*matrix\[1]\[3] +\n    src\[2]*matrix\[2]\[3] + matrix\[3]\[3];\n    \n    return float3(x/w, y/w, z/w);\n\}\n\n//This function is used to calculate the screenspace coordinates.\ninline bool computePixelCoordinates( \n    const float3 pWorld, \n    float3 &pRaster, \n    const float4x4 &worldToCamera, \n    const float &canvasWidth, \n    const float &canvasHeight, \n    const int &imageWidth, \n    const int &imageHeight\n) \n\{ \n    float3 pCamera; \n    pCamera = multVecMatrix(pWorld, worldToCamera); \n    float2 pScreen; \n    pScreen.x = pCamera.x / -pCamera.z; \n    pScreen.y = pCamera.y / -pCamera.z; \n    float2 pNDC; \n    pNDC.x = (pScreen.x + canvasWidth * 0.5f) / canvasWidth; \n    pNDC.y = (pScreen.y + canvasHeight * 0.5f) / canvasHeight; \n    pRaster.x = (pNDC.x * imageWidth); \n    pRaster.y = ((pNDC.y) * imageHeight); \n    pRaster.z = -pCamera.z; \n    if (pRaster.x < 0.0f || pRaster.x > imageWidth || \n       pRaster.y < 0.0f || pRaster.y > imageHeight || pRaster.z < 0.0f) \{\n       return false;  \n    \}\n    return true;\n\} \n\n\nkernel PointRender3D : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessRandom, eEdgeClamped> ppos;    //The point position map\n  Image<eRead, eAccessRandom, eEdgeClamped> src;     //The texture map\n  Image<eRead, eAccessRandom, eEdgeClamped> normals;     //The texture map  \n  Image<eRead, eAccessRandom, eEdgeClamped> occlusion;     //The texture map \n  Image<eWrite, eAccessRandom> dst;                 //the output image\n\n  param: //Parameters available to the user\n    float4x4 cam_Matrix;    //The world matrix of the camera\n    float cam_Focal;        //The focal length of the camera\n    float cam_Hapeture;     //The horizontal apeture of the camera\n    int2 WHformat,Vformat;          //The format of the output image\n    float zoom;             //A \"post\" zoom function\n    int _filtering;        //Filter method\n    float _alphaMultiplier; //Additive multiplier\n    bool _pointRender,_wireRender,_facetRender;\n    float _maxPlexDistance; //Additive multiplier\n    int _maxPlexConnections;\n    int _maxPlexType; // 0==Grid, -1==Nearest\n    bool _plexLinedefXY,_plexLinedefX,_plexLinedefY,_plexLinedefXtoY,_plexLinedefAUX; // Define what connections NOT to include\n    bool _plexConnectX,_plexConnectY; //Connect from the edge of x to 0, or edge of y to 0, usually for spheres\n    float _plex_gamma; //The threshold making shorter paths bright and longer paths dark\n    bool _dof_enable; // Enable DOF\n    int _dof_samples; // How many samples per DOF ring\n    int _dof_rings; // How many rings \n    float focalDepth,_depthOfField,_depthMult,_maxDofSize; //DOF Settings\n    float dof_aspect; //Pixel aspect ratio\n    float dof_threshold;\n    float dof_gain;\n    float dof_bias; //bokeh edge bias\n    float dof_fringe; //bokeh chromatic aberration/fringing\n    bool _flatshading,_backfacing,_frontfacing; //Vertex rendering settings\n    int _vertexMode;  //The rendering output mode, (think AOV)\n    bool _depthBuffer; //Non-additive, only render front most pixel\n    float2 _texoffset;\n    int _pointSize;\n    float _gaussigma;\n    bool _depthOcclusion;\n    float depthMultiplier;\n    float _maxLineSteps; //cap the line length to avoid process lock\n    float _lineOffset; //Alow you to shrink or extend the lines\n    float _lineInMultiplier,_lineOutMultiplier; //Control the brightness of the wires at the tips.\n\n  local: //Local variables\n    int max_line_connections;\n    float3 vRaster;\n    float3 pRaster;\n    float3 tRaster;    \n    float3 vWorld;\n    float canvasWidth;\n    float canvasHeight; \n    float matrixData\[4]\[4];\n    float4x4 cameraToWorld;\n    float4x4 worldToCamera;\n\n  void define() \{\n    defineParam(cam_Matrix, \"cam_Matrix\", float4x4( 1.0f,0.0f,0.0f,0.0f,\n                                                    0.0f,1.0f,0.0f,0.0f,\n                                                    0.0f,0.0f,1.0f,0.0f,\n                                                    0.0f,0.0f,0.0f,1.0f));\n    defineParam(cam_Focal,      \"focallength\", 11.5f);\n    defineParam(cam_Hapeture,      \"hapeture\", 24.576f);\n    defineParam(WHformat,      \"format\", int2(2048,2048));\n    defineParam(Vformat,      \"vertexformat\", int2(10,10));\n    defineParam(zoom, \"Zoom\", 1.0f);\n    defineParam(_filtering, \"Filtering Method\", 1); \n    defineParam(_alphaMultiplier, \"_alphaMultiplier\", 1.0f);     \n    defineParam(_pointRender, \"_pointRender\", true);  \n    defineParam(_wireRender, \"_wireRender\", true);\n    defineParam(_facetRender, \"_facetRender\", true);\n    defineParam(_maxPlexDistance, \"_maxLDistance\", 1.0f);    \n    defineParam(_maxPlexConnections, \"_maxLConnections\", 1);    \n    defineParam(_maxPlexType, \"_maxPlexType\", 0); \n    defineParam(_plexLinedefXY, \"_plexLinedefXY\", false);      \n    defineParam(_plexLinedefXtoY, \"_plexLinedefXtoY\", false); //NYI\n    defineParam(_plexLinedefAUX, \"_plexLinedefAUX\", false); \n    defineParam(_plexLinedefX, \"_plexLinedefX\", false);  \n    defineParam(_plexLinedefY, \"_plexLinedefY\", false);  \n    defineParam(_plexConnectX, \"_plexConnectX\", false);      \n    defineParam(_plexConnectY, \"_plexConnectY\", false);   \n    defineParam(_plex_gamma, \"_L_gamma\", 1.0f);\n    //DOF SETTINGS   \n    defineParam(_dof_enable, \"Enable Depth of Field\", false);   \n    defineParam(_dof_samples, \"samples\", 3);    \n    defineParam(_dof_rings, \"rings\", 5);   \n    defineParam(focalDepth, \"focalDepth\", 1.0f);  \n    defineParam(_depthOfField, \"_depthOfField\", 4.0f);  \n    defineParam(_depthMult, \"_depthMult\", 0.1f);  \n    defineParam(_maxDofSize, \"_maxDofSize\", 8.0f);  \n    defineParam(dof_aspect, \"dof_aspect\", 1.0f);  \n    defineParam(dof_threshold, \"dof_threshold\", 1.0f);  \n    defineParam(dof_gain, \"dof_gain\", 0.0f);  \n    defineParam(dof_bias, \"dof_bias\", -2.0f);  \n    defineParam(dof_fringe, \"dof_fringe\", 0.0f); \n    //SHADING SETTINGS \n    defineParam(_flatshading, \"_flatshading\", true);  \n    defineParam(_vertexMode, \"_vertexMode\", 0);  \n    defineParam(_backfacing, \"_backfacing\", true);    \n    defineParam(_frontfacing, \"_frontfacing\", true);        \n    defineParam(_depthBuffer, \"_depthBuffer\", true);  \n    defineParam(_texoffset, \"_texoffset\", float2(0.5f,0.5f)); \n    defineParam(_pointSize, \"_pointSize\", 1); \n    defineParam(_gaussigma, \"_gaussigma\", 1.0f); \n    defineParam(_depthOcclusion, \"_depthOcclusion\", true); \n    defineParam(depthMultiplier, \"depthMultiplier\", 1.0f); \n    defineParam(_maxLineSteps, \"_maxLineSteps\", 4000.0f); \n    defineParam(_lineOffset, \"_lineOffset\", 1.0f); \n    defineParam(_lineInMultiplier, \"_lineInMultiplier\", 1.0f);   \n    defineParam(_lineOutMultiplier, \"_lineOutMultiplier\", 1.0f);     \n\n  \}\n\n  //The init() function is run before any calls to process().\n  void init() \{\n    max_line_connections = 80;\n    canvasWidth = ((cam_Hapeture)/cam_Focal);\n    canvasHeight = ((cam_Hapeture)/cam_Focal)*float(float(WHformat.y)/float(WHformat.x)); \n    float matrixData\[] = \{cam_Matrix\[0]\[0], cam_Matrix\[1]\[0], cam_Matrix\[2]\[0], cam_Matrix\[3]\[0], \n                          cam_Matrix\[0]\[1], cam_Matrix\[1]\[1], cam_Matrix\[2]\[1], cam_Matrix\[3]\[1], \n                          cam_Matrix\[0]\[2], cam_Matrix\[1]\[2], cam_Matrix\[2]\[2], cam_Matrix\[3]\[2], \n                          cam_Matrix\[0]\[3], cam_Matrix\[1]\[3], cam_Matrix\[2]\[3], cam_Matrix\[3]\[3]\};\n    cameraToWorld.setArray(matrixData); //This is a workaround. Due to the buggy matrix implementation, we pass the matrix on from another structure.\n    worldToCamera = cameraToWorld.invert();\n  \}\n\n  //Convert a 3d point position into a 2d raster position.\n  float3 Reconsile3D(float3 _PointPos)\{\n      vWorld = float3(_PointPos.x,_PointPos.y,_PointPos.z)*(zoom);\n      int ret = computePixelCoordinates(vWorld, tRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1]);\n      return tRaster;\n  \}\n\n//------------------------------\n//-------DRAW FUNCTIONS---------\n//------------------------------\n  //Write pixels to output.\n  void writepixel(float posx,float posy, float4 color,int index,float weight=1.0f)\n  \{ \n      if (_depthOcclusion)\{\n        float4 depthSample = occlusion(posx,posy);\n        if (depthSample.x<=vRaster.z && depthSample.w>0.0f)\{\n\n          float depth = (vRaster.z-depthSample.x);\n          color = color*(1.0f-depthSample.w);\n          color = color / (((depth*depth)*depthMultiplier)+1.0f);\n          //return;\n        \}\n      \}\n      float4 finalOutput; //This is used to store the final output\n      float4 dstSample; //This is used to store a sample of the destination\n      if ( dst.bounds.inside( posx, posy ) ) \{ //Test if the pixel written to is inside the output image. \n        if (_depthBuffer) \{\n          dstSample = (float4)dst(posx,posy); //Sample the destination image\n          if ((dstSample.w>color.w)||dstSample.w==0.0f) \{\n            dst(posx,posy) = color;\n          \}\n        \}\n        else \{\n          dstSample = (float4)dst(posx,posy); //Sample the destination image\n          finalOutput = dstSample + (color*_alphaMultiplier*weight);\n          finalOutput.w = dstSample.w + ((color.w*_alphaMultiplier*weight));\n\n          finalOutput.w = (dstSample.w + ((color.w*_alphaMultiplier*weight)))-(dstSample.w * ((color.w*_alphaMultiplier*weight)));\n\n          dst(posx,posy) = finalOutput;\n        \}\n      \} \n  \}\n\n  //Calculate a Bilinear Plot\n  void bilinear_Plot(float2 temppos,float4 color,int index)\n  \{\n    float2 p;\n    p.x=Frac(temppos.x);\n    p.y=Frac(temppos.y);\n    float weights\[] = \{(1.0f-p.x)*(1.0f-p.y), p.x*(1.0f-p.y), (1.0f-p.x)*p.y, p.x*p.y\};\n    int2 _position = int2(floor(temppos.x)-0,floor(temppos.y)-0); \n    writepixel(_position.x,_position.y,color,index,weights\[0]);\n    writepixel(_position.x+1,_position.y,color,index,weights\[1]);\n    writepixel(_position.x,_position.y+1,color,index,weights\[2]);\n    writepixel(_position.x+1,_position.y+1,color,index,weights\[3]);\n  \}\n\n  //NYI, unused!\n  void gaussian(float2 temppos,float4 color,int index)\{\n    float in_x = temppos.x;\n    float in_y = temppos.y;\n    int kernelSize = (_pointSize+1)*2;\n    int subsize = (kernelSize /2)-1;\n    float gKernel\[64]\[64];\n    float sigma = _gaussigma;\n    float intSigma = float(_pointSize);\n    float r, s = intSigma * sigma * sigma;\n\n    float sum = 0.0f;\n\n    // generate 5x5 kernel\n    for (int x = -subsize; x <= subsize; x++)\n    \{\n        for(int y = -subsize; y <= subsize; y++)\n        \{\n            r = float(sqrt(x*x + y*y));\n            gKernel\[x + subsize]\[y + subsize] = (exp(-(r*r)/s))/(3.141592654f * s);\n            sum += gKernel\[x + subsize]\[y + subsize];\n        \}\n    \}\n\n    // normalize the Kernel\n    for (int x = -subsize; x <= subsize; x++)\n    \{\n        for(int y = -subsize; y <= subsize; y++)\n        \{\n            gKernel\[x + subsize]\[y + subsize] /= sum;\n            writepixel(in_x+x,in_y+y,color,index,gKernel\[x + subsize]\[y + subsize]);\n        \}\n    \}\n  \}\n\n//-------------------------------------\n// DrawLine\n// ----------\n// Draw a line between two points, \n// x,y being 2d screenspace pos and z being depth.\n//-------------------------------------\n  void DrawLine(float3 origin, float3 endpoint,float4 _colorA,float4 _colorB) \{\n    float4 _color;\n    float3 delta = origin-endpoint;\n    float3 curPoint = origin;\n    float mag = sqrt(delta.x*delta.x+delta.y*delta.y);\n    mag = min(mag,_maxLineSteps); //Lets not go crazy, we cap it at 10.000 to avoid insane unwated processing time \n    for( float a = 0; a < mag*_lineOffset; a = a + 1.0f )\{\n      curPoint -= (delta/mag);\n      _color = (_colorA*(1.0f-(a/mag*1.0f)))+(_colorB*(a/mag*1.00f));\n      if (_dof_enable)\{\n        Bokeh(curPoint,_color);\n      \}\n      else \{\n        bilinear_Plot(float2(curPoint.x,curPoint.y),_color,1);\n      \}\n      \n    \}\n  \}\n\n//-------------------------------------\n// Point_Render\n//-------------------------------------\nvoid point_render(int2 pos, float3 screen_pos)\{\n  float4 color = src(pos.x,pos.y);\n\n  if (_filtering == 1)\{\n      if (_dof_enable)\{\n        Bokeh(screen_pos,color);\n      \}\n      else \{\n        bilinear_Plot(float2(screen_pos.x,screen_pos.y),color,1);\n      \}\n  \}\n  /*\n  //THIS PART NEEDS TO BE RE-WRITTEN.\n  else if (_filtering == 2)\{ \n      if (_dof_enable)\{\n        Bokeh(screen_pos,color);\n      \}\n      else \{\n        gaussian(float2(screen_pos.x,screen_pos.y),color,1);\n      \}\n  \}\n  */\n  else \{\n      int2 _position = int2(floor(screen_pos.x),floor(screen_pos.y)); \n      if (_depthBuffer) \{color.w = screen_pos.z;\}\n      writepixel(_position.x,_position.y, color,1,1.0f); //OutputSample\n  \}\n\n\}\n\n//-------------------------------------\n// Facet_Render\n//-------------------------------------\n//This function is used to calculate what triangels to draw\nvoid facet_render(int2 pos, float3 _vWorld)\{\n\n    float3 screen_pos = Reconsile3D(_vWorld);\n\n    bool insideX = ppos.bounds.inside(pos.x+1,pos.y );\n    bool insideY = ppos.bounds.inside(pos.x+1,pos.y-1 );\n    bool insideYtop = ppos.bounds.inside(pos.x,pos.y+1);\n    float2 fpos = float2(pos.x,pos.y);\n    float3 V1_Pos,V2_Pos,V1_wPos,V2_wPos,V0_N,V1_N,V2_N;\n    float2 V0_ST,V1_ST,V2_ST;\n    float4 V1_Sample,V2_Sample;\n    float4 _tn;\n    float3 normal0,normal1,normal2;\n    float2 UV_Format = float2(Vformat.x,Vformat.y);\n\n\n    int2 P0 = int2(pos.x-1,pos.y-1);\n    int2 P1 = int2(pos.x+1,pos.y+1);\n    if (_plexConnectX && pos.x == int(Vformat.x))\{\n      insideX == true;\n      P1 = int2(0.0f,pos.y+1);\n    \}\n    if (_plexConnectY && pos.y == int(Vformat.y))\{\n      insideYtop == true;\n      P1 = int2(pos.x+1,0);\n    \} \n\n    if (_plexConnectY && pos.y == 0)\{\n      insideY == true;\n      P0 = int2(pos.x-1,int(UV_Format.y));\n    \} \n\n    if (!_flatshading) \{\n      _tn = normals(pos.x,pos.y);\n      V0_N =float3(_tn.x,_tn.y,_tn.z);\n    \}\n    V0_ST = float2(pos.x,pos.y)/UV_Format;\n\n  if (insideX) \{\n    V2_Sample = ppos(P1.x,pos.y);\n    V2_ST = float2(P1.x,pos.y)/UV_Format;\n    V2_wPos = float3(V2_Sample.x,V2_Sample.y,V2_Sample.z);\n    V2_Pos = Reconsile3D(V2_wPos);\n    if (!_flatshading) \{\n      _tn = normals(P1.x,pos.y);\n      V2_N =float3(_tn.x,_tn.y,_tn.z);\n    \}\n        \n\n    if (V2_Sample.w != 0.0f) \{ \n\n      if (insideY) \{\n        V1_Sample = ppos(P1.x,P0.y);\n        V1_ST = float2(P1.x,P0.y)/UV_Format;\n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (!_flatshading) \{\n          _tn = normals(P1.x,P0.y);\n          V1_N =float3(_tn.x,_tn.y,_tn.z);\n        \}\n        if (V1_Sample.w != 0.0f) \{ \n          DrawTriangle(screen_pos,V2_Pos,V1_Pos,_vWorld,V2_wPos,V1_wPos,V0_N,V2_N,V1_N,V0_ST,V2_ST,V1_ST);\n        \}\n      \}\n      if (insideYtop) \{\n        V1_Sample = ppos(pos.x,P1.y);\n        V1_ST = float2(pos.x,P1.y)/UV_Format;        \n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (!_flatshading) \{\n          _tn = normals(pos.x,P1.y);\n          V1_N =float3(_tn.x,_tn.y,_tn.z);\n        \}        \n        if (V1_Sample.w != 0.0f) \{ \n          DrawTriangle(screen_pos,V1_Pos,V2_Pos,_vWorld,V1_wPos,V2_wPos,V0_N,V1_N,V2_N,V0_ST,V1_ST,V2_ST);\n        \}\n      \}\n    \}\n  \}\n\}\n\n\n\n//This function will calculate if pixel C is inside the triangle\nfloat edgeFunction(float3 a, float3 b, float3 c) \n\{ \n    return ((c.x - a.x) * (b.y - a.y) - (c.y - a.y) * (b.x - a.x)); \n\} \n\nfloat3 CalculateSurfaceNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat3 CalculateVertexNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat Distance(float3 _a,float3 _b)\n\{\n          float xd = _a.x - _b.x;\n          float yd = _a.y - _b.y;\n          float zd = _a.z - _b.z;\n          return sqrt(xd*xd + yd*yd + zd*zd);\n\}\n\nvoid DrawTriangle(float3 V0, float3 V1, float3 V2,float3 WP0, float3 WP1, float3 WP2,float3 N0, float3 N1, float3 N2, float2 st0,float2 st1,float2 st2) \{\n\n  // Precompute reciprocal of vertex z-coordinate \n  V0.z = 1.0f / V0.z, V1.z = 1.0f / V1.z, V2.z = 1.0f / V2.z; \n\n  float2 st0n = st0 * V0.z;\n  float2 st1n = st1 * V1.z; \n  float2 st2n = st2 * V2.z; //Normal version of ST\n\n  bool inside; \n  float X0 = Fmin(V0.x,V1.x,V2.x)-1.0f;\n  float X1 = Fmax(V0.x,V1.x,V2.x)+1.0f;\n  float Y0 = Fmin(V0.y,V1.y,V2.y)-1.0f;\n  float Y1 = Fmax(V0.y,V1.y,V2.y)+1.0f;\n  float area = edgeFunction(V2, V1, V0);\n\n\n  float2 sampos = float2(st0.x*float(Vformat.x),st0.y*float(Vformat.y));\n  float4 text0 = src(sampos.x,sampos.y);\n  sampos = float2(st1.x*float(Vformat.x),st1.y*float(Vformat.y));\n  float4 text1 = src(sampos.x,sampos.y);\n  sampos = float2(st2.x*float(Vformat.x),st2.y*float(Vformat.y));  //Why do we have to do this? =(\n  float4 text2 = src(sampos.x,sampos.y);\n  sampos = float2(min(min(st0.x,st1.x),st2.x)*float(Vformat.x),min(min(st0.y,st1.y),st2.y)*float(Vformat.y));\n  float4 text3 = src(sampos.x,sampos.y);\n\n\n  for( int x = X0; x < X1 ; x++) \{\n    for( int y = Y0; y < Y1 ; y++) \{\n      float3 pixelSample(x + _texoffset.x, y + _texoffset.y,0.0f); \n\n      //This is the part where we test if the current pixel is inside the triangle\n      //We check both for front facing and back faing options\n      float w0 = edgeFunction(V1, V0, pixelSample); //Front Facing\n      float w1 = edgeFunction(V2, V1, pixelSample); \n      float w2 = edgeFunction(V0, V2, pixelSample); \n      float w3 = edgeFunction(V0, V1, pixelSample); //Back Facing\n      float w4 = edgeFunction(V1, V2, pixelSample); \n      float w5 = edgeFunction(V2, V0, pixelSample);\n\n      //writepixel(x,y, float4(w1),1,1.0f);\n      if ((w0 >= 0 && w1 >= 0 && w2 >= 0 && _frontfacing) || (w3 >= 0 && w4 >= 0 && w5 >= 0 && _backfacing)) \{ //The curent pixel is inside the triangle\n\n       // calculate vectors from point f to vertices p1, p2 and p3:\n       float3 f1 = V0-pixelSample;\n       float3 f2 = V1-pixelSample;\n       float3 f3 = V2-pixelSample;\n       // calculate the areas and factors (order of parameters doesn't matter):\n       float a = length(cross(V0-V1,V0-V2 )); // main triangle area a\n       area = length(V0-V1)+length(V0-V2)+length(V1-V2);\n\n        w0 /= area; \n        w1 /= area; \n        w2 /= area; \n\n        w3 /= area; \n        w4 /= area; \n        w5 /= area; \n\n       float a1 = length(cross(f2, f3)) / a; // p1's triangle area / a\n       float a2 = length(cross(f3, f1)) / a; // p2's triangle area / a \n       float a3 = length(cross(f1, f2)) / a; // p3's triangle area / a\n       float a_magnitude = a1+a2+a3;\n       a1 = a1/a_magnitude;\n       a2 = a2/a_magnitude;\n       a3 = a3/a_magnitude;\n       float z = 1.0f / (V0.z * a1 + V1.z * a2 + V2.z * a3); \n\n\n        // find the uv corresponding to point f (uv1/uv2/uv3 are associated to p1/p2/p3):\n        float2 uv = st0 * a1 + st1 * a2 + st2 * a3;\n        float2 st = st0 * w0 + st1 * w1 + st2 * w2; \n        st *= z;      \n\n\n        //Calculate normals. Eighter we have flat shading, else we calculate a normal per pixel\n        float3 normalB;\n        if (_flatshading) \{\n          normalB = CalculateSurfaceNormals(WP0,WP1,WP2);\n\n        \}\n        else \{\n          float3 c0 = N2/float3(V0.z); \n          float3 c1 = N0/float3(V1.z); \n          float3 c2 = N1/float3(V2.z);  \n\n          normalB.x = w0 * c0.x + w1 * c1.x + w2 * c2.x; \n          normalB.y = w0 * c0.y + w1 * c1.y + w2 * c2.y; \n          normalB.z = w0 * c0.z + w1 * c1.z + w2 * c2.z; \n\n          normalB.x *= z, normalB.y *= z, normalB.z *= z; \n        \}\n        normalB = normalize(normalB);\n\n        //CALCULATE THE OBJECT TEXTURE COORDINATES\n        float zn = 1.0f / (V0.z * w0 + V1.z * w1 + V2.z * w2); \n        st = st0n * w0 + st1n * w1 + st2n * w2; \n        st *= zn;   \n        //--END \n\n        float3 Wpos = WP0*a1 + WP1*a2 + WP2*a3; //World Position.\n        float3 ViewNormal = normalize(float3(cameraToWorld\[3]\[0],cameraToWorld\[3]\[1],cameraToWorld\[3]\[2])-Wpos);\n\n        float nDotView =  dot(normalB,ViewNormal);\n        nDotView = 1.0f-fabs(nDotView); //make sure that the view normal ramps back around when doing backface\n        float4 tempout;\n\n        //Flatshading or regular?\n        if (!_flatshading) \{\n          tempout = text0 * a1 + text1 * a2 + text2 * a3; \n        \}\n        else\{\n          tempout = text3;\n        \}\n\n        //Additional Render Modes\n        if (_vertexMode == 1)\{\n          tempout = float4(a1,a2,a3,1.0f);\n        \}\n        else if (_vertexMode == 2)\{\n          tempout = float4(normalB.x,normalB.y,normalB.z,1.0f);\n        \}\n        else if (_vertexMode == 3)\{\n          tempout = float4(nDotView,nDotView,nDotView,1.0f);\n        \}\n        else if (_vertexMode == 4)\{\n          tempout = float4(uv.x,uv.y,0.0f,1.0f);\n        \}       \n        else if (_vertexMode == 5)\{\n          tempout = float4(st.x,st.y,0.0f,1.0f);\n        \}               \n        else if (_vertexMode == 6)\{\n          tempout = float4(ViewNormal.x,ViewNormal.y,ViewNormal.z,1.0f);\n        \}             \n        else if (_vertexMode == 7)\{\n          tempout = float4(Wpos.x,Wpos.y,Wpos.z,1.0f);\n        \}   \n\n        if (_depthBuffer)\{\n          writepixel(x,y, float4(tempout.x,tempout.y,tempout.z,z),1,1.0f);  \n        \}\n        else \{\n          if (_dof_enable)\{\n            Bokeh(float3(x,y,z),float4(tempout.x,tempout.y,tempout.z,z));\n          \}\n          else \{\n            bilinear_Plot(float2(x,y),float4(tempout.x,tempout.y,tempout.z,z),1);\n          \}\n        \}\n\n      \}  \n\n    \}\n  \}\n\}\n\n//-------------------------------------\n// Wire_Render\n//-------------------------------------\nvoid wire_render(int2 pos) \{\n  float4 temp = float4(0.0f,0.0f,0.0f,FLT_MAX);\n  float4 wire_ref_sample;\n  int2 tempXY = int2(0,0);\n  float4 plexlist\[11] = \{temp,temp,temp,temp,temp,temp,temp,temp,temp,temp,temp\}; \n  int2 plexlistXY\[11] = \{tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY\};\n  int plex_count = 0; //We use this to figure how many points that should connect.\n  float plex_dist;\n  float3 plex_position,plex_position_b;\n  float4 temp_pos, temp_pos_b; //Temporary Position Containers\n  if (_maxPlexType == -1) \{ //Used for random connection types\n    for( int x = 0; x < max_line_connections ; x++)\{ //THIS 80 NUMBER IS THE LIMIT TO AVOID TOO SLOW PROCESSING!\n      for( int y = 0; y < max_line_connections ; y++)\{\n        wire_ref_sample = ppos(x,y);\n        if (wire_ref_sample.w != 0.0f && pos.x!=x && pos.y != y) \{ \n          plex_position = float3(wire_ref_sample.x,wire_ref_sample.y,wire_ref_sample.z)*(zoom);\n          float xd = plex_position.x - vWorld.x;\n          float yd = plex_position.y - vWorld.y;\n          float zd = plex_position.z - vWorld.z;\n          float plex_dist = sqrt(xd*xd + yd*yd + zd*zd);\n          if (plex_dist<_maxPlexDistance)\{\n            plex_count = min(10,plex_count+1); //Add one to the count\n            for( int h = 0; h < plex_count+1 ; h++) \{ //Loop thought all the points. If the distance is shorter then insert it into the array and push the rest of the array down\n              if (plex_dist < plexlist\[h].w) \{                  \n                for( int i = plex_count+1; i > h ; i--) \{\n                  plexlist\[i] = plexlist\[i-1];\n                  plexlistXY\[i] = plexlistXY\[i-1];\n                \}\n                plexlist\[h] = float4(plex_position.x,plex_position.y,plex_position.z,plex_dist);\n                plexlistXY\[h] = int2(x,y);\n                break;        \n              \}\n            \}\n          \} \n        \}\n      \}\n    \}\n  \}\n  else\{ //Used for standard connection types\n    float4 temp_pos;\n    bool insideX = !(Vformat.x < pos.x+1);\n    bool insideY = !(Vformat.y < pos.y+1);\n\n\n    if (!_plexLinedefAUX)\{\n      temp_pos = normals(pos.x,pos.y);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,vWorld+plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    if ( insideX && !_plexLinedefX) \{\n      temp_pos = ppos(pos.x+1,pos.y );\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && !_plexLinedefX) \{\n      temp_pos = ppos(0,pos.y);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    if ( insideY && !_plexLinedefY) \{\n      temp_pos = ppos(pos.x,pos.y+1);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\}                          \n    \}\n    else if ( _plexConnectY  && !_plexLinedefY) \{\n      temp_pos = ppos(pos.x,0);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    //_plexConnect\n    if ( insideX && insideY && !_plexLinedefXY) \{              \n      temp_pos = ppos(pos.x+1,pos.y+1);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && _plexConnectY && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && insideY && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectY && insideX && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n  \}   \n\n  //now that all the connections have been sorted by distance then we connect the dots.\n  for( int x = 0; x < min(_maxPlexConnections,plex_count) ; x++)\{\n    plex_position = float3(plexlist\[x].x,plexlist\[x].y,plexlist\[x].z);\n    plex_dist = plexlist\[x].w;\n\n\n    float plex_distribution = 1.0f-((plexlist\[x].w-plexlist\[0].w)/((plexlist\[min(_maxPlexConnections,plex_count)].w-plexlist\[0].w)+0.00001f)); //Where does it lie between the best and the worst distance?\n    //plexlistXY\n\n    float4 plex_col = float4(pow(1.0f-(plex_dist/_maxPlexDistance),1.0f/_plex_gamma))*float4(plex_distribution); //This one is quite cool aswell, but does leave the center ones a bit too focused \n    float4 plex_colorA = src(pos.x,pos.y);\n    float4 plex_colorB = src( plexlistXY\[x].x,plexlistXY\[x].y);\n    plex_col *= 0.1f;\n\n    computePixelCoordinates(plex_position, pRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1]);\n    if (dst.bounds.inside(int(vRaster.x),int(vRaster.y)) || dst.bounds.inside(int(pRaster.x),int(pRaster.y)))\{\n        DrawLine(vRaster,pRaster,(plex_colorA*plex_col)*_lineInMultiplier,(plex_colorB*plex_col)*_lineOutMultiplier);\n    \}\n  \}\n\}\n\nvoid wire_connection(float3 p_source,float3 p_target, float4 (&p_plexlist)\[11], int2 (&p_plexlistXY)\[11],int &p_plexcount,int2 position) \{\n  float xd = p_target.x - p_source.x;\n  float yd = p_target.y - p_source.y;\n  float zd = p_target.z - p_source.z;\n  float plex_dist = sqrt(xd*xd + yd*yd + zd*zd);\n  if (plex_dist<_maxPlexDistance)\{\n    p_plexcount = min(11,p_plexcount+1); //Add one to the count\n    for( int h = 0; h < p_plexcount+1 ; h++) \{ //Loop thought all the points. If the distance is shorter then insert it into the array and push the rest of the array down\n      if (plex_dist < p_plexlist\[h].w) \{                  \n        for( int i = p_plexcount+1; i > h ; i--) \{\n          p_plexlist\[i] = p_plexlist\[i-1];\n          p_plexlistXY\[i] = p_plexlistXY\[i-1];\n        \}\n        p_plexlist\[h] = float4(p_target.x,p_target.y,p_target.z,plex_dist);\n        p_plexlistXY\[h] = int2(position.x,position.y);\n        break;        \n      \}\n    \}  \n  \}\n\}\n//-------END OF WIRE RENDER FUNCTIONS---------\n\n\n\n\n//-------------------------------\n//-------BOKEH FUNCTIONS---------\n//thanks to: http://devlog-martinsh.blogspot.dk/2011/11/glsl-depth-of-field-with-bokeh-v21.html\nfloat2 rand(float2 coord) //generating noise/pattern texture for dithering\n\{\n  float noiseX = ((Frac(1.0-coord.x*(WHformat\[0]/2.0))*0.25)+(Frac(coord.y*(WHformat\[1]/2.0))*0.75))*2.0-1.0;\n  float noiseY = ((Frac(1.0-coord.x*(WHformat\[0]/2.0))*0.75)+(Frac(coord.y*(WHformat\[1]/2.0))*0.25))*2.0-1.0;\n  noiseX = clamp(Frac(sin(dot(coord ,float2(12.9898f,78.233f))) * 43758.5453f),0.0f,1.0f)*2.0f-1.0f;\n  noiseY = clamp(Frac(sin(dot(coord ,float2(12.9898f,78.233f)*2.0f)) * 43758.5453f),0.0f,1.0f)*2.0-1.0f;\n  return float2(noiseX,noiseY);\n\}\n//-------------------------------------\n// Bokeh\n//-------------------------------------\nvoid Bokeh(float3 pos,float4 color)\{\n  float blur = 0.0;\n  blur = clamp((fabs(pos.z - focalDepth)/_depthOfField)*100.0f,-_maxDofSize,_maxDofSize);\n  \n  float w = (1.0/WHformat.x)*blur;//+noise.x;\n  float h = (1.0/(WHformat.x*dof_aspect))*blur;//+noise.y;\n  float3 v3_col = float3(color.x,color.y,color.z);\n  int ringsamples;\n  float s = 1.0;  \n\n  for (int i = 1; i <= _dof_rings; i += 1)\n  \{   \n    ringsamples = i * _dof_samples; \n    for (int j = 0 ; j < ringsamples ; j += 1)  \n    \{ \n      s += (1.0f*mix(1.0f,(float(i))/(float(_dof_rings)),dof_bias)*1.0f); //No need to do this in the loop\n    \}\n  \}\n\n  for (int i = 1; i <= _dof_rings; i += 1)\n  \{   \n    ringsamples = i * _dof_samples;\n     \n    for (int j = 0 ; j < ringsamples ; j += 1)   \n    \{\n      float step = PI*2.0 / float(ringsamples);\n      float pw = (cos(float(j)*step)*(float(i)/_dof_rings));\n      float ph = (sin(float(j)*step)*(float(i)/_dof_rings));\n      float p = 1.0;\n\n      float posx = pos.x+((pw*w)*blur);\n      float posy = pos.y+((ph*h)*blur);\n\n\n      float3 lumcoeff = float3(0.299,0.587,0.114);\n      float lum = dot(v3_col, lumcoeff);\n      float thresh = max((lum-dof_threshold)*dof_gain, 0.0f);\n      v3_col+mix(float3(0.0),v3_col,thresh*blur);\n\n      float3 col = (v3_col*mix(1.0,(float(i))/(float(_dof_rings)),dof_bias)*p)/s; \n      bilinear_Plot(float2(posx,posy),float4(col.x,col.y,col.z,color.w/(_dof_rings*_dof_rings)),1);\n    \}\n  \}\n\}\n//-------END OF BOKEH FUNCTIONS---------\n\n\n\n//-------------------------------------\n// Process\n//-------------------------------------\n  void process(int2 pos) \{\n    float4 _sample = ppos(pos.x,pos.y); //Get the XYZ Coordinates\n    float2 posf = float2(pos.x,pos.y);\n\n    if (_sample.w != 0.0f) \{  //No need to process if there is no data.\n\n      //Convert worldspace coordinates to screenspcace coordinates.\n      vWorld = float3(_sample.x,_sample.y,_sample.z)*(zoom);\n      int ret = computePixelCoordinates(vWorld, vRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1]);\n      if (ret) \{ //Only create points that are visible on screen\n        if (_pointRender)\{\n          point_render(pos,vRaster);\n        \}\n      \} //Pointrender over\n\n      if (_wireRender && _maxPlexConnections>=1) \{\n        if (max(pos.x,pos.y)<=max_line_connections || (_maxPlexType==0))\{ // Don't process more wires than allowed in nearest mode.\n          wire_render(pos);\n        \}\n      \} //WireRender over\n\n      if (_facetRender) \{\n        facet_render(pos,float3(_sample.x,_sample.y,_sample.z));\n      \}  //FacetRender over\n      \n    \}\n  \} //----> process\n\};\n"
  useGPUIfAvailable false
  rebuild ""
  PointRender3D_cam_Matrix {
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
    }
  PointRender3D_focallength {{parent.Camera1.focal}}
  PointRender3D_hapeture {{parent.Camera1.haperture}}
  PointRender3D_format {{Settings_Format.width} {Settings_Format.height}}
  PointRender3D_vertexformat {{parent.InputFormat.box.r-1} {parent.InputFormat.box.t-1}}
  PointRender3D__alphaMultiplier {{parent.AlphaMultiplier}}
  PointRender3D__pointRender {{parent.RenderMode==0}}
  PointRender3D__wireRender {{parent.RenderMode==1}}
  PointRender3D__facetRender {{parent.RenderMode==2}}
  PointRender3D__maxLDistance {{parent.wire_maxdistance}}
  PointRender3D__maxLConnections {{parent.wire_connections}}
  PointRender3D__maxPlexType {{-parent.wire_type}}
  PointRender3D__plexLinedefXY {{!parent.connect_xy}}
  PointRender3D__plexLinedefX {{!parent.connect_x}}
  PointRender3D__plexLinedefY {{!parent.connect_y}}
  PointRender3D__plexLinedefAUX {{!connect_aux}}
  PointRender3D__plexConnectX {{parent.CloseX}}
  PointRender3D__plexConnectY {{parent.CloseY}}
  PointRender3D__L_gamma {{parent.wire_Threshold}}
  "PointRender3D_Enable Depth of Field" {{parent.dof_enable}}
  PointRender3D_samples {{3*(parent.Dof_Quality*parent.Dof_Quality+1)}}
  PointRender3D_rings {{3*(parent.Dof_Quality*parent.Dof_Quality+1)}}
  PointRender3D_focalDepth {{parent.dof_focaldepth}}
  PointRender3D__depthOfField {{parent.dof_dof}}
  PointRender3D__depthMult {{parent.DofMultiplier}}
  PointRender3D__maxDofSize {{parent.dof_maxSize*400}}
  PointRender3D_dof_aspect {{parent.dof_Aspect}}
  PointRender3D_dof_bias {{parent.dof_bias}}
  PointRender3D__flatshading {{parent.facet_flatShading}}
  PointRender3D__backfacing {{parent.facet_backface}}
  PointRender3D__frontfacing {{parent.facet_front}}
  PointRender3D__vertexMode {{parent.renderMode}}
  PointRender3D__depthBuffer {{parent.facet_depth}}
  PointRender3D__texoffset {-0.5 0.5}
  PointRender3D__pointSize 0
  PointRender3D__depthOcclusion {{parent.UseOcclusionMap}}
  PointRender3D__maxLineSteps {{parent.maxSamples}}
  PointRender3D__lineOffset {{parent.lineoffset}}
  PointRender3D__lineInMultiplier {{parent.inGain}}
  PointRender3D__lineOutMultiplier {{parent.outGain}}
  format "1280 720 0 0 1280 720 1 HD_720"
  rebuild_finalise ""
  name BlinkScript1
  selected true
  xpos -27
  ypos 159
 }
 Reformat {
  format {{{Settings_Format.format}}}
  resize none
  center false
  name Reformat1
  xpos -27
  ypos 343
 }
 Group {
  name SoftLook
  xpos -27
  ypos 460
  disable {{!parent.HighlightCompression}}
  addUserKnob {20 User}
  addUserKnob {26 ""}
  addUserKnob {7 Add R 0 4}
  Add {{parent.HighlightCeiling}}
  addUserKnob {7 Offset R 0 4}
  Offset {{parent.Compression}}
 }
  Input {
   inputs 0
   name Input1
   xpos -248
   ypos 500
  }
set N68eb0bb0 [stack 0]
  Expression {
   expr0 r/(r+parent.Offset)*parent.Add
   expr1 g/(g+parent.Offset)*parent.Add
   expr2 b/(b+parent.Offset)*parent.Add
   expr3 a/(a+parent.Offset)*parent.Add
   name Expression1
   xpos -339
   ypos 576
  }
push $N68eb0bb0
  ShuffleCopy {
   inputs 2
   red red
   green green
   blue blue
   alpha alpha2
   name ShuffleCopy1
   xpos -248
   ypos 576
  }
  Output {
   name Output1
   xpos -248
   ypos 651
  }
 end_group
 TimeBlur {
  divisions {{parent.Samples}}
  shutter {{parent.Shutter}}
  shutteroffset centred
  shuttercustomoffset 0
  name MotionBlur
  xpos -27
  ypos 581
  disable {{1-parent.mb_enable x89 0}}
 }
 ShuffleCopy {
  inputs 2
  in pos
  red red
  green green
  blue blue
  out pos
  name ShuffleCopy1
  xpos -27
  ypos 673
  disable true
 }
 Output {
  name Output1
  xpos -27
  ypos 710
 }
 Input {
  inputs 0
  name InputCamera
  xpos -1129
  ypos 116
  number 1
 }
 Camera2 {
  focal {{parent.FocalLength}}
  haperture {{parent.horizontalApeture}}
  name Camera1
  xpos -1119
  ypos 223
  addUserKnob {20 Ivy}
  addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.toolbox.v1.nodes.docs', fromlist=\['open_docs_name']).open_docs_name('IvyTab')" +STARTLINE}
  addUserKnob {26 divider4 l "" +STARTLINE}
  addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
  _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
  addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
  addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
  addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
  _expressions {{curve}}
  addUserKnob {26 divider0 l "" +STARTLINE}
  addUserKnob {20 dbinfo l "DB Info" n 1}
  dbinfo 0
  addUserKnob {1 twig_dnuuid l "Twig Id"}
  addUserKnob {1 stalk_dnuuid l "Stalk Id"}
  addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
  addUserKnob {1 leaf_dnuuid l "Leaf Id"}
  addUserKnob {26 divider1 l "" +STARTLINE}
  addUserKnob {1 twigtype l "Twig Type"}
  addUserKnob {1 leaf_label l Leaf}
  addUserKnob {1 ivy_version l Version}
  addUserKnob {43 ivy_notes l Notes}
  addUserKnob {26 divider2 l "" +STARTLINE}
  addUserKnob {1 build_label l "Build Label"}
  addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
 }
 Reformat {
  inputs 0
  format "2156 1806 0 0 2156 1806 2 JOYRIDE Working"
  resize none
  center false
  name Settings_Format
  xpos -1404
  ypos 241
 }
push $N68e76530
 PositionToPoints2 {
  display textured
  render_mode textured
  P_channel pos
  detail 0.25
  pointSize 0.6
  name PreviewNode
  xpos -22
  ypos 8
  disable {{!parent.Enable3DPreview}}
 }
push $N4025cfe0
 Reformat {
  type "to box"
  box_width 100
  box_height 100
  box_fixed true
  scale 0.1
  resize none
  filter impulse
  black_outside true
  name Reformat3
  xpos -633
  ypos -1109
  disable {{!wire_type==1}}
 }
push $N4013d0a0
 Crop {
  box {0 0 {width} {height}}
  reformat true
  crop false
  name InputFormat
  xpos -456
  ypos -402
 }
end_group
TimeOffset {
 time_offset -1182
 time ""
 name TimeOffset1
 selected true
 xpos 8695
 ypos 32626
}
Dot {
 name Dot294
 selected true
 xpos 8729
 ypos 32930
}
FileOut {
 name FileOut25
 tile_color 0xbfbf00ff
 label 2DparticleFX_2
 selected true
 xpos 8695
 ypos 33005
 icon smartgrade.png
 channels rgba
 _destination /jobs
 _stemstatus ""
 file ""
 proxy ""
 fileProxy ""
 views {main}
 first 1001
 last 1400
 pbb true
 smart_grade on
 dw_compression_level 0
 tex_metadata "default metadata and exr/*"
 disable_autolabel_format true
 _defaults "\{'smart_grade': 0, 'compression': 1, 'tile_color': 3216965887, 'pbb': True, 'dw_compression_level': 0, 'label': u'2DparticleFX_2', 'exr_metadata': 2\}"
 _format ""
 _generator "NukeRenderGenerator dnnuke.core.render.v1"
 _ivyVals "\{'variant': None, 'host': None, 'versionNum': '7', 'twigType': 'spider://query@TwigType.one?TwigType.code==2d', 'twigNameTags': \{'subtask': u'precomp', 'task': u'comp', 'label': u'2DparticleFX_2', 'out_dir': u'ELEMENT'\}, 'job': 'STONE', 'stalk': None, 'stalkAttrs': \{'framerange': '1017-1053'\}, 'twig': None, 'stem': 'spider://query@Stem.one?Stem.dnuuid==cfb45239-1375-4623-b0a4-12b2a5fba3d0&Stem.stemname==110_fof_0010&Stem.stemtype==shot'\}"
 _old_filetype exr
 _stalkname E_110_fof_0010_comp_precomp_2DparticleFX_2_v007
 _twigtype 2d
 _wrapper "FileOut dnnuke.nodes.file_out.wrapper"
 beforeRender ""
 beforeFrameRender ""
 afterFrameRender ""
 afterRender ""
 renderProgress ""
 _invert_grade /tools/STONE/ivyasset/110_fof_0010/ivy/grade/GRD_110_fof_0010_neutral_v001/GRD_110_fof_0010_neutral_v001.grade
}
BagAndTagKeep {
 name BagAndTagKeep1
 selected true
 xpos 8695
 ypos 33114
}
Read {
 inputs 0
 file_type exr
 file /jobs/JOYRIDE/hap0850/ELEMENT/E_hap0850_comp_precomp_2DparticleFX_2_v007/2156x1806/E_hap0850_comp_precomp_2DparticleFX_2_v007.####.exr
 localizationPolicy off
 format "2156 1806 0 0 2156 1806 2 JOYRIDE Working"
 proxy_format "640 480 0 0 640 480 1 PC_Video"
 first 1001
 last 1400
 origfirst 1001
 origlast 1400
 origset true
 smartGrade true
 name Read191
 selected true
 xpos 8691
 ypos 33233
 postage_stamp_frame 1200
 addUserKnob {20 Ivy}
 addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.toolbox.v1.nodes.docs', fromlist=\['open_docs_name']).open_docs_name('IvyTab')" +STARTLINE}
 addUserKnob {26 divider4 l "" +STARTLINE}
 addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
 _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
 addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
 addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
 _ivyFile /jobs/JOYRIDE/hap0850/ELEMENT/E_hap0850_comp_precomp_2DparticleFX_2_v007/2156x1806/E_hap0850_comp_precomp_2DparticleFX_2_v007.####.exr
 addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
 _expressions {{curve}}
 addUserKnob {26 divider0 l "" +STARTLINE}
 addUserKnob {20 dbinfo l "DB Info" n 1}
 dbinfo 0
 addUserKnob {1 twig_dnuuid l "Twig Id"}
 twig_dnuuid 776d86dd-5bde-4453-9885-d4e475541d96
 addUserKnob {1 stalk_dnuuid l "Stalk Id"}
 stalk_dnuuid a1971776-3b9e-4e6c-a357-8168962603df
 addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
 twigtype_dnuuid e9f824fa-c932-4c3e-acbd-c612fb5ea846
 addUserKnob {1 leaf_dnuuid l "Leaf Id"}
 leaf_dnuuid b49dc7ed-3066-4993-8567-ab00ce582eb2
 addUserKnob {26 divider1 l "" +STARTLINE}
 addUserKnob {1 twigtype l "Twig Type"}
 twigtype elmr
 addUserKnob {1 leaf_label l Leaf}
 leaf_label main_proxy0
 addUserKnob {1 ivy_version l Version}
 ivy_version 7
 addUserKnob {43 ivy_notes l Notes}
 addUserKnob {26 divider2 l "" +STARTLINE}
 addUserKnob {1 build_label l "Build Label"}
 addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
}
BagAndTagKeep {
 name BagAndTagKeep2
 selected true
 xpos 8691
 ypos 33368
}
push $cut_paste_input
Camera2 {
 translate {5 0.1 0.07756583}
 rotate {0 87.69209641 0}
 name Camera1
 selected true
 xpos 9885
 ypos 32607
 addUserKnob {20 Ivy}
 addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.toolbox.v1.nodes.docs', fromlist=\['open_docs_name']).open_docs_name('IvyTab')" +STARTLINE}
 addUserKnob {26 divider4 l "" +STARTLINE}
 addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
 _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
 addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
 addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
 addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
 _expressions {{curve}}
 addUserKnob {26 divider0 l "" +STARTLINE}
 addUserKnob {20 dbinfo l "DB Info" n 1}
 dbinfo 0
 addUserKnob {1 twig_dnuuid l "Twig Id"}
 addUserKnob {1 stalk_dnuuid l "Stalk Id"}
 addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
 addUserKnob {1 leaf_dnuuid l "Leaf Id"}
 addUserKnob {26 divider1 l "" +STARTLINE}
 addUserKnob {1 twigtype l "Twig Type"}
 addUserKnob {1 leaf_label l Leaf}
 addUserKnob {1 ivy_version l Version}
 addUserKnob {43 ivy_notes l Notes}
 addUserKnob {26 divider2 l "" +STARTLINE}
 addUserKnob {1 build_label l "Build Label"}
 addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
}
Group {
 inputs 0
 name Point_Grid4
 tile_color 0x434343ff
 note_font_color 0x7dadf9ff
 selected true
 xpos 10210
 ypos 32097
 addUserKnob {20 User}
 addUserKnob {26 text l "" +STARTLINE T "Point Grid v1.0\n\nThis node generates a grid.\nAs it is defined in a non-euclidian space, \nmost of the shaders and wire or facet rendering won't work. "}
 addUserKnob {26 ""}
 addUserKnob {41 size_x l "Number of Points" T CONTROLER.size_x}
 addUserKnob {41 size_y l "" -STARTLINE T CONTROLER.size_y}
 addUserKnob {41 size_z l "" -STARTLINE T CONTROLER.size_z}
 addUserKnob {18 Position}
 Position {0 0 0}
 addUserKnob {6 Position_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Position_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Position_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {18 Scale}
 Scale {2 4 2}
 addUserKnob {6 Scale_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Scale_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Scale_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
}
 NoOp {
  inputs 0
  name CONTROLER
  xpos 224
  ypos -62
  addUserKnob {20 User}
  addUserKnob {3 VoxelDensity}
  VoxelDensity {{ceil(pow(size_x*size_y*size_z,1/3))}}
  addUserKnob {3 size_x l "Voxel Grid Size"}
  size_x 140
  addUserKnob {3 size_y l "" -STARTLINE}
  size_y 100
  addUserKnob {3 size_z l "" -STARTLINE}
  size_z 130
 }
 Crop {
  inputs 0
  box {0 0 {ceil(sqrt(pow(parent.CONTROLER.VoxelDensity,3)))} {sqrt(pow(parent.CONTROLER.VoxelDensity,3))}}
  reformat true
  crop false
  name Crop3
  xpos 372
  ypos -108
 }
 BlinkScript {
  recompileCount 9
  ProgramGroup 1
  KernelDescription "2 \"InvertKernel\" iterate pixelWise 21048e0522d3524e03cb582229852f2e33dbe569cd86686b92f460148f8700cf 2 \"src\" Read Point \"dst\" Write Point 1 \"Cube Size\" Int 3 IAAAACAAAAAgAAAAAAAAAA== 1 \"cube_size\" 3 1 0"
  kernelSource "kernel InvertKernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;  \n  Image<eWrite> dst;\n\n  param:\n    int3 cube_size;\n\n  local:\n    \n\n  void define() \{\n    defineParam(cube_size, \"Cube Size\", int3(32,32,32));\n  \}\n\n  void init() \{\n    \n  \}\n\n  void process(int2 pos) \{\n    int t_offset = (pos.x+(pos.y*src.bounds.width()));\n    float4 position;\n    float maxSize = max(max(cube_size.x,cube_size.y),cube_size.z);\n\n    position.x = fmod(t_offset,cube_size.x)/float(cube_size.x-1);\n    position.y = fmod(int(t_offset/cube_size.x),cube_size.y)/float(cube_size.y-1);\n    position.z = fmod(int(t_offset/(cube_size.x*cube_size.y)),cube_size.z)/float(cube_size.z-1);\n    position.w = 1-min(fmod(int(t_offset/(cube_size.x*cube_size.y*cube_size.z)),maxSize),1.0f);\n\n    dst() = float4(position.x*position.w,position.y*position.w,position.z*position.w,position.w);\n   \}\n\};\n\n"
  rebuild ""
  "InvertKernel_Cube Size" {{parent.CONTROLER.size_x} {parent.CONTROLER.size_y} {parent.CONTROLER.size_z}}
  rebuild_finalise ""
  name BlinkScript8
  selected true
  xpos 372
  ypos -79
 }
 Grade {
  add -0.5
  black_clamp false
  name Grade1
  xpos 372
  ypos -47
 }
 Grade {
  white {{parent.Scale.r} {parent.Scale.g} {parent.Scale.b} 0.9}
  add {{parent.Position.r} {parent.Position.g} {parent.Position.b} 0}
  black_clamp false
  name Grade2
  xpos 372
  ypos -26
 }
 Shuffle {
  red white
  green white
  blue white
  black red
  white green
  red2 blue
  green2 alpha
  out2 pos
  name Shuffle1
  xpos 372
  ypos -2
 }
 ModifyMetaData {
  metadata {
   {set pointrender/n_points "\[expr \[value parent.size_x]*\[value parent.size_y] *\[value parent.size_z]]"}
   {set pointrender/gen_type 3}
  }
  name SetMetaData
  xpos 372
  ypos 22
 }
 Grade {
  white {{1/((parent.size_x*parent.size_y*parent.size_z)/200000)}}
  black_clamp false
  name Grade9
  xpos 372
  ypos 46
 }
 Crop {
  box {0 0 {ceil(sqrt(pow(parent.CONTROLER.VoxelDensity,3)))} {sqrt(pow(parent.CONTROLER.VoxelDensity,3))}}
  crop false
  name Crop1
  xpos 372
  ypos 70
 }
 Output {
  name Output1
  xpos 372
  ypos 149
 }
end_group
Group {
 name Fractal9
 tile_color 0x434343ff
 label v003
 note_font_color 0x7dadf9ff
 selected true
 xpos 10210
 ypos 32168
 addUserKnob {20 User t test}
 addUserKnob {26 _1 l "" +STARTLINE T "Point Fractal 1.0\n"}
 addUserKnob {26 devider_noise l "<b><font color=#7DADF9>Noise Settings</font><b>"}
 addUserKnob {6 Noise_Absolute l Absolute t "Negative values in the noise offset is made positive." +STARTLINE}
 addUserKnob {3 Noise_Octaves l Octaves}
 Noise_Octaves 8
 addUserKnob {7 Noise_Gain l Gain}
 Noise_Gain 0.3
 addUserKnob {7 Noise_Lacunarity l Lacunarity R 0 4}
 Noise_Lacunarity 1.18
 addUserKnob {18 Amplitude}
 Amplitude 0.49
 addUserKnob {6 Amplitude_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Amplitude_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Amplitude_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Amplitude_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {3 Itterations}
 Itterations 5
 addUserKnob {26 invis_devider_noise l "" +STARTLINE T " "}
 addUserKnob {26 Devider_Frequency l "<b><font color=#7DADF9>Freq Control</font><b>"}
 addUserKnob {19 Freq_Offset l "General Offset" t "This is like a 3D translation, letting you move the current noise pattern in the X, Y, Z and W (4th dimention)" R 0 10}
 Freq_Offset {0 0 0 0}
 addUserKnob {6 Freq_Offset_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_Offset_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_Offset_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_Offset_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_Offset_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 Freq_GeneralScale l "Genral Scale" t "This lets you control the scale of each individual noise axis."}
 Freq_GeneralScale {1 1 1 1}
 addUserKnob {6 Freq_GeneralScale_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_GeneralScale_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_GeneralScale_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_GeneralScale_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_GeneralScale_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {26 invis_devider_freq l "" +STARTLINE T " "}
 addUserKnob {19 Freq_EvolveLow l "Evolve Low" t "This lets you evolve (auto animate) the noise in a particular direction. The \"Low\" part means that this only affects the low frequencies.\n\nTo avoid a \"scrolling\" effect you can use the 4th dimention to break up the spatial cohearence." R 0 10}
 Freq_EvolveLow {3 0 0 0.5}
 addUserKnob {6 Freq_EvolveLow_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveLow_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveLow_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveLow_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveLow_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleLow_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 Freq_EvolveHigh l "Evolve High" t "This lets you evolve (auto animate) the noise in a particular direction. The \"High\" part means that this only affects the high frequencies.\n\nTo avoid a \"scrolling\" effect you can use the 4th dimention to break up the spatial cohearence."}
 Freq_EvolveHigh {0.9 0 -0.5 1}
 addUserKnob {6 Freq_EvolveHigh_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveHigh_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveHigh_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveHigh_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveHigh_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {26 invis_devider_freq2 l "" +STARTLINE T " "}
 addUserKnob {19 Freq_ScaleLow l "Scale Low" t "This lets you scale the noise in a particular axis. The \"Low\" part means that this only affects the low frequencies."}
 Freq_ScaleLow {3 0.3 2 2}
 addUserKnob {6 Freq_ScaleLow_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleLow_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleLow_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleLow_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleLow_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 Freq_ScaleHigh l "Scale High" t "This lets you scale the noise in a particular axis. The \"High\" part means that this only affects the high frequencies."}
 Freq_ScaleHigh {2 2 2 2}
 addUserKnob {6 Freq_ScaleHigh_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleHigh_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleHigh_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleHigh_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleHigh_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {26 invis_devider_freq3 l "" +STARTLINE T " "}
 addUserKnob {26 Curve l "<b><font color=#7DADF9>Curve Noise</font><b>"}
 addUserKnob {6 CurveNoise_Enable l Enable t "Adds a gamma curve to the noise intensity making noise near the \"Offset\" value more flat. This is a experimental feature." +STARTLINE}
 addUserKnob {6 CurveNoise_Invert l Invert t "Inverts the effect of the curved noise." -STARTLINE}
 addUserKnob {7 CurveGain l "Curve Gain" R -10 10}
 CurveGain 3
 addUserKnob {7 CurveOffset R -2 2}
 addUserKnob {26 gabgen l "" +STARTLINE T "\n"}
 addUserKnob {26 info_mask l "<b><font color=#7DADF9>Mask</font><b>"}
 addUserKnob {41 maskChannelMask l "" t "If a node is connected to the mask input, this will let you mask off the effect of the noise.\nIts recommended that you use the Point_Texture node to ensure a correct aspect and size." -STARTLINE T Merge1.maskChannelMask}
 addUserKnob {41 inject -STARTLINE T Merge1.inject}
 addUserKnob {41 invert_mask l invert -STARTLINE T Merge1.invert_mask}
 addUserKnob {41 fringe -STARTLINE T Merge1.fringe}
 addUserKnob {41 mix T Merge1.mix}
}
 Input {
  inputs 0
  name InputMask
  xpos -714
  ypos 207
  number 1
 }
 Reformat {
  type "to box"
  box_width {{parent.InputFormat.box.r}}
  box_height {{parent.InputFormat.box.t}}
  box_fixed true
  resize distort
  name Reformat2
  xpos -714
  ypos 306
 }
 Shuffle {
  name Shuffle3
  xpos -714
  ypos 330
 }
 Input {
  inputs 0
  name InputData
  xpos -582
  ypos 73
 }
 Dot {
  name Dot1
  xpos -548
  ypos 114
 }
set N55429640 [stack 0]
 Shuffle {
  in pos
  name Shuffle1
  xpos -470
  ypos 110
 }
 BlinkScript {
  kernelSourceFile /Users/madshagbarth/Github/Nuke-Private/Blink/PointRender/Modify/Fractal_v06.cpp
  recompileCount 60
  ProgramGroup 1
  KernelDescription "2 \"Noise4D\" iterate pixelWise d54284af3e5573ad197bef9032773e8653de2cad590694fcc9fd5af993e97da3 2 \"src\" Read Point \"dst\" Write Point 17 \"absNoise\" Bool 1 AA== \"curveNoise\" Bool 1 AA== \"curveInvert\" Bool 1 AA== \"curveGain\" Float 1 AACAPw== \"curveOffset\" Float 1 AACAPw== \"Octaves\" Int 1 CgAAAA== \"Gain\" Float 1 AAAAPw== \"Lacunarity\" Float 1 AAAAQA== \"Gamma\" Float 1 AAAAPw== \"amplitude\" Float 3 AAAAPwAAAD8AAAA/AAAAAA== \"itterations\" Int 1 AQAAAA== \"Offset\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"Scale\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"suboffset\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"topoffset\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"subscale\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"topscale\" Float 4 AACAPwAAgD8AAIA/AACAPw== 17 \"absNoise\" 1 1 \"curveNoise\" 1 1 \"curveInvert\" 1 1 \"curveGain\" 1 1 \"curveOffset\" 1 1 \"octaves\" 1 1 \"gain\" 1 1 \"lacunarity\" 1 1 \"gamma\" 1 1 \"amplitude\" 3 1 \"itterations\" 1 1 \"offset\" 4 1 \"scale\" 4 1 \"suboffset\" 4 1 \"topoffset\" 4 1 \"subscale\" 4 1 \"topscale\" 4 1 0"
  kernelSource "//Based on https://github.com/Draradech/csworldgen/blob/master/simplexnoise.cpp\n//Ported by Mads Hagbarth Lund 2014\n\n/* Copyright (c) 2007-2012 Eliot Eshelman\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n\nint fastfloor( const float x ) \{ return x > 0 ? (int) x : (int) x - 1; \}\ninline float raw_noise_4d( const float x, const float y, const float z, const float w ) \n\{\nint simplex\[64]\[4] = \{\n    \{0,1,2,3\},\{0,1,3,2\},\{0,0,0,0\},\{0,2,3,1\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{1,2,3,0\},\n    \{0,2,1,3\},\{0,0,0,0\},\{0,3,1,2\},\{0,3,2,1\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{1,3,2,0\},\n    \{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\n    \{1,2,0,3\},\{0,0,0,0\},\{1,3,0,2\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{2,3,0,1\},\{2,3,1,0\},\n    \{1,0,2,3\},\{1,0,3,2\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{2,0,3,1\},\{0,0,0,0\},\{2,1,3,0\},\n    \{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\n    \{2,0,1,3\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{3,0,1,2\},\{3,0,2,1\},\{0,0,0,0\},\{3,1,2,0\},\n    \{2,1,0,3\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{3,1,0,2\},\{0,0,0,0\},\{3,2,0,1\},\{3,2,1,0\}\n\};\n    int perm\[512] = \{\n        151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,\n        8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,\n        35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,\n        134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,\n        55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208, 89,\n        18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,\n        250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,\n        189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,\n        172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,\n        228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,\n        107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,\n        138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180,\n\n        151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,\n        8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,\n        35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,\n        134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,\n        55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208, 89,\n        18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,\n        250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,\n        189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,\n        172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,\n        228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,\n        107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,\n        138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180\n    \};\n   int grad4\[32]\[4]= \{\n    \{0,1,1,1\},  \{0,1,1,-1\},  \{0,1,-1,1\},  \{0,1,-1,-1\},\n    \{0,-1,1,1\}, \{0,-1,1,-1\}, \{0,-1,-1,1\}, \{0,-1,-1,-1\},\n    \{1,0,1,1\},  \{1,0,1,-1\},  \{1,0,-1,1\},  \{1,0,-1,-1\},\n    \{-1,0,1,1\}, \{-1,0,1,-1\}, \{-1,0,-1,1\}, \{-1,0,-1,-1\},\n    \{1,1,0,1\},  \{1,1,0,-1\},  \{1,-1,0,1\},  \{1,-1,0,-1\},\n    \{-1,1,0,1\}, \{-1,1,0,-1\}, \{-1,-1,0,1\}, \{-1,-1,0,-1\},\n    \{1,1,1,0\},  \{1,1,-1,0\},  \{1,-1,1,0\},  \{1,-1,-1,0\},\n    \{-1,1,1,0\}, \{-1,1,-1,0\}, \{-1,-1,1,0\}, \{-1,-1,-1,0\}\n   \};\n    float F4 = (sqrt(5.0f)-1.0f)/4.0f;\n    float G4 = (5.0f-sqrt(5.0f))/20.0f;\n    float n0, n1, n2, n3, n4;\n    float s = (x + y + z + w) * F4;\n    int i = fastfloor(x + s);\n    int j = fastfloor(y + s);\n    int k = fastfloor(z + s);\n    int l = fastfloor(w + s);\n    float t = (i + j + k + l) * G4;\n    float X0 = i - t;\n    float Y0 = j - t;\n    float Z0 = k - t;\n    float W0 = l - t;\n\n    float x0 = x - X0;\n    float y0 = y - Y0;\n    float z0 = z - Z0;\n    float w0 = w - W0;\n    int c1 = (x0 > y0) ? 32 : 0;\n    int c2 = (x0 > z0) ? 16 : 0;\n    int c3 = (y0 > z0) ? 8 : 0;\n    int c4 = (x0 > w0) ? 4 : 0;\n    int c5 = (y0 > w0) ? 2 : 0;\n    int c6 = (z0 > w0) ? 1 : 0;\n    int c = c1 + c2 + c3 + c4 + c5 + c6;\n\n    int i1, j1, k1, l1;\n    int i2, j2, k2, l2;\n    int i3, j3, k3, l3;\n    i1 = simplex\[c]\[0]>=3 ? 1 : 0;\n    j1 = simplex\[c]\[1]>=3 ? 1 : 0;\n    k1 = simplex\[c]\[2]>=3 ? 1 : 0;\n    l1 = simplex\[c]\[3]>=3 ? 1 : 0;\n    i2 = simplex\[c]\[0]>=2 ? 1 : 0;\n    j2 = simplex\[c]\[1]>=2 ? 1 : 0;\n    k2 = simplex\[c]\[2]>=2 ? 1 : 0;\n    l2 = simplex\[c]\[3]>=2 ? 1 : 0;\n    i3 = simplex\[c]\[0]>=1 ? 1 : 0;\n    j3 = simplex\[c]\[1]>=1 ? 1 : 0;\n    k3 = simplex\[c]\[2]>=1 ? 1 : 0;\n    l3 = simplex\[c]\[3]>=1 ? 1 : 0;\n    float x1 = x0 - i1 + G4;\n    float y1 = y0 - j1 + G4;\n    float z1 = z0 - k1 + G4;\n    float w1 = w0 - l1 + G4;\n    float x2 = x0 - i2 + 2.0*G4;\n    float y2 = y0 - j2 + 2.0*G4;\n    float z2 = z0 - k2 + 2.0*G4;\n    float w2 = w0 - l2 + 2.0*G4;\n    float x3 = x0 - i3 + 3.0*G4;\n    float y3 = y0 - j3 + 3.0*G4;\n    float z3 = z0 - k3 + 3.0*G4;\n    float w3 = w0 - l3 + 3.0*G4;\n    float x4 = x0 - 1.0 + 4.0*G4;\n    float y4 = y0 - 1.0 + 4.0*G4;\n    float z4 = z0 - 1.0 + 4.0*G4;\n    float w4 = w0 - 1.0 + 4.0*G4;\n    int ii = i & 255;\n    int jj = j & 255;\n    int kk = k & 255;\n    int ll = l & 255;\n    int gi0 = perm\[ii+perm\[jj+perm\[kk+perm\[ll]]]] % 32;\n    int gi1 = perm\[ii+i1+perm\[jj+j1+perm\[kk+k1+perm\[ll+l1]]]] % 32;\n    int gi2 = perm\[ii+i2+perm\[jj+j2+perm\[kk+k2+perm\[ll+l2]]]] % 32;\n    int gi3 = perm\[ii+i3+perm\[jj+j3+perm\[kk+k3+perm\[ll+l3]]]] % 32;\n    int gi4 = perm\[ii+1+perm\[jj+1+perm\[kk+1+perm\[ll+1]]]] % 32;\n    float t0 = 0.6 - x0*x0 - y0*y0 - z0*z0 - w0*w0;\n    if(t0<0) n0 = 0.0;\n    else \{\n        t0 *= t0;\n        n0 = t0 * t0 * dot(float4(grad4\[gi0]\[0],grad4\[gi0]\[2],grad4\[gi0]\[3],grad4\[gi0]\[3]), float4(x0, y0, z0, w0));\n    \}\n    float t1 = 0.6 - x1*x1 - y1*y1 - z1*z1 - w1*w1;\n    if(t1<0) n1 = 0.0;\n    else \{\n        t1 *= t1;\n        n1 = t1 * t1 * dot(float4(grad4\[gi1]\[0],grad4\[gi1]\[2],grad4\[gi1]\[3],grad4\[gi1]\[3]), float4(x1, y1, z1, w1));\n    \}\n    float t2 = 0.6 - x2*x2 - y2*y2 - z2*z2 - w2*w2;\n    if(t2<0) n2 = 0.0;\n    else \{\n        t2 *= t2;\n        n2 = t2 * t2 * dot(float4(grad4\[gi2]\[0],grad4\[gi2]\[2],grad4\[gi2]\[3],grad4\[gi2]\[3]), float4(x2, y2, z2, w2));\n    \}\n    float t3 = 0.6 - x3*x3 - y3*y3 - z3*z3 - w3*w3;\n    if(t3<0) n3 = 0.0;\n    else \{\n        t3 *= t3;\n        n3 = t3 * t3 * dot(float4(grad4\[gi3]\[0],grad4\[gi3]\[2],grad4\[gi3]\[3],grad4\[gi3]\[3]), float4(x3, y3, z3, w3));\n    \}\n    float t4 = 0.6 - x4*x4 - y4*y4 - z4*z4 - w4*w4;\n    if(t4<0) n4 = 0.0;\n    else \{\n        t4 *= t4;\n        n4 = t4 * t4 * dot(float4(grad4\[gi4]\[0],grad4\[gi4]\[2],grad4\[gi4]\[3],grad4\[gi4]\[3]), float4(x4, y4, z4, w4));\n    \}\n    return 27.0 * (n0 + n1 + n2 + n3 + n4);\n\}\n\n\n\n\nkernel Noise4D : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n  Image<eWrite, eAccessPoint> dst;\nparam:\n    bool absNoise;\n    bool curveNoise;\n    bool curveInvert;\n    float curveGain;\n    float curveOffset;\n    int octaves;\n    float gain;\n    float lacunarity;\n    float gamma;\n    float3 amplitude;\n    int itterations;\n    float4 offset;\n    float4 scale;\n    float4 suboffset;\n    float4 topoffset;\n    float4 subscale;\n    float4 topscale;\n\n\n  void define() \{\n        defineParam (absNoise, \"absNoise\", false);    \n        defineParam (curveNoise, \"curveNoise\", false);    \n        defineParam (curveInvert, \"curveInvert\", false);   \n        defineParam (curveGain, \"curveGain\", 1.0f);\n        defineParam (curveOffset, \"curveOffset\", 1.0f);\n        defineParam (octaves, \"Octaves\", 10);\n        defineParam (gain, \"Gain\", 0.5f);\n        defineParam (lacunarity, \"Lacunarity\", 2.0f);\n        defineParam (gamma, \"Gamma\", 0.5f);\n        defineParam (amplitude, \"amplitude\", float3(0.5f));\n        defineParam (itterations, \"itterations\", 1);\n        defineParam(offset, \"Offset\", float4(0.0f, 0.0f, 0.0f,0.0f));\n        defineParam(scale, \"Scale\", float4(1.0f, 1.0f, 1.0f,1.0f));\n        defineParam(suboffset, \"suboffset\", float4(1.0f, 1.0f, 1.0f,1.0f));\n        defineParam(topoffset, \"topoffset\", float4(1.0f, 1.0f, 1.0f,1.0f));\n        defineParam(subscale, \"subscale\", float4(1.0f, 1.0f, 1.0f,1.0f));\n        defineParam(topscale, \"topscale\", float4(1.0f, 1.0f, 1.0f,1.0f));        \n  \}\n\nfloat octave_noise_4d( const float octaves, const float persistence, const float scale, const float x, const float y, const float z, const float w ) \n\{\n    float total = 0.0f;\n    float current;\n    float last = 1.0f;\n    float frequency = scale;\n    float amplitude = 1.0f;\n    float maxAmplitude = 0.0f;\n    float4 Tempoffset;\n    float4 Tempscale;\n\n\n    for( int i=0; i < octaves; i++ ) \{\n\n        /*\n        if (i == 0) \{\n            total += (float)raw_noise_4d( (x+suboffset.x) * frequency, (y+suboffset.y) * frequency, (z+suboffset.z) * frequency, (w+suboffset.w) * frequency ) * amplitude;\n        \}\n        else if (i == octaves-1) \{\n            total += (float)raw_noise_4d( (x+topoffset.x) * frequency, (y+topoffset.y) * frequency, (z+topoffset.z) * frequency, (w+topoffset.w) * frequency ) * amplitude;\n        \}\n        else \{\n            total += (float)raw_noise_4d( x * frequency, y * frequency, z * frequency, w * frequency ) * amplitude;\n        \}\n        */\n\n\n        Tempscale = (topscale * (i/(octaves-1.0f)))+(subscale * (1-(i/(octaves-1.0f))));       \n        Tempoffset = (topoffset * (i/(octaves-1.0f)))+(suboffset * (1-(i/(octaves-1.0f))));\n        current = (float)raw_noise_4d(   ((x*Tempscale.x)+Tempoffset.x) * frequency, \n                                        ((y*Tempscale.y)+Tempoffset.y) * frequency, \n                                        ((z*Tempscale.z)+Tempoffset.z) * frequency, \n                                        ((w*Tempscale.w)+Tempoffset.w) * frequency \n                                        ) * amplitude;\n        if (i == 0 && curveNoise)\{\n            if (curveInvert)\{\n                last = 0.5f-current;  \n            \}\n            else\{\n                last = current;  \n            \}\n               \n        \}\n        current = curveNoise?current*((last+curveOffset)*curveGain):current;\n        total += absNoise?fabs(current):current;\n        frequency *= 2.0f;\n        maxAmplitude += amplitude;\n        amplitude *= persistence;\n\n    \}\n    return float(total / maxAmplitude);\n\}\n\n\n\n\n  void process() \{\n    float4 srcSample = float4(src(0),src(1),src(2),src(3));\n    float sampleR,sampleG,sampleB;\n    for( int i=0; i < itterations; i++ ) \{\n        sampleR = (float)octave_noise_4d(float(octaves), gain, lacunarity, ( srcSample.x * scale.x ) + offset.x, ( srcSample.y * scale.y ) + offset.y,  ( srcSample.z * scale.z ) + offset.z, ( srcSample.w * scale.w ) + offset.w) * amplitude.x;\n        sampleG = (float)octave_noise_4d(float(octaves), gain, lacunarity, ( srcSample.x * scale.x ) + offset.x, ( srcSample.y * scale.y ) + offset.y,  ( srcSample.z * scale.z ) + offset.z, ( srcSample.w * scale.w ) + offset.w - 100.0f) * amplitude.y;\n        sampleB = (float)octave_noise_4d(float(octaves), gain, lacunarity, ( srcSample.x * scale.x ) + offset.x, ( srcSample.y * scale.y ) + offset.y,  ( srcSample.z * scale.z ) + offset.z, ( srcSample.w * scale.w ) + offset.w + 200.0f) * amplitude.z;\n        srcSample = float4(srcSample.x+sampleR,srcSample.y+sampleG,srcSample.z+sampleB,srcSample.w);\n    \}\n    dst() = float4(srcSample.x,srcSample.y,srcSample.z,1.0f);\n\}\n\};"
  rebuild ""
  Noise4D_curveNoise {{parent.CurveNoise_Enable}}
  Noise4D_curveInvert {{parent.CurveNoise_Invert}}
  Noise4D_curveGain {{parent.CurveGain}}
  Noise4D_curveOffset {{parent.CurveOffset}}
  Noise4D_Octaves {{parent.Noise_Octaves}}
  Noise4D_Gain {{parent.Noise_Gain}}
  Noise4D_Lacunarity {{parent.Noise_Lacunarity}}
  Noise4D_Gamma 0.79
  Noise4D_amplitude {{parent.Amplitude.r} {parent.Amplitude.g} {parent.Amplitude.b}}
  Noise4D_itterations {{parent.Itterations}}
  Noise4D_Offset {{parent.Freq_Offset} {parent.Freq_Offset} {parent.Freq_Offset} {parent.Freq_Offset}}
  Noise4D_Scale {{parent.Freq_GeneralScale} {parent.Freq_GeneralScale} {parent.Freq_GeneralScale} {parent.Freq_GeneralScale}}
  Noise4D_suboffset {{(frame*parent.Freq_EvolveLow.r)/50} {(frame*parent.Freq_EvolveLow.g)/50} {(frame*parent.Freq_EvolveLow.b)/50} {(frame*parent.Freq_EvolveLow.a)/50}}
  Noise4D_topoffset {{(frame*parent.Freq_EvolveHigh.r)/10} {(frame*parent.Freq_EvolveHigh.g)/10} {(frame*parent.Freq_EvolveHigh.b)/10} {(frame*parent.Freq_EvolveHigh.a)/10}}
  Noise4D_subscale {{parent.Freq_ScaleLow} {parent.Freq_ScaleLow} {parent.Freq_ScaleLow} {parent.Freq_ScaleLow}}
  Noise4D_topscale {{parent.Freq_ScaleHigh} {parent.Freq_ScaleHigh} {parent.Freq_ScaleHigh} {parent.Freq_ScaleHigh}}
  rebuild_finalise ""
  name Noise4D1
  selected true
  xpos -470
  ypos 177
 }
 Expression {
  expr0 abs(r)
  expr1 abs(g)
  expr2 abs(b)
  name Expression2
  xpos -470
  ypos 259
  disable {{!parent.Noise_Absolute}}
 }
 Shuffle {
  out pos
  name Shuffle2
  xpos -470
  ypos 330
 }
push $N55429640
 Merge2 {
  inputs 2+1
  operation copy
  bbox B
  Achannels {pos.red pos.green pos.blue -pos.alpha}
  Bchannels {pos.red pos.green pos.blue -pos.alpha}
  output {pos.red pos.green pos.blue -pos.alpha}
  maskChannelMask -rgba.alpha
  name Merge1
  xpos -582
  ypos 326
 }
 Output {
  name Output1
  xpos -582
  ypos 497
 }
push $N55429640
 Crop {
  box {0 0 {width} {height}}
  reformat true
  crop false
  name InputFormat
  xpos -713
  ypos 111
 }
end_group
set N553e7270 [stack 0]
Dot {
 name Dot295
 selected true
 xpos 10117
 ypos 32178
}
push $N553e7270
Dot {
 name Dot296
 selected true
 xpos 10244
 ypos 32316
}
Group {
 inputs 2
 name Point_OffsetShader5
 tile_color 0x434343ff
 note_font_color 0x55ffffff
 selected true
 xpos 10083
 ypos 32312
 addUserKnob {20 User}
 addUserKnob {26 info l "" +STARTLINE T "Point Offset Shader v1.0\n\nCalcualtes the distance between 2 point sets.\nThis can for example be used to see the difference between the original generator\nand the modified one."}
 addUserKnob {26 devider_general l "<b><font color=#70EE70>General</font><b>"}
 addUserKnob {7 Gain}
 Gain 3
 addUserKnob {7 Offset R -0.5 0.5}
 Offset -0.1
 addUserKnob {6 Absolute +STARTLINE}
 Absolute true
 addUserKnob {6 Reverse +STARTLINE}
}
 BackdropNode {
  inputs 0
  name BackdropNode1
  tile_color 0x388e8e00
  label Offset
  note_font_size 42
  xpos -591
  ypos 304
  bdwidth 224
  bdheight 161
 }
 Input {
  inputs 0
  name Input2
  xpos -438
  ypos 40
  number 1
 }
 Shuffle {
  in pos
  name Shuffle1
  xpos -438
  ypos 120
 }
 Dot {
  name Dot4
  xpos -404
  ypos 285
 }
 Dot {
  name Dot1
  xpos -404
  ypos 392
 }
 Input {
  inputs 0
  name Input1
  xpos -580
  ypos 50
 }
 Shuffle {
  in pos
  name Shuffle5
  xpos -580
  ypos 120
 }
 Dot {
  name Dot3
  xpos -546
  ypos 256
 }
 MergeExpression {
  inputs 2
  temp_name0 xd
  temp_expr0 A.red-B.red
  temp_name1 yd
  temp_expr1 A.green-B.green
  temp_name2 zd
  temp_expr2 A.blue-B.blue
  temp_name3 Distance
  temp_expr3 "sqrt(xd*xd + yd*yd + zd*zd)"
  expr0 Distance
  expr1 Distance
  expr2 Distance
  name Distance
  xpos -584
  ypos 388
 }
 Grade {
  add {{parent.Offset}}
  black_clamp false
  name Grade3
  xpos -584
  ypos 412
 }
 Grade {
  white {{parent.Gain}}
  black_clamp {{!parent.Absolute}}
  name Grade1
  xpos -584
  ypos 436
 }
 Expression {
  expr0 abs(r)
  expr1 abs(g)
  expr2 abs(b)
  name Expression1
  xpos -584
  ypos 459
  disable {{!parent.Absolute}}
 }
 Expression {
  expr0 max(0,1-r)
  expr1 max(0,1-r)
  expr2 max(0,1-r)
  name Expression2
  selected true
  xpos -584
  ypos 483
  disable {{!parent.Reverse}}
 }
 Group {
  name SoftLook_NF1
  xpos -584
  ypos 650
  disable true
  addUserKnob {20 User}
  addUserKnob {26 Info l "" +STARTLINE T "SoftLook\nby Mads Hagbarth Lund - 2016"}
  addUserKnob {26 ""}
  addUserKnob {7 Add R 0 4}
  Add 1.14
  addUserKnob {7 Offset R 0 4}
  Offset 0.86
 }
  Input {
   inputs 0
   name Input1
   xpos -248
   ypos 500
  }
set N55119d30 [stack 0]
  Expression {
   expr0 r/(r+parent.Offset)*parent.Add
   expr1 g/(g+parent.Offset)*parent.Add
   expr2 b/(b+parent.Offset)*parent.Add
   expr3 a/(a+parent.Offset)*parent.Add
   name Expression1
   selected true
   xpos -339
   ypos 576
  }
push $N55119d30
  ShuffleCopy {
   inputs 2
   red red
   green green
   blue blue
   alpha alpha2
   name ShuffleCopy1
   xpos -248
   ypos 576
  }
  Output {
   name Output1
   xpos -248
   ypos 651
  }
 end_group
 Output {
  name Output1
  xpos -584
  ypos 686
 }
end_group
Grade {
 white 1.3
 multiply {0.6887242198 0.9288096428 1 1}
 gamma {0.2101119161 0.3576882482 1 1}
 name Grade25
 selected true
 xpos 10083
 ypos 32488
}
Group {
 inputs 2
 name Point_Render4
 tile_color 0x434343ff
 note_font_color 0x7dadf9ff
 selected true
 xpos 10083
 ypos 32627
 addUserKnob {20 User l "Point Render" t dd}
 addUserKnob {26 info_header l "" +STARTLINE T "Point Render v1.0"}
 addUserKnob {26 devider_general l "<b><font color=#7DADF9>General</font><b>"}
 addUserKnob {4 RenderMode l "Render Mode" t "Some generators support multiple render modes other than just point rendering. This should be considered a experimental feature, but can be used to great effect.\n\nIn the Render Settings tab you can find more controls relating to Wire and Facet rendering modes.\n\nNote that Facet Render can be slow when really close to a object. " M {"Point Render" "Wire Render" "Facet Render (experimental)" "" "" ""}}
 addUserKnob {7 FocalLength l "Focal Length" t "The point render does not take the focal length from the input camera, so if you want to match it to a camera you should link the focal length from the camera to this." R 0 200}
 FocalLength 20
 addUserKnob {7 horizontalApeture l "Horiz Apeture" R 0 100}
 horizontalApeture 24.576
 addUserKnob {7 AlphaMultiplier l Exposure t "This is a general exposure modifier that lets you adjust the overall brightness of the render." R 0 2}
 AlphaMultiplier 0.15
 addUserKnob {6 UseOcclusionMap l "Use Occlusion Map" t "Enable the Occlusion map input. This lets you use a depth map as a holdout.\n\nNote:\nThe Red channal should contain the depth (absolute distance, not 1/depth)\nThe Alpha channal must be 1 for the areas that you want to holdout." +STARTLINE}
 addUserKnob {26 devider_cc l "<b><font color=#7DADF9>Preview</font><b>"}
 addUserKnob {6 FastPreview l "Fast Preview" t "Reduce the number of points for a quick preview of the final render." +STARTLINE}
 addUserKnob {6 HighlightCompression l "Hilight Compression" t "Compresses the highlights to make it easier to see bright details." +STARTLINE}
 addUserKnob {7 HighlightCeiling l "Highlight Ceiling" t "Adjust the cealing for the highlight compression." R 1 10}
 HighlightCeiling 1.15
 addUserKnob {7 Compression t "The compression amount." -STARTLINE R 0 5}
 Compression 1
 addUserKnob {26 devider_format l "<b><font color=#7DADF9>Format</font><b>"}
 addUserKnob {41 format l "output format" T Settings_Format.format}
 addUserKnob {20 WireRender l "Render Settings"}
 addUserKnob {26 devider_wirerender l "<b><font color=#7DADF9>Wire Rendering</font><b>"}
 addUserKnob {4 wire_type l "Connection Mode" t "*Normal\nConnect lines between the local neigbours of the 2d position map\n\n*Nearest\nConnect lines to the nearest points (in 3D space). This mode is limited to 100x100 points for performence reasons!" M {Normal Nearest "" "" "" "" "" "" "" ""}}
 addUserKnob {26 text l "Normal Mode Wires" T " "}
 addUserKnob {6 connect_x l x t "Connect wires in the (uv) X axis." -STARTLINE}
 connect_x true
 addUserKnob {6 connect_xy l xy t "Connect wires in the (uv) XY axis." -STARTLINE}
 connect_xy true
 addUserKnob {6 connect_y l y t "Connect wires in the (uv) Y axis." -STARTLINE}
 connect_y true
 addUserKnob {6 connect_aux l aux t "If you input a vector map into the Aux input for this node, and enable this option, you will get a wire from each point along that vector." -STARTLINE}
 addUserKnob {7 wire_maxdistance l "Max Distance" t "The maximum distance that the wires connect." R 0 10}
 wire_maxdistance 6
 addUserKnob {7 wire_Threshold l "Distance Threshold" t "Control the max distance threshold" R 0 2}
 wire_Threshold 0.5
 addUserKnob {3 wire_connections l "Max Connections" t "The maximum number of connections (Not Yet Implemented)"}
 wire_connections 4
 addUserKnob {7 maxSamples l "Max Line Samples" t "The maximum length of a line. Once a line is longer than this, it will start break up. \nThis can also be used as a creative effect if you set it low, try setting it to 10 in wire mode to get dotted lines" R 0 10000}
 maxSamples 10000
 addUserKnob {7 lineoffset l "Line Offset" t "Expand or contract the lines."}
 lineoffset 1
 addUserKnob {7 inGain l "In Gain" t "Gain the brightness of the in-point of the lines"}
 inGain 1
 addUserKnob {7 outGain l "Out Gain" t "Gain the brightness of the out-point of the lines" -STARTLINE}
 outGain 1
 addUserKnob {26 devider_facet l "<b><font color=#7DADF9>Facet Rendering</font><b>"}
 addUserKnob {4 renderMode l "Render Mode" t "Pick the desidered render mode." M {Diffuse "Local ST" Normal "Facing Ratio" UV ST "View Normal" "World Position" "" ""}}
 addUserKnob {6 facet_flatShading l "Flat Shading" t "Flat shading" +STARTLINE}
 addUserKnob {6 facet_depth l "Depth Buffer" t "Enable depth sorting to avoid additive surfaces." -STARTLINE}
 addUserKnob {6 facet_front l "Front Face" t "Render front facing facets" +STARTLINE}
 facet_front true
 addUserKnob {6 facet_backface l "Back Face" t "Render backfacing faces" -STARTLINE}
 facet_backface true
 addUserKnob {26 _1 l "<b><font color=#7DADF9>Other</font><b>"}
 addUserKnob {6 CloseX l "Close X" t "On spheres or round objects this closes the loop" +STARTLINE}
 addUserKnob {6 CloseY l "Close Y" t "On spheres or round objects this closes the loop" -STARTLINE}
 addUserKnob {20 Fog_1 l Fog}
 addUserKnob {26 Devider_Fog l "<b><font color=#7DADF9>Fog</font><b>"}
 addUserKnob {6 Fog t "Fog reduces the brightness of poins far from the camera." +STARTLINE}
 addUserKnob {7 FogNear l "Fog Near" R 0 200}
 FogNear 3
 addUserKnob {7 FogFar l "Fog Far" R 0 200}
 FogFar 10
 addUserKnob {7 FogExponent l "Fog Exponent" R 0 8}
 FogExponent 8
 addUserKnob {20 DepthOfField l "Depth of Field"}
 addUserKnob {26 devider_dof l "<b><font color=#7DADF9>Depth Of Field</font><b>"}
 addUserKnob {6 dof_enable l Enable +STARTLINE}
 addUserKnob {7 dof_focaldepth l "Focal Depth" R 0 40}
 dof_focaldepth 5
 addUserKnob {7 dof_dof l "Depth of Field" R 0 10}
 dof_dof 2
 addUserKnob {7 dof_maxSize l "Max Size"}
 dof_maxSize 0.5
 addUserKnob {7 dof_Aspect l "Aspect Ratio"}
 dof_Aspect 1
 addUserKnob {7 dof_bias l Bias R -3 3}
 dof_bias -0.2
 addUserKnob {4 Dof_Quality l Quality M {Low Medium High Extreme}}
 addUserKnob {20 MotionBlur}
 addUserKnob {26 devider_MotionBlur l "<b><font color=#7DADF9>Motion Blur</font><b>"}
 addUserKnob {6 mb_enable l Enable +STARTLINE}
 mb_enable true
 addUserKnob {6 Fast l "Fast (Interpolated)" -STARTLINE}
 Fast true
 addUserKnob {3 Samples}
 Samples 4
 addUserKnob {7 Shutter R 0 2}
 Shutter 0.5
 addUserKnob {4 pulldown l "Shutter Offset" M {Centered Start End ""}}
 addUserKnob {20 preview_3d l "3D Preview"}
 addUserKnob {6 Enable3DPreview l "Enable 3D Preview" t "Display a preview of the points in the Nuke 3D view." +STARTLINE}
 addUserKnob {41 pointSize l "point size" T PreviewNode.pointSize}
 addUserKnob {41 detail l "point detail" T PreviewNode.detail}
}
 BackdropNode {
  inputs 0
  name BackdropNode1
  tile_color 0x388e8e00
  label "Output Format Manager"
  note_font_size 22
  xpos -1491
  ypos 149
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode10
  tile_color 0x388e8e00
  label "AUX Input"
  note_font_size 22
  xpos -385
  ypos 178
  bdwidth 207
  bdheight 178
 }
 BackdropNode {
  inputs 0
  name BackdropNode11
  tile_color 0x388e8e00
  label "Point Render"
  note_font_size 22
  xpos -96
  ypos 99
  bdwidth 198
  bdheight 135
 }
 BackdropNode {
  inputs 0
  name BackdropNode12
  tile_color 0x388e8e00
  label "Normal Generator\nFor Vertex Normals"
  note_font_size 22
  xpos -616
  ypos 243
  bdwidth 191
  bdheight 122
 }
 BackdropNode {
  inputs 0
  name BackdropNode13
  tile_color 0x388e8e00
  label "Ensure output format"
  note_font_size 22
  xpos -622
  ypos -41
  bdwidth 198
  bdheight 135
 }
 BackdropNode {
  inputs 0
  name BackdropNode14
  tile_color 0x388e8e00
  label "Motion Blur"
  note_font_size 22
  xpos -85
  ypos 526
  bdwidth 193
  bdheight 91
 }
 BackdropNode {
  inputs 0
  name BackdropNode15
  tile_color 0x388e8e00
  label "Soft Preview"
  note_font_size 22
  xpos -83
  ypos 414
  bdwidth 191
  bdheight 94
 }
 BackdropNode {
  inputs 0
  name BackdropNode16
  tile_color 0x388e8e00
  label "Final format"
  note_font_size 22
  xpos -84
  ypos 295
  bdwidth 192
  bdheight 95
 }
 BackdropNode {
  inputs 0
  name BackdropNode17
  tile_color 0x388e8e00
  label "No Clue =)"
  note_font_size 22
  xpos -385
  ypos -41
  bdwidth 160
  bdheight 87
 }
 BackdropNode {
  inputs 0
  name BackdropNode2
  tile_color 0x388e8e00
  label Motionblur
  note_font_size 22
  xpos -672
  ypos -781
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode3
  tile_color 0x388e8e00
  label "Fast Preview"
  note_font_size 22
  xpos -669
  ypos -971
  bdwidth 254
  bdheight 138
 }
 BackdropNode {
  inputs 0
  name BackdropNode4
  tile_color 0x388e8e00
  label "Nearest Wire Mode Clamp"
  note_font_size 22
  xpos -666
  ypos -1184
  bdwidth 253
  bdheight 111
 }
 BackdropNode {
  inputs 0
  name BackdropNode5
  tile_color 0x388e8e00
  label Occlution
  note_font_size 22
  xpos 208
  ypos 27
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode6
  tile_color 0x388e8e00
  label "Input Camera Container"
  note_font_size 22
  xpos -1215
  ypos 148
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode7
  tile_color 0x388e8e00
  label "3D Preview"
  note_font_size 22
  xpos -88
  ypos -45
  bdwidth 207
  bdheight 102
 }
 BackdropNode {
  inputs 0
  name BackdropNode8
  tile_color 0x388e8e00
  label "Input Format Manager"
  note_font_size 22
  xpos -526
  ypos -459
  bdwidth 208
  bdheight 97
 }
 BackdropNode {
  inputs 0
  name BackdropNode9
  tile_color 0x388e8e00
  label FOG
  note_font_size 22
  xpos -602
  ypos -253
  bdwidth 370
  bdheight 152
 }
 Input {
  inputs 0
  name InputPointData
  xpos -584
  ypos -1321
 }
 Dot {
  name Dot4
  xpos -550
  ypos -1234
 }
set N551e4060 [stack 0]
 Reformat {
  type "to box"
  box_width 100
  box_height 100
  box_fixed true
  scale 0.1
  resize fill
  filter impulse
  black_outside true
  name Reformat5
  xpos -584
  ypos -906
  disable {{!parent.FastPreview==1}}
 }
 Grade {
  white 10
  name Grade2
  xpos -584
  ypos -874
  disable {{!parent.FastPreview}}
 }
 Dot {
  name Dot2
  xpos -550
  ypos -712
 }
set N54fc9500 [stack 0]
 Group {
  name FrameHold3
  tile_color 0xb0a45dff
  label "(frame \[value first_frames])"
  xpos -501
  ypos -719
  disable {{1-parent.mb_enable}}
  addUserKnob {20 User}
  addUserKnob {3 first_frames l "first frame"}
  first_frames {{frame+1}}
  addUserKnob {41 increment T FrameHold2.increment}
  addUserKnob {22 SetCurrentFrame l "Set This Frame" T "nuke.thisNode()\[\"first_frames\"].setValue(nuke.frame())" +STARTLINE}
 }
  Input {
   inputs 0
   name Input1
   xpos -7
   ypos -154
  }
  FrameHold {
   first_frame {{parent.knob.first_frames}}
   name FrameHold2
   xpos -7
   ypos -114
  }
  Output {
   name Output1
   xpos -7
   ypos -14
  }
 end_group
 Dot {
  name Dot6
  xpos -467
  ypos -659
 }
push $N54fc9500
 Group {
  name FrameHold2
  tile_color 0xb0a45dff
  label "(frame \[value first_frames])"
  xpos -660
  ypos -719
  disable {{1-parent.mb_enable}}
  addUserKnob {20 User}
  addUserKnob {3 first_frames l "first frame"}
  first_frames {{frame}}
  addUserKnob {41 increment T FrameHold2.increment}
  addUserKnob {22 SetCurrentFrame l "Set This Frame" T "nuke.thisNode()\[\"first_frames\"].setValue(nuke.frame())" +STARTLINE}
 }
  Input {
   inputs 0
   name Input1
   xpos -7
   ypos -154
  }
  FrameHold {
   first_frame {{parent.knob.first_frames}}
   name FrameHold2
   xpos -7
   ypos -114
  }
  Output {
   name Output1
   xpos -7
   ypos -14
  }
 end_group
 Dot {
  name Dot5
  xpos -626
  ypos -659
 }
 Dissolve {
  inputs 2
  which {{frame-floor(frame)}}
  name Dissolve1
  xpos -582
  ypos -666
  disable {{1-parent.mb_enable}}
 }
push $N54fc9500
 Switch {
  inputs 2
  which {{parent.Fast}}
  name Switch2
  xpos -582
  ypos -619
 }
 Dot {
  name DataFetch
  label "data fetch\t"
  note_font_color 0xff21ff
  xpos -550
  ypos -513
  addUserKnob {20 User}
  addUserKnob {3 n_particles l "Number of Particles"}
  n_particles {{"\[metadata pointrender/n_points]"}}
  addUserKnob {3 gentype l "Type Of Generator"}
  gentype {{"\[metadata pointrender/gen_type]"}}
  addUserKnob {26 info l "" -STARTLINE T "0 = unknown, 1 = Card, 2 = Sphere, 3 = Grid"}
 }
set N550251a0 [stack 0]
 Dot {
  name Dot3
  xpos -635
  ypos -513
 }
 Dot {
  name Dot1
  xpos -635
  ypos 676
 }
 Input {
  inputs 0
  name InputOcclution
  xpos 238
  ypos 75
  number 2
 }
 Constant {
  inputs 0
  channels rgb
  color 1
  name Empty
  xpos 371
  ypos 139
 }
 Switch {
  inputs 2
  which {{parent.UseOcclusionMap}}
  name Switch1
  xpos 238
  ypos 163
 }
 Input {
  inputs 0
  name Aux
  xpos -324
  ypos 214
  number 3
 }
 Reformat {
  type "to box"
  format "1280 720 0 0 1280 720 1 HD_720"
  box_width {{input.width>Settings_Format.format.width?input.width:Settings_Format.format.width}}
  box_height {{input.height>Settings_Format.format.height?input.height:Settings_Format.format.height}}
  box_fixed true
  resize none
  center false
  filter impulse
  black_outside true
  name Reformat2
  xpos -324
  ypos 238
 }
 Crop {
  box {0 0 {input.width} {input.height}}
  name Crop1
  xpos -324
  ypos 275
 }
push $N550251a0
 Shuffle {
  in pos
  name Shuffle1
  xpos -584
  ypos -192
 }
set N5506a2c0 [stack 0]
 Reformat {
  type "to box"
  format "1280 720 0 0 1280 720 1 HD_720"
  box_width {{input.width>Settings_Format.format.width?input.width:Settings_Format.format.width}}
  box_height {{input.height>Settings_Format.format.height?input.height:Settings_Format.format.height}}
  box_fixed true
  resize none
  center false
  filter impulse
  black_outside true
  name Reformat4
  xpos -584
  ypos 18
 }
 Crop {
  box {0 0 {input.width} {input.height}}
  name Crop2
  xpos -584
  ypos 48
 }
 Dot {
  name Dot8
  xpos -550
  ypos 166
 }
set N550951e0 [stack 0]
 Group {
  name Point_Normal2
  tile_color 0x434343ff
  note_font_color 0x55ffffff
  xpos -584
  ypos 311
  disable {{!(renderMode==2&&RenderMode==2)}}
  addUserKnob {20 User}
  addUserKnob {26 info l "" +STARTLINE T "Point Normal v1.0"}
  addUserKnob {26 devider_general l "<b><font color=#7DADF9>General</font><b>"}
  addUserKnob {26 info_1 l "" +STARTLINE T "well, not much to do here =)"}
 }
  Input {
   inputs 0
   name Input1
   xpos 389
   ypos 207
  }
  Shuffle {
   in pos
   name Shuffle1
   xpos 389
   ypos 294
  }
  BlinkScript {
   kernelSourceFile /Users/madshagbarth/Github/Nuke-Private/Blink/PointRender/Modify/BasicLight.cpp
   recompileCount 69
   ProgramGroup 1
   KernelDescription "2 \"PointRender3D\" iterate pixelWise d5452fe7b684561fcfa5182d0c789025a037cc4fe4474c24e065e3fa53fcd8ce 2 \"ppos\" Read Random \"dst\" Write Point 9 \"cam_Matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== \"focallength\" Float 1 AAA4QQ== \"hapeture\" Float 1 ppvEQQ== \"format\" Int 2 AAgAAAAIAAA= \"Zoom\" Float 1 AACAPw== \"half Lambert\" Bool 1 AQ== \"light Mode\" Int 1 AAAAAA== \"light_position\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"light_color\" Float 3 AACAPwAAgD8AAIA/AAAAAA== 9 \"cam_Matrix\" 16 1 \"cam_Focal\" 1 1 \"cam_Hapeture\" 1 1 \"WHformat\" 2 1 \"zoom\" 1 1 \"halfLambert\" 1 1 \"lightMode\" 1 1 \"lightPos\" 3 1 \"lightcolor\" 3 1 10 \"vRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"pRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"tRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"vWorld\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"canvasWidth\" Float 1 1 AAAAAA== \"canvasHeight\" Float 1 1 AAAAAA== \"matrixData\" Float 1 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cameraToWorld\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"worldToCamera\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"namount\" Float 1 1 AAAAAA=="
   kernelSource "inline float Frac(float a_X)\n\{\n    return a_X-floor(a_X);\n\}\n\ninline float Fmax(float a_X,float b_X,float c_X)\n\{\n    return max(c_X,max(a_X,b_X));\n\}\ninline float Fmin(float a_X,float b_X,float c_X)\n\{\n    return min(c_X,min(a_X,b_X));\n\}\n\ninline float saturate(float _in)\n\{\n    return max(0.0f,min(1.0f,_in));\n\}\n\ninline float3 reflect(float3 incidence,float3 normal)\n\{\n  return incidence - 2.f * dot(incidence, normal) * normal;\n\}\n\n//This function is used to multiply a float3 by a matrix4x4\ninline float3 multVecMatrix( float3 src, float4x4 matrix)\n\{\n    float   x,y,z,w;\n    \n    x = src\[0]*matrix\[0]\[0] + src\[1]*matrix\[1]\[0] +\n    src\[2]*matrix\[2]\[0] + matrix\[3]\[0];\n    y = src\[0]*matrix\[0]\[1] + src\[1]*matrix\[1]\[1] +\n    src\[2]*matrix\[2]\[1] + matrix\[3]\[1];\n    z = src\[0]*matrix\[0]\[2] + src\[1]*matrix\[1]\[2] +\n    src\[2]*matrix\[2]\[2] + matrix\[3]\[2];\n    w = src\[0]*matrix\[0]\[3] + src\[1]*matrix\[1]\[3] +\n    src\[2]*matrix\[2]\[3] + matrix\[3]\[3];\n    \n    return float3(x/w, y/w, z/w);\n\}\n\n//This function is used to calculate the screenspace coordinates.\ninline bool computePixelCoordinates( \n    const float3 pWorld, \n    float3 &pRaster, \n    const float4x4 &worldToCamera, \n    const float &canvasWidth, \n    const float &canvasHeight, \n    const int &imageWidth, \n    const int &imageHeight\n) \n\{ \n    float3 pCamera; \n    pCamera = multVecMatrix(pWorld, worldToCamera); \n    float2 pScreen; \n    pScreen.x = pCamera.x / -pCamera.z; \n    pScreen.y = pCamera.y / -pCamera.z; \n    if (fabs(pScreen.x) > canvasWidth || fabs(pScreen.y) > canvasHeight) \n         return false; \n    float2 pNDC; \n    pNDC.x = (pScreen.x + canvasWidth * 0.5f) / canvasWidth; \n    pNDC.y = (pScreen.y + canvasHeight * 0.5f) / canvasHeight; \n    pRaster.x = (pNDC.x * imageWidth); \n    pRaster.y = ((pNDC.y) * imageHeight); \n    pRaster.z = -pCamera.z; \n    if (pRaster.x < 0.0f || pRaster.x > imageWidth || \n       pRaster.y < 0.0f || pRaster.y > imageHeight) \{\n       return false;  \n    \}\n    return true;\n\} \n\n\n\nkernel PointRender3D : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessRandom, eEdgeClamped> ppos;    //The point position map\n  Image<eWrite> dst;                 //the output image\n\n  param: //Parameters available to the user\n    float4x4 cam_Matrix;    //The world matrix of the camera\n    float cam_Focal;        //The focal length of the camera\n    float cam_Hapeture;     //The horizontal apeture of the camera\n    int2 WHformat;          //The format of the output image\n    float zoom;             //A \"post\" zoom function\n    bool halfLambert;\n    int lightMode;\n    float3 lightPos;\n    float3 lightcolor;\n\n\n  local: //Local variables\n    float3 vRaster;\n    float3 pRaster;\n    float3 tRaster;    \n    float3 vWorld;\n    float canvasWidth;\n    float canvasHeight; \n    float matrixData\[4]\[4];\n    float4x4 cameraToWorld;\n    float4x4 worldToCamera;\n    float namount; //dither amount\n\n\n  void define() \{\n    defineParam(cam_Matrix, \"cam_Matrix\", float4x4( 1.0f,0.0f,0.0f,0.0f,\n                                                    0.0f,1.0f,0.0f,0.0f,\n                                                    0.0f,0.0f,1.0f,0.0f,\n                                                    0.0f,0.0f,0.0f,1.0f));\n    defineParam(cam_Focal,      \"focallength\", 11.5f);\n    defineParam(cam_Hapeture,      \"hapeture\", 24.576f);\n    defineParam(WHformat,      \"format\", int2(2048,2048));\n    defineParam(zoom, \"Zoom\", 1.0f);\n    defineParam(halfLambert, \"half Lambert\", true);\n    defineParam(lightMode, \"light Mode\", 0);\n    defineParam(lightPos,      \"light_position\", float3(0,0,0));  \n    defineParam(lightcolor,      \"light_color\", float3(1.0,1.0,1.0)); \n  \}\n\n\n  //The init() function is run before any calls to process().\n  void init() \{\n    canvasWidth = ((cam_Hapeture)/cam_Focal);\n    canvasHeight = ((cam_Hapeture)/cam_Focal)*float(float(WHformat.y)/float(WHformat.x)); \n    float matrixData\[] = \{cam_Matrix\[0]\[0], cam_Matrix\[1]\[0], cam_Matrix\[2]\[0], cam_Matrix\[3]\[0], \n                          cam_Matrix\[0]\[1], cam_Matrix\[1]\[1], cam_Matrix\[2]\[1], cam_Matrix\[3]\[1], \n                          cam_Matrix\[0]\[2], cam_Matrix\[1]\[2], cam_Matrix\[2]\[2], cam_Matrix\[3]\[2], \n                          cam_Matrix\[0]\[3], cam_Matrix\[1]\[3], cam_Matrix\[2]\[3], cam_Matrix\[3]\[3]\};\n    cameraToWorld.setArray(matrixData); //This is a workaround. Due to the buggy matrix implementation, we pass the matrix on from another structure.\n    worldToCamera = cameraToWorld.invert();\n    namount = 0.0001; //dither amount\n  \}\n\n\n\nfloat3 Reconsile3D(float3 _PointPos)\{\n    vWorld = float3(_PointPos.x,_PointPos.y,_PointPos.z)*(zoom);\n    int ret = computePixelCoordinates(vWorld, tRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1]);\n    return tRaster;\n\}\n\n\n\n//-------------------------------------\n// Facet_Render\n//-------------------------------------\n//This function is used to calculate what triangels to draw\nfloat3 facet_render(int2 pos, float3 _vWorld)\{\n\n    float3 screen_pos = Reconsile3D(_vWorld);\n    bool insideX = ppos.bounds.inside(pos.x+1,pos.y );\n    bool insideY = ppos.bounds.inside(pos.x,pos.y-1 );\n    bool insideYtop = ppos.bounds.inside(pos.x,pos.y+1);\n    float2 fpos = float2(pos.x,pos.y);\n    float3 V1_Pos,V2_Pos,V1_wPos,V2_wPos;\n    float4 V0_Sample,V1_Sample,V2_Sample;\n    float3 normal0,normal1,normal2;\n\n    //for area calculation\n    float area;\n    float3 V0,V1,V2;\n    float3 output = float3(0.0f);\n  if (insideX) \{\n    V2_Sample = ppos(pos.x+1,pos.y);\n    V2_wPos = float3(V2_Sample.x,V2_Sample.y,V2_Sample.z);\n    V2_Pos = Reconsile3D(V2_wPos);\n    if (V2_Sample.w != 0.0f) \{ \n\n      if (insideY) \{\n        V1_Sample = ppos(pos.x+1,pos.y-1);\n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (V1_Sample.w != 0.0f) \{ \n            float3 Normal = CalculateVertexNormals(_vWorld,V2_wPos,V1_wPos);\n\n            //Calculate Area for density:\n            V0 = screen_pos;\n            V1 = V1_Pos;\n            V2 = V2_Pos;\n            V0.z = 1.0f / V0.z, V1.z = 1.0f / V1.z, V2.z = 1.0f / V2.z; \n            area = length(V0-V1)+length(V0-V2)+length(V1-V2);\n\n          //write output\n          output +=  float3(Normal.x,Normal.y,Normal.z);\n        \}\n      \}\n      if (insideYtop) \{\n        V1_Sample = ppos(pos.x,pos.y+1);\n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (V1_Sample.w != 0.0f) \{ \n          float3 Normal = CalculateVertexNormals(_vWorld,V1_wPos,V2_wPos);\n\n            //Calculate Area for density:\n            V0 = screen_pos;\n            V1 = V1_Pos;\n            V2 = V2_Pos;\n            V0.z = 1.0f / V0.z, V1.z = 1.0f / V1.z, V2.z = 1.0f / V2.z; \n            area = length(V0-V1)+length(V0-V2)+length(V1-V2);\n\n          output += float3(Normal.x,Normal.y,Normal.z);\n\n        \}\n      \}\n    \}\n  \}\n  return output;\n\}\n\n\n\nfloat3 CalculateSurfaceNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat3 CalculateVertexNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 hitNormal = cross((V1 - V0),(V2 - V0)); \n        return hitNormal;\n\}\n\n\n\n//-------------------------------------\n// Process\n//-------------------------------------\n  void process(int2 pos) \{\n    float3 output = float3(0.0f);\n    float4 _sample = ppos(pos.x,pos.y); //Get the XYZ Coordinates\n    float3 point_pos = float3(_sample.x,_sample.y,_sample.z);\n    if (_sample.w != 0.0f) \{  //No need to process if there is no data.\n      dst() = float4(0.0f);\n      output+=facet_render(pos,float3(_sample.x,_sample.y,_sample.z))*2.0f;\n      _sample = ppos(pos.x-1,pos.y); //Get the XYZ Coordinates\n      output+=facet_render(int2(pos.x-1,pos.y),float3(_sample.x,_sample.y,_sample.z));\n\n      _sample = ppos(pos.x-1,pos.y+1); //Get the XYZ Coordinates\n      output+=facet_render(int2(pos.x-1,pos.y+1),float3(_sample.x,_sample.y,_sample.z));\n\n      _sample = ppos(pos.x,pos.y-1); //Get the XYZ Coordinates\n      output+=facet_render(int2(pos.x,pos.y-1),float3(_sample.x,_sample.y,_sample.z));\n\n      output = normalize(output);\n      float3 normal = -output;\n\n      \n\n\n      dst() = float4(normal.x,normal.y,normal.z,1.0f);\n    \}\n  \} //----> process\n\};\n"
   rebuild ""
   "PointRender3D_half Lambert" false
   "PointRender3D_light Mode" {{parent.LightFalloff}}
   PointRender3D_light_position {{parent.Axis1.translate} {parent.Axis1.translate} {parent.Axis1.translate}}
   PointRender3D_light_color {{parent.LightColor} {parent.LightColor} {parent.LightColor}}
   rebuild_finalise ""
   name BlinkScript1
   xpos 389
   ypos 344
  }
  Grade {
   multiply 0.5
   add 0.5
   black_clamp false
   name Grade1
   xpos 389
   ypos 376
   disable true
  }
  Output {
   name Output1
   xpos 389
   ypos 459
  }
  Axis2 {
   inputs 0
   translate {0.5 0.5 0.5}
   name Axis1
   xpos 661
   ypos 318
   addUserKnob {20 Ivy}
   addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.toolbox.v1.nodes.docs', fromlist=\['open_docs_name']).open_docs_name('IvyTab')" +STARTLINE}
   addUserKnob {26 divider4 l "" +STARTLINE}
   addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
   _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
   addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
   addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
   addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
   _expressions {{curve}}
   addUserKnob {26 divider0 l "" +STARTLINE}
   addUserKnob {20 dbinfo l "DB Info" n 1}
   dbinfo 0
   addUserKnob {1 twig_dnuuid l "Twig Id"}
   addUserKnob {1 stalk_dnuuid l "Stalk Id"}
   addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
   addUserKnob {1 leaf_dnuuid l "Leaf Id"}
   addUserKnob {26 divider1 l "" +STARTLINE}
   addUserKnob {1 twigtype l "Twig Type"}
   addUserKnob {1 leaf_label l Leaf}
   addUserKnob {1 ivy_version l Version}
   addUserKnob {43 ivy_notes l Notes}
   addUserKnob {26 divider2 l "" +STARTLINE}
   addUserKnob {1 build_label l "Build Label"}
   addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
  }
 end_group
 Switch {
  inputs 2
  which {{parent.connect_aux}}
  name Switch3
  xpos -324
  ypos 311
 }
push $N5506a2c0
 Expression {
  temp_name0 xd
  temp_expr0 red-Camera1.world_matrix.3
  temp_name1 yd
  temp_expr1 green-Camera1.world_matrix.7
  temp_name2 zd
  temp_expr2 blue-Camera1.world_matrix.11
  temp_name3 Distance
  temp_expr3 "sqrt(xd*xd + yd*yd + zd*zd)"
  expr0 Distance
  expr1 Distance
  expr2 Distance
  expr3 Distance
  name Expression1
  xpos -456
  ypos -192
 }
 Grade {
  channels rgba
  blackpoint {{parent.FogFar}}
  whitepoint {{parent.FogNear}}
  gamma {{1/(parent.FogExponent+0.000000001)}}
  white_clamp true
  name Grade1
  xpos -456
  ypos -168
 }
push $N550251a0
 Dot {
  name Dot7
  xpos -307
  ypos -513
 }
 Merge2 {
  inputs 2
  operation multiply
  name Merge1
  xpos -341
  ypos -168
  disable {{!parent.Fog}}
 }
 Shuffle {
  name Shuffle3
  xpos -341
  ypos 8
 }
set N54f4b610 [stack 0]
push $N550951e0
 BlinkScript {
  inputs 4
  kernelSourceFile /Users/madshagbarth/Github/Nuke-Private/Blink/PointRender/Render/3D_PointRender_v15.cpp
  recompileCount 792
  ProgramGroup 1
  KernelDescription "2 \"PointRender3D\" iterate pixelWise e0ecbbf4cba39730471d23bc9f9ec846fcae1bbb869971a11b15641cf6fd5620 5 \"ppos\" Read Random \"src\" Read Random \"normals\" Read Random \"occlusion\" Read Random \"dst\" Write Random 48 \"cam_Matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== \"focallength\" Float 1 AAA4QQ== \"hapeture\" Float 1 ppvEQQ== \"format\" Int 2 AAgAAAAIAAA= \"vertexformat\" Int 2 CgAAAAoAAAA= \"Zoom\" Float 1 AACAPw== \"Filtering Method\" Int 1 AQAAAA== \"_alphaMultiplier\" Float 1 AACAPw== \"_pointRender\" Bool 1 AQ== \"_wireRender\" Bool 1 AQ== \"_facetRender\" Bool 1 AQ== \"_maxLDistance\" Float 1 AACAPw== \"_maxLConnections\" Int 1 AQAAAA== \"_maxPlexType\" Int 1 AAAAAA== \"_plexLinedefXY\" Bool 1 AA== \"_plexLinedefX\" Bool 1 AA== \"_plexLinedefY\" Bool 1 AA== \"_plexLinedefXtoY\" Bool 1 AA== \"_plexLinedefAUX\" Bool 1 AA== \"_plexConnectX\" Bool 1 AA== \"_plexConnectY\" Bool 1 AA== \"_L_gamma\" Float 1 AACAPw== \"Enable Depth of Field\" Bool 1 AA== \"samples\" Int 1 AwAAAA== \"rings\" Int 1 BQAAAA== \"focalDepth\" Float 1 AACAPw== \"_depthOfField\" Float 1 AACAQA== \"_depthMult\" Float 1 zczMPQ== \"_maxDofSize\" Float 1 AAAAQQ== \"dof_aspect\" Float 1 AACAPw== \"dof_threshold\" Float 1 AACAPw== \"dof_gain\" Float 1 AAAAAA== \"dof_bias\" Float 1 AAAAwA== \"dof_fringe\" Float 1 AAAAAA== \"_flatshading\" Bool 1 AQ== \"_backfacing\" Bool 1 AQ== \"_frontfacing\" Bool 1 AQ== \"_vertexMode\" Int 1 AAAAAA== \"_depthBuffer\" Bool 1 AQ== \"_texoffset\" Float 2 AAAAPwAAAD8= \"_pointSize\" Int 1 AQAAAA== \"_gaussigma\" Float 1 AACAPw== \"_depthOcclusion\" Bool 1 AQ== \"depthMultiplier\" Float 1 AACAPw== \"_maxLineSteps\" Float 1 AAB6RQ== \"_lineOffset\" Float 1 AACAPw== \"_lineInMultiplier\" Float 1 AACAPw== \"_lineOutMultiplier\" Float 1 AACAPw== 48 \"cam_Matrix\" 16 1 \"cam_Focal\" 1 1 \"cam_Hapeture\" 1 1 \"WHformat\" 2 1 \"Vformat\" 2 1 \"zoom\" 1 1 \"_filtering\" 1 1 \"_alphaMultiplier\" 1 1 \"_pointRender\" 1 1 \"_wireRender\" 1 1 \"_facetRender\" 1 1 \"_maxPlexDistance\" 1 1 \"_maxPlexConnections\" 1 1 \"_maxPlexType\" 1 1 \"_plexLinedefXY\" 1 1 \"_plexLinedefX\" 1 1 \"_plexLinedefY\" 1 1 \"_plexLinedefXtoY\" 1 1 \"_plexLinedefAUX\" 1 1 \"_plexConnectX\" 1 1 \"_plexConnectY\" 1 1 \"_plex_gamma\" 1 1 \"_dof_enable\" 1 1 \"_dof_samples\" 1 1 \"_dof_rings\" 1 1 \"focalDepth\" 1 1 \"_depthOfField\" 1 1 \"_depthMult\" 1 1 \"_maxDofSize\" 1 1 \"dof_aspect\" 1 1 \"dof_threshold\" 1 1 \"dof_gain\" 1 1 \"dof_bias\" 1 1 \"dof_fringe\" 1 1 \"_flatshading\" 1 1 \"_backfacing\" 1 1 \"_frontfacing\" 1 1 \"_vertexMode\" 1 1 \"_depthBuffer\" 1 1 \"_texoffset\" 2 1 \"_pointSize\" 1 1 \"_gaussigma\" 1 1 \"_depthOcclusion\" 1 1 \"depthMultiplier\" 1 1 \"_maxLineSteps\" 1 1 \"_lineOffset\" 1 1 \"_lineInMultiplier\" 1 1 \"_lineOutMultiplier\" 1 1 10 \"max_line_connections\" Int 1 1 AAAAAA== \"vRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"pRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"tRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"vWorld\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"canvasWidth\" Float 1 1 AAAAAA== \"canvasHeight\" Float 1 1 AAAAAA== \"matrixData\" Float 1 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cameraToWorld\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"worldToCamera\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "//Some basic generic functions.\ninline float Frac(float a_X)\n\{\n    return a_X-floor(a_X);\n\}\n\ninline float3 Cross(float3 A,float3 B)\n\{\n    return float3(A.y*B.z - A.z*B.y,A.z*B.x - A.x*B.z,A.x*B.y - A.y*B.x);\n\}\n\ninline float Fmax(float a_X,float b_X,float c_X)\n\{\n    return max(c_X,max(a_X,b_X));\n\}\ninline float Fmin(float a_X,float b_X,float c_X)\n\{\n    return min(c_X,min(a_X,b_X));\n\}     \n\ninline float3 mix(float3 _X,float3 _Y,float _A)\{\n  return _X*(1.0f-_A)+_Y*_A;\n\}\ninline float mix(float _X,float _Y,float _A)\{\n  return _X*(1.0f-_A)+_Y*_A;\n\}                                                                                              \n\n//This function is used to multiply a float3 by a matrix4x4\ninline float3 multVecMatrix( float3 src, float4x4 matrix)\n\{\n    float   x,y,z,w;\n\n    x = src\[0]*matrix\[0]\[0] + src\[1]*matrix\[1]\[0] +\n    src\[2]*matrix\[2]\[0] + matrix\[3]\[0];\n    y = src\[0]*matrix\[0]\[1] + src\[1]*matrix\[1]\[1] +\n    src\[2]*matrix\[2]\[1] + matrix\[3]\[1];\n    z = src\[0]*matrix\[0]\[2] + src\[1]*matrix\[1]\[2] +\n    src\[2]*matrix\[2]\[2] + matrix\[3]\[2];\n    w = src\[0]*matrix\[0]\[3] + src\[1]*matrix\[1]\[3] +\n    src\[2]*matrix\[2]\[3] + matrix\[3]\[3];\n    \n    return float3(x/w, y/w, z/w);\n\}\n\n//This function is used to calculate the screenspace coordinates.\ninline bool computePixelCoordinates( \n    const float3 pWorld, \n    float3 &pRaster, \n    const float4x4 &worldToCamera, \n    const float &canvasWidth, \n    const float &canvasHeight, \n    const int &imageWidth, \n    const int &imageHeight\n) \n\{ \n    float3 pCamera; \n    pCamera = multVecMatrix(pWorld, worldToCamera); \n    float2 pScreen; \n    pScreen.x = pCamera.x / -pCamera.z; \n    pScreen.y = pCamera.y / -pCamera.z; \n    float2 pNDC; \n    pNDC.x = (pScreen.x + canvasWidth * 0.5f) / canvasWidth; \n    pNDC.y = (pScreen.y + canvasHeight * 0.5f) / canvasHeight; \n    pRaster.x = (pNDC.x * imageWidth); \n    pRaster.y = ((pNDC.y) * imageHeight); \n    pRaster.z = -pCamera.z; \n    if (pRaster.x < 0.0f || pRaster.x > imageWidth || \n       pRaster.y < 0.0f || pRaster.y > imageHeight || pRaster.z < 0.0f) \{\n       return false;  \n    \}\n    return true;\n\} \n\n\nkernel PointRender3D : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessRandom, eEdgeClamped> ppos;    //The point position map\n  Image<eRead, eAccessRandom, eEdgeClamped> src;     //The texture map\n  Image<eRead, eAccessRandom, eEdgeClamped> normals;     //The texture map  \n  Image<eRead, eAccessRandom, eEdgeClamped> occlusion;     //The texture map \n  Image<eWrite, eAccessRandom> dst;                 //the output image\n\n  param: //Parameters available to the user\n    float4x4 cam_Matrix;    //The world matrix of the camera\n    float cam_Focal;        //The focal length of the camera\n    float cam_Hapeture;     //The horizontal apeture of the camera\n    int2 WHformat,Vformat;          //The format of the output image\n    float zoom;             //A \"post\" zoom function\n    int _filtering;        //Filter method\n    float _alphaMultiplier; //Additive multiplier\n    bool _pointRender,_wireRender,_facetRender;\n    float _maxPlexDistance; //Additive multiplier\n    int _maxPlexConnections;\n    int _maxPlexType; // 0==Grid, -1==Nearest\n    bool _plexLinedefXY,_plexLinedefX,_plexLinedefY,_plexLinedefXtoY,_plexLinedefAUX; // Define what connections NOT to include\n    bool _plexConnectX,_plexConnectY; //Connect from the edge of x to 0, or edge of y to 0, usually for spheres\n    float _plex_gamma; //The threshold making shorter paths bright and longer paths dark\n    bool _dof_enable; // Enable DOF\n    int _dof_samples; // How many samples per DOF ring\n    int _dof_rings; // How many rings \n    float focalDepth,_depthOfField,_depthMult,_maxDofSize; //DOF Settings\n    float dof_aspect; //Pixel aspect ratio\n    float dof_threshold;\n    float dof_gain;\n    float dof_bias; //bokeh edge bias\n    float dof_fringe; //bokeh chromatic aberration/fringing\n    bool _flatshading,_backfacing,_frontfacing; //Vertex rendering settings\n    int _vertexMode;  //The rendering output mode, (think AOV)\n    bool _depthBuffer; //Non-additive, only render front most pixel\n    float2 _texoffset;\n    int _pointSize;\n    float _gaussigma;\n    bool _depthOcclusion;\n    float depthMultiplier;\n    float _maxLineSteps; //cap the line length to avoid process lock\n    float _lineOffset; //Alow you to shrink or extend the lines\n    float _lineInMultiplier,_lineOutMultiplier; //Control the brightness of the wires at the tips.\n\n  local: //Local variables\n    int max_line_connections;\n    float3 vRaster;\n    float3 pRaster;\n    float3 tRaster;    \n    float3 vWorld;\n    float canvasWidth;\n    float canvasHeight; \n    float matrixData\[4]\[4];\n    float4x4 cameraToWorld;\n    float4x4 worldToCamera;\n\n  void define() \{\n    defineParam(cam_Matrix, \"cam_Matrix\", float4x4( 1.0f,0.0f,0.0f,0.0f,\n                                                    0.0f,1.0f,0.0f,0.0f,\n                                                    0.0f,0.0f,1.0f,0.0f,\n                                                    0.0f,0.0f,0.0f,1.0f));\n    defineParam(cam_Focal,      \"focallength\", 11.5f);\n    defineParam(cam_Hapeture,      \"hapeture\", 24.576f);\n    defineParam(WHformat,      \"format\", int2(2048,2048));\n    defineParam(Vformat,      \"vertexformat\", int2(10,10));\n    defineParam(zoom, \"Zoom\", 1.0f);\n    defineParam(_filtering, \"Filtering Method\", 1); \n    defineParam(_alphaMultiplier, \"_alphaMultiplier\", 1.0f);     \n    defineParam(_pointRender, \"_pointRender\", true);  \n    defineParam(_wireRender, \"_wireRender\", true);\n    defineParam(_facetRender, \"_facetRender\", true);\n    defineParam(_maxPlexDistance, \"_maxLDistance\", 1.0f);    \n    defineParam(_maxPlexConnections, \"_maxLConnections\", 1);    \n    defineParam(_maxPlexType, \"_maxPlexType\", 0); \n    defineParam(_plexLinedefXY, \"_plexLinedefXY\", false);      \n    defineParam(_plexLinedefXtoY, \"_plexLinedefXtoY\", false); //NYI\n    defineParam(_plexLinedefAUX, \"_plexLinedefAUX\", false); \n    defineParam(_plexLinedefX, \"_plexLinedefX\", false);  \n    defineParam(_plexLinedefY, \"_plexLinedefY\", false);  \n    defineParam(_plexConnectX, \"_plexConnectX\", false);      \n    defineParam(_plexConnectY, \"_plexConnectY\", false);   \n    defineParam(_plex_gamma, \"_L_gamma\", 1.0f);\n    //DOF SETTINGS   \n    defineParam(_dof_enable, \"Enable Depth of Field\", false);   \n    defineParam(_dof_samples, \"samples\", 3);    \n    defineParam(_dof_rings, \"rings\", 5);   \n    defineParam(focalDepth, \"focalDepth\", 1.0f);  \n    defineParam(_depthOfField, \"_depthOfField\", 4.0f);  \n    defineParam(_depthMult, \"_depthMult\", 0.1f);  \n    defineParam(_maxDofSize, \"_maxDofSize\", 8.0f);  \n    defineParam(dof_aspect, \"dof_aspect\", 1.0f);  \n    defineParam(dof_threshold, \"dof_threshold\", 1.0f);  \n    defineParam(dof_gain, \"dof_gain\", 0.0f);  \n    defineParam(dof_bias, \"dof_bias\", -2.0f);  \n    defineParam(dof_fringe, \"dof_fringe\", 0.0f); \n    //SHADING SETTINGS \n    defineParam(_flatshading, \"_flatshading\", true);  \n    defineParam(_vertexMode, \"_vertexMode\", 0);  \n    defineParam(_backfacing, \"_backfacing\", true);    \n    defineParam(_frontfacing, \"_frontfacing\", true);        \n    defineParam(_depthBuffer, \"_depthBuffer\", true);  \n    defineParam(_texoffset, \"_texoffset\", float2(0.5f,0.5f)); \n    defineParam(_pointSize, \"_pointSize\", 1); \n    defineParam(_gaussigma, \"_gaussigma\", 1.0f); \n    defineParam(_depthOcclusion, \"_depthOcclusion\", true); \n    defineParam(depthMultiplier, \"depthMultiplier\", 1.0f); \n    defineParam(_maxLineSteps, \"_maxLineSteps\", 4000.0f); \n    defineParam(_lineOffset, \"_lineOffset\", 1.0f); \n    defineParam(_lineInMultiplier, \"_lineInMultiplier\", 1.0f);   \n    defineParam(_lineOutMultiplier, \"_lineOutMultiplier\", 1.0f);     \n\n  \}\n\n  //The init() function is run before any calls to process().\n  void init() \{\n    max_line_connections = 80;\n    canvasWidth = ((cam_Hapeture)/cam_Focal);\n    canvasHeight = ((cam_Hapeture)/cam_Focal)*float(float(WHformat.y)/float(WHformat.x)); \n    float matrixData\[] = \{cam_Matrix\[0]\[0], cam_Matrix\[1]\[0], cam_Matrix\[2]\[0], cam_Matrix\[3]\[0], \n                          cam_Matrix\[0]\[1], cam_Matrix\[1]\[1], cam_Matrix\[2]\[1], cam_Matrix\[3]\[1], \n                          cam_Matrix\[0]\[2], cam_Matrix\[1]\[2], cam_Matrix\[2]\[2], cam_Matrix\[3]\[2], \n                          cam_Matrix\[0]\[3], cam_Matrix\[1]\[3], cam_Matrix\[2]\[3], cam_Matrix\[3]\[3]\};\n    cameraToWorld.setArray(matrixData); //This is a workaround. Due to the buggy matrix implementation, we pass the matrix on from another structure.\n    worldToCamera = cameraToWorld.invert();\n  \}\n\n  //Convert a 3d point position into a 2d raster position.\n  float3 Reconsile3D(float3 _PointPos)\{\n      vWorld = float3(_PointPos.x,_PointPos.y,_PointPos.z)*(zoom);\n      int ret = computePixelCoordinates(vWorld, tRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1]);\n      return tRaster;\n  \}\n\n//------------------------------\n//-------DRAW FUNCTIONS---------\n//------------------------------\n  //Write pixels to output.\n  void writepixel(float posx,float posy, float4 color,int index,float weight=1.0f)\n  \{ \n      if (_depthOcclusion)\{\n        float4 depthSample = occlusion(posx,posy);\n        if (depthSample.x<=vRaster.z && depthSample.w>0.0f)\{\n\n          float depth = (vRaster.z-depthSample.x);\n          color = color*(1.0f-depthSample.w);\n          color = color / (((depth*depth)*depthMultiplier)+1.0f);\n          //return;\n        \}\n      \}\n      float4 finalOutput; //This is used to store the final output\n      float4 dstSample; //This is used to store a sample of the destination\n      if ( dst.bounds.inside( posx, posy ) ) \{ //Test if the pixel written to is inside the output image. \n        if (_depthBuffer) \{\n          dstSample = (float4)dst(posx,posy); //Sample the destination image\n          if ((dstSample.w>color.w)||dstSample.w==0.0f) \{\n            dst(posx,posy) = color;\n          \}\n        \}\n        else \{\n          dstSample = (float4)dst(posx,posy); //Sample the destination image\n          finalOutput = dstSample + (color*_alphaMultiplier*weight);\n          finalOutput.w = dstSample.w + ((color.w*_alphaMultiplier*weight));\n\n          finalOutput.w = (dstSample.w + ((color.w*_alphaMultiplier*weight)))-(dstSample.w * ((color.w*_alphaMultiplier*weight)));\n\n          dst(posx,posy) = finalOutput;\n        \}\n      \} \n  \}\n\n  //Calculate a Bilinear Plot\n  void bilinear_Plot(float2 temppos,float4 color,int index)\n  \{\n    float2 p;\n    p.x=Frac(temppos.x);\n    p.y=Frac(temppos.y);\n    float weights\[] = \{(1.0f-p.x)*(1.0f-p.y), p.x*(1.0f-p.y), (1.0f-p.x)*p.y, p.x*p.y\};\n    int2 _position = int2(floor(temppos.x)-0,floor(temppos.y)-0); \n    writepixel(_position.x,_position.y,color,index,weights\[0]);\n    writepixel(_position.x+1,_position.y,color,index,weights\[1]);\n    writepixel(_position.x,_position.y+1,color,index,weights\[2]);\n    writepixel(_position.x+1,_position.y+1,color,index,weights\[3]);\n  \}\n\n  //NYI, unused!\n  void gaussian(float2 temppos,float4 color,int index)\{\n    float in_x = temppos.x;\n    float in_y = temppos.y;\n    int kernelSize = (_pointSize+1)*2;\n    int subsize = (kernelSize /2)-1;\n    float gKernel\[64]\[64];\n    float sigma = _gaussigma;\n    float intSigma = float(_pointSize);\n    float r, s = intSigma * sigma * sigma;\n\n    float sum = 0.0f;\n\n    // generate 5x5 kernel\n    for (int x = -subsize; x <= subsize; x++)\n    \{\n        for(int y = -subsize; y <= subsize; y++)\n        \{\n            r = float(sqrt(x*x + y*y));\n            gKernel\[x + subsize]\[y + subsize] = (exp(-(r*r)/s))/(3.141592654f * s);\n            sum += gKernel\[x + subsize]\[y + subsize];\n        \}\n    \}\n\n    // normalize the Kernel\n    for (int x = -subsize; x <= subsize; x++)\n    \{\n        for(int y = -subsize; y <= subsize; y++)\n        \{\n            gKernel\[x + subsize]\[y + subsize] /= sum;\n            writepixel(in_x+x,in_y+y,color,index,gKernel\[x + subsize]\[y + subsize]);\n        \}\n    \}\n  \}\n\n//-------------------------------------\n// DrawLine\n// ----------\n// Draw a line between two points, \n// x,y being 2d screenspace pos and z being depth.\n//-------------------------------------\n  void DrawLine(float3 origin, float3 endpoint,float4 _colorA,float4 _colorB) \{\n    float4 _color;\n    float3 delta = origin-endpoint;\n    float3 curPoint = origin;\n    float mag = sqrt(delta.x*delta.x+delta.y*delta.y);\n    mag = min(mag,_maxLineSteps); //Lets not go crazy, we cap it at 10.000 to avoid insane unwated processing time \n    for( float a = 0; a < mag*_lineOffset; a = a + 1.0f )\{\n      curPoint -= (delta/mag);\n      _color = (_colorA*(1.0f-(a/mag*1.0f)))+(_colorB*(a/mag*1.00f));\n      if (_dof_enable)\{\n        Bokeh(curPoint,_color);\n      \}\n      else \{\n        bilinear_Plot(float2(curPoint.x,curPoint.y),_color,1);\n      \}\n      \n    \}\n  \}\n\n//-------------------------------------\n// Point_Render\n//-------------------------------------\nvoid point_render(int2 pos, float3 screen_pos)\{\n  float4 color = src(pos.x,pos.y);\n\n  if (_filtering == 1)\{\n      if (_dof_enable)\{\n        Bokeh(screen_pos,color);\n      \}\n      else \{\n        bilinear_Plot(float2(screen_pos.x,screen_pos.y),color,1);\n      \}\n  \}\n  /*\n  //THIS PART NEEDS TO BE RE-WRITTEN.\n  else if (_filtering == 2)\{ \n      if (_dof_enable)\{\n        Bokeh(screen_pos,color);\n      \}\n      else \{\n        gaussian(float2(screen_pos.x,screen_pos.y),color,1);\n      \}\n  \}\n  */\n  else \{\n      int2 _position = int2(floor(screen_pos.x),floor(screen_pos.y)); \n      if (_depthBuffer) \{color.w = screen_pos.z;\}\n      writepixel(_position.x,_position.y, color,1,1.0f); //OutputSample\n  \}\n\n\}\n\n//-------------------------------------\n// Facet_Render\n//-------------------------------------\n//This function is used to calculate what triangels to draw\nvoid facet_render(int2 pos, float3 _vWorld)\{\n\n    float3 screen_pos = Reconsile3D(_vWorld);\n\n    bool insideX = ppos.bounds.inside(pos.x+1,pos.y );\n    bool insideY = ppos.bounds.inside(pos.x+1,pos.y-1 );\n    bool insideYtop = ppos.bounds.inside(pos.x,pos.y+1);\n    float2 fpos = float2(pos.x,pos.y);\n    float3 V1_Pos,V2_Pos,V1_wPos,V2_wPos,V0_N,V1_N,V2_N;\n    float2 V0_ST,V1_ST,V2_ST;\n    float4 V1_Sample,V2_Sample;\n    float4 _tn;\n    float3 normal0,normal1,normal2;\n    float2 UV_Format = float2(Vformat.x,Vformat.y);\n\n\n    int2 P0 = int2(pos.x-1,pos.y-1);\n    int2 P1 = int2(pos.x+1,pos.y+1);\n    if (_plexConnectX && pos.x == int(Vformat.x))\{\n      insideX == true;\n      P1 = int2(0.0f,pos.y+1);\n    \}\n    if (_plexConnectY && pos.y == int(Vformat.y))\{\n      insideYtop == true;\n      P1 = int2(pos.x+1,0);\n    \} \n\n    if (_plexConnectY && pos.y == 0)\{\n      insideY == true;\n      P0 = int2(pos.x-1,int(UV_Format.y));\n    \} \n\n    if (!_flatshading) \{\n      _tn = normals(pos.x,pos.y);\n      V0_N =float3(_tn.x,_tn.y,_tn.z);\n    \}\n    V0_ST = float2(pos.x,pos.y)/UV_Format;\n\n  if (insideX) \{\n    V2_Sample = ppos(P1.x,pos.y);\n    V2_ST = float2(P1.x,pos.y)/UV_Format;\n    V2_wPos = float3(V2_Sample.x,V2_Sample.y,V2_Sample.z);\n    V2_Pos = Reconsile3D(V2_wPos);\n    if (!_flatshading) \{\n      _tn = normals(P1.x,pos.y);\n      V2_N =float3(_tn.x,_tn.y,_tn.z);\n    \}\n        \n\n    if (V2_Sample.w != 0.0f) \{ \n\n      if (insideY) \{\n        V1_Sample = ppos(P1.x,P0.y);\n        V1_ST = float2(P1.x,P0.y)/UV_Format;\n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (!_flatshading) \{\n          _tn = normals(P1.x,P0.y);\n          V1_N =float3(_tn.x,_tn.y,_tn.z);\n        \}\n        if (V1_Sample.w != 0.0f) \{ \n          DrawTriangle(screen_pos,V2_Pos,V1_Pos,_vWorld,V2_wPos,V1_wPos,V0_N,V2_N,V1_N,V0_ST,V2_ST,V1_ST);\n        \}\n      \}\n      if (insideYtop) \{\n        V1_Sample = ppos(pos.x,P1.y);\n        V1_ST = float2(pos.x,P1.y)/UV_Format;        \n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (!_flatshading) \{\n          _tn = normals(pos.x,P1.y);\n          V1_N =float3(_tn.x,_tn.y,_tn.z);\n        \}        \n        if (V1_Sample.w != 0.0f) \{ \n          DrawTriangle(screen_pos,V1_Pos,V2_Pos,_vWorld,V1_wPos,V2_wPos,V0_N,V1_N,V2_N,V0_ST,V1_ST,V2_ST);\n        \}\n      \}\n    \}\n  \}\n\}\n\n\n\n//This function will calculate if pixel C is inside the triangle\nfloat edgeFunction(float3 a, float3 b, float3 c) \n\{ \n    return ((c.x - a.x) * (b.y - a.y) - (c.y - a.y) * (b.x - a.x)); \n\} \n\nfloat3 CalculateSurfaceNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat3 CalculateVertexNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat Distance(float3 _a,float3 _b)\n\{\n          float xd = _a.x - _b.x;\n          float yd = _a.y - _b.y;\n          float zd = _a.z - _b.z;\n          return sqrt(xd*xd + yd*yd + zd*zd);\n\}\n\nvoid DrawTriangle(float3 V0, float3 V1, float3 V2,float3 WP0, float3 WP1, float3 WP2,float3 N0, float3 N1, float3 N2, float2 st0,float2 st1,float2 st2) \{\n\n  // Precompute reciprocal of vertex z-coordinate \n  V0.z = 1.0f / V0.z, V1.z = 1.0f / V1.z, V2.z = 1.0f / V2.z; \n\n  float2 st0n = st0 * V0.z;\n  float2 st1n = st1 * V1.z; \n  float2 st2n = st2 * V2.z; //Normal version of ST\n\n  bool inside; \n  float X0 = Fmin(V0.x,V1.x,V2.x)-1.0f;\n  float X1 = Fmax(V0.x,V1.x,V2.x)+1.0f;\n  float Y0 = Fmin(V0.y,V1.y,V2.y)-1.0f;\n  float Y1 = Fmax(V0.y,V1.y,V2.y)+1.0f;\n  float area = edgeFunction(V2, V1, V0);\n\n\n  float2 sampos = float2(st0.x*float(Vformat.x),st0.y*float(Vformat.y));\n  float4 text0 = src(sampos.x,sampos.y);\n  sampos = float2(st1.x*float(Vformat.x),st1.y*float(Vformat.y));\n  float4 text1 = src(sampos.x,sampos.y);\n  sampos = float2(st2.x*float(Vformat.x),st2.y*float(Vformat.y));  //Why do we have to do this? =(\n  float4 text2 = src(sampos.x,sampos.y);\n  sampos = float2(min(min(st0.x,st1.x),st2.x)*float(Vformat.x),min(min(st0.y,st1.y),st2.y)*float(Vformat.y));\n  float4 text3 = src(sampos.x,sampos.y);\n\n\n  for( int x = X0; x < X1 ; x++) \{\n    for( int y = Y0; y < Y1 ; y++) \{\n      float3 pixelSample(x + _texoffset.x, y + _texoffset.y,0.0f); \n\n      //This is the part where we test if the current pixel is inside the triangle\n      //We check both for front facing and back faing options\n      float w0 = edgeFunction(V1, V0, pixelSample); //Front Facing\n      float w1 = edgeFunction(V2, V1, pixelSample); \n      float w2 = edgeFunction(V0, V2, pixelSample); \n      float w3 = edgeFunction(V0, V1, pixelSample); //Back Facing\n      float w4 = edgeFunction(V1, V2, pixelSample); \n      float w5 = edgeFunction(V2, V0, pixelSample);\n\n      //writepixel(x,y, float4(w1),1,1.0f);\n      if ((w0 >= 0 && w1 >= 0 && w2 >= 0 && _frontfacing) || (w3 >= 0 && w4 >= 0 && w5 >= 0 && _backfacing)) \{ //The curent pixel is inside the triangle\n\n       // calculate vectors from point f to vertices p1, p2 and p3:\n       float3 f1 = V0-pixelSample;\n       float3 f2 = V1-pixelSample;\n       float3 f3 = V2-pixelSample;\n       // calculate the areas and factors (order of parameters doesn't matter):\n       float a = length(cross(V0-V1,V0-V2 )); // main triangle area a\n       area = length(V0-V1)+length(V0-V2)+length(V1-V2);\n\n        w0 /= area; \n        w1 /= area; \n        w2 /= area; \n\n        w3 /= area; \n        w4 /= area; \n        w5 /= area; \n\n       float a1 = length(cross(f2, f3)) / a; // p1's triangle area / a\n       float a2 = length(cross(f3, f1)) / a; // p2's triangle area / a \n       float a3 = length(cross(f1, f2)) / a; // p3's triangle area / a\n       float a_magnitude = a1+a2+a3;\n       a1 = a1/a_magnitude;\n       a2 = a2/a_magnitude;\n       a3 = a3/a_magnitude;\n       float z = 1.0f / (V0.z * a1 + V1.z * a2 + V2.z * a3); \n\n\n        // find the uv corresponding to point f (uv1/uv2/uv3 are associated to p1/p2/p3):\n        float2 uv = st0 * a1 + st1 * a2 + st2 * a3;\n        float2 st = st0 * w0 + st1 * w1 + st2 * w2; \n        st *= z;      \n\n\n        //Calculate normals. Eighter we have flat shading, else we calculate a normal per pixel\n        float3 normalB;\n        if (_flatshading) \{\n          normalB = CalculateSurfaceNormals(WP0,WP1,WP2);\n\n        \}\n        else \{\n          float3 c0 = N2/float3(V0.z); \n          float3 c1 = N0/float3(V1.z); \n          float3 c2 = N1/float3(V2.z);  \n\n          normalB.x = w0 * c0.x + w1 * c1.x + w2 * c2.x; \n          normalB.y = w0 * c0.y + w1 * c1.y + w2 * c2.y; \n          normalB.z = w0 * c0.z + w1 * c1.z + w2 * c2.z; \n\n          normalB.x *= z, normalB.y *= z, normalB.z *= z; \n        \}\n        normalB = normalize(normalB);\n\n        //CALCULATE THE OBJECT TEXTURE COORDINATES\n        float zn = 1.0f / (V0.z * w0 + V1.z * w1 + V2.z * w2); \n        st = st0n * w0 + st1n * w1 + st2n * w2; \n        st *= zn;   \n        //--END \n\n        float3 Wpos = WP0*a1 + WP1*a2 + WP2*a3; //World Position.\n        float3 ViewNormal = normalize(float3(cameraToWorld\[3]\[0],cameraToWorld\[3]\[1],cameraToWorld\[3]\[2])-Wpos);\n\n        float nDotView =  dot(normalB,ViewNormal);\n        nDotView = 1.0f-fabs(nDotView); //make sure that the view normal ramps back around when doing backface\n        float4 tempout;\n\n        //Flatshading or regular?\n        if (!_flatshading) \{\n          tempout = text0 * a1 + text1 * a2 + text2 * a3; \n        \}\n        else\{\n          tempout = text3;\n        \}\n\n        //Additional Render Modes\n        if (_vertexMode == 1)\{\n          tempout = float4(a1,a2,a3,1.0f);\n        \}\n        else if (_vertexMode == 2)\{\n          tempout = float4(normalB.x,normalB.y,normalB.z,1.0f);\n        \}\n        else if (_vertexMode == 3)\{\n          tempout = float4(nDotView,nDotView,nDotView,1.0f);\n        \}\n        else if (_vertexMode == 4)\{\n          tempout = float4(uv.x,uv.y,0.0f,1.0f);\n        \}       \n        else if (_vertexMode == 5)\{\n          tempout = float4(st.x,st.y,0.0f,1.0f);\n        \}               \n        else if (_vertexMode == 6)\{\n          tempout = float4(ViewNormal.x,ViewNormal.y,ViewNormal.z,1.0f);\n        \}             \n        else if (_vertexMode == 7)\{\n          tempout = float4(Wpos.x,Wpos.y,Wpos.z,1.0f);\n        \}   \n\n        if (_depthBuffer)\{\n          writepixel(x,y, float4(tempout.x,tempout.y,tempout.z,z),1,1.0f);  \n        \}\n        else \{\n          if (_dof_enable)\{\n            Bokeh(float3(x,y,z),float4(tempout.x,tempout.y,tempout.z,z));\n          \}\n          else \{\n            bilinear_Plot(float2(x,y),float4(tempout.x,tempout.y,tempout.z,z),1);\n          \}\n        \}\n\n      \}  \n\n    \}\n  \}\n\}\n\n//-------------------------------------\n// Wire_Render\n//-------------------------------------\nvoid wire_render(int2 pos) \{\n  float4 temp = float4(0.0f,0.0f,0.0f,FLT_MAX);\n  float4 wire_ref_sample;\n  int2 tempXY = int2(0,0);\n  float4 plexlist\[11] = \{temp,temp,temp,temp,temp,temp,temp,temp,temp,temp,temp\}; \n  int2 plexlistXY\[11] = \{tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY\};\n  int plex_count = 0; //We use this to figure how many points that should connect.\n  float plex_dist;\n  float3 plex_position,plex_position_b;\n  float4 temp_pos, temp_pos_b; //Temporary Position Containers\n  if (_maxPlexType == -1) \{ //Used for random connection types\n    for( int x = 0; x < max_line_connections ; x++)\{ //THIS 80 NUMBER IS THE LIMIT TO AVOID TOO SLOW PROCESSING!\n      for( int y = 0; y < max_line_connections ; y++)\{\n        wire_ref_sample = ppos(x,y);\n        if (wire_ref_sample.w != 0.0f && pos.x!=x && pos.y != y) \{ \n          plex_position = float3(wire_ref_sample.x,wire_ref_sample.y,wire_ref_sample.z)*(zoom);\n          float xd = plex_position.x - vWorld.x;\n          float yd = plex_position.y - vWorld.y;\n          float zd = plex_position.z - vWorld.z;\n          float plex_dist = sqrt(xd*xd + yd*yd + zd*zd);\n          if (plex_dist<_maxPlexDistance)\{\n            plex_count = min(10,plex_count+1); //Add one to the count\n            for( int h = 0; h < plex_count+1 ; h++) \{ //Loop thought all the points. If the distance is shorter then insert it into the array and push the rest of the array down\n              if (plex_dist < plexlist\[h].w) \{                  \n                for( int i = plex_count+1; i > h ; i--) \{\n                  plexlist\[i] = plexlist\[i-1];\n                  plexlistXY\[i] = plexlistXY\[i-1];\n                \}\n                plexlist\[h] = float4(plex_position.x,plex_position.y,plex_position.z,plex_dist);\n                plexlistXY\[h] = int2(x,y);\n                break;        \n              \}\n            \}\n          \} \n        \}\n      \}\n    \}\n  \}\n  else\{ //Used for standard connection types\n    float4 temp_pos;\n    bool insideX = !(Vformat.x < pos.x+1);\n    bool insideY = !(Vformat.y < pos.y+1);\n\n\n    if (!_plexLinedefAUX)\{\n      temp_pos = normals(pos.x,pos.y);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,vWorld+plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    if ( insideX && !_plexLinedefX) \{\n      temp_pos = ppos(pos.x+1,pos.y );\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && !_plexLinedefX) \{\n      temp_pos = ppos(0,pos.y);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    if ( insideY && !_plexLinedefY) \{\n      temp_pos = ppos(pos.x,pos.y+1);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\}                          \n    \}\n    else if ( _plexConnectY  && !_plexLinedefY) \{\n      temp_pos = ppos(pos.x,0);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    //_plexConnect\n    if ( insideX && insideY && !_plexLinedefXY) \{              \n      temp_pos = ppos(pos.x+1,pos.y+1);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && _plexConnectY && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && insideY && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectY && insideX && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n  \}   \n\n  //now that all the connections have been sorted by distance then we connect the dots.\n  for( int x = 0; x < min(_maxPlexConnections,plex_count) ; x++)\{\n    plex_position = float3(plexlist\[x].x,plexlist\[x].y,plexlist\[x].z);\n    plex_dist = plexlist\[x].w;\n\n\n    float plex_distribution = 1.0f-((plexlist\[x].w-plexlist\[0].w)/((plexlist\[min(_maxPlexConnections,plex_count)].w-plexlist\[0].w)+0.00001f)); //Where does it lie between the best and the worst distance?\n    //plexlistXY\n\n    float4 plex_col = float4(pow(1.0f-(plex_dist/_maxPlexDistance),1.0f/_plex_gamma))*float4(plex_distribution); //This one is quite cool aswell, but does leave the center ones a bit too focused \n    float4 plex_colorA = src(pos.x,pos.y);\n    float4 plex_colorB = src( plexlistXY\[x].x,plexlistXY\[x].y);\n    plex_col *= 0.1f;\n\n    computePixelCoordinates(plex_position, pRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1]);\n    if (dst.bounds.inside(int(vRaster.x),int(vRaster.y)) || dst.bounds.inside(int(pRaster.x),int(pRaster.y)))\{\n        DrawLine(vRaster,pRaster,(plex_colorA*plex_col)*_lineInMultiplier,(plex_colorB*plex_col)*_lineOutMultiplier);\n    \}\n  \}\n\}\n\nvoid wire_connection(float3 p_source,float3 p_target, float4 (&p_plexlist)\[11], int2 (&p_plexlistXY)\[11],int &p_plexcount,int2 position) \{\n  float xd = p_target.x - p_source.x;\n  float yd = p_target.y - p_source.y;\n  float zd = p_target.z - p_source.z;\n  float plex_dist = sqrt(xd*xd + yd*yd + zd*zd);\n  if (plex_dist<_maxPlexDistance)\{\n    p_plexcount = min(11,p_plexcount+1); //Add one to the count\n    for( int h = 0; h < p_plexcount+1 ; h++) \{ //Loop thought all the points. If the distance is shorter then insert it into the array and push the rest of the array down\n      if (plex_dist < p_plexlist\[h].w) \{                  \n        for( int i = p_plexcount+1; i > h ; i--) \{\n          p_plexlist\[i] = p_plexlist\[i-1];\n          p_plexlistXY\[i] = p_plexlistXY\[i-1];\n        \}\n        p_plexlist\[h] = float4(p_target.x,p_target.y,p_target.z,plex_dist);\n        p_plexlistXY\[h] = int2(position.x,position.y);\n        break;        \n      \}\n    \}  \n  \}\n\}\n//-------END OF WIRE RENDER FUNCTIONS---------\n\n\n\n\n//-------------------------------\n//-------BOKEH FUNCTIONS---------\n//thanks to: http://devlog-martinsh.blogspot.dk/2011/11/glsl-depth-of-field-with-bokeh-v21.html\nfloat2 rand(float2 coord) //generating noise/pattern texture for dithering\n\{\n  float noiseX = ((Frac(1.0-coord.x*(WHformat\[0]/2.0))*0.25)+(Frac(coord.y*(WHformat\[1]/2.0))*0.75))*2.0-1.0;\n  float noiseY = ((Frac(1.0-coord.x*(WHformat\[0]/2.0))*0.75)+(Frac(coord.y*(WHformat\[1]/2.0))*0.25))*2.0-1.0;\n  noiseX = clamp(Frac(sin(dot(coord ,float2(12.9898f,78.233f))) * 43758.5453f),0.0f,1.0f)*2.0f-1.0f;\n  noiseY = clamp(Frac(sin(dot(coord ,float2(12.9898f,78.233f)*2.0f)) * 43758.5453f),0.0f,1.0f)*2.0-1.0f;\n  return float2(noiseX,noiseY);\n\}\n//-------------------------------------\n// Bokeh\n//-------------------------------------\nvoid Bokeh(float3 pos,float4 color)\{\n  float blur = 0.0;\n  blur = clamp((fabs(pos.z - focalDepth)/_depthOfField)*100.0f,-_maxDofSize,_maxDofSize);\n  \n  float w = (1.0/WHformat.x)*blur;//+noise.x;\n  float h = (1.0/(WHformat.x*dof_aspect))*blur;//+noise.y;\n  float3 v3_col = float3(color.x,color.y,color.z);\n  int ringsamples;\n  float s = 1.0;  \n\n  for (int i = 1; i <= _dof_rings; i += 1)\n  \{   \n    ringsamples = i * _dof_samples; \n    for (int j = 0 ; j < ringsamples ; j += 1)  \n    \{ \n      s += (1.0f*mix(1.0f,(float(i))/(float(_dof_rings)),dof_bias)*1.0f); //No need to do this in the loop\n    \}\n  \}\n\n  for (int i = 1; i <= _dof_rings; i += 1)\n  \{   \n    ringsamples = i * _dof_samples;\n     \n    for (int j = 0 ; j < ringsamples ; j += 1)   \n    \{\n      float step = PI*2.0 / float(ringsamples);\n      float pw = (cos(float(j)*step)*(float(i)/_dof_rings));\n      float ph = (sin(float(j)*step)*(float(i)/_dof_rings));\n      float p = 1.0;\n\n      float posx = pos.x+((pw*w)*blur);\n      float posy = pos.y+((ph*h)*blur);\n\n\n      float3 lumcoeff = float3(0.299,0.587,0.114);\n      float lum = dot(v3_col, lumcoeff);\n      float thresh = max((lum-dof_threshold)*dof_gain, 0.0f);\n      v3_col+mix(float3(0.0),v3_col,thresh*blur);\n\n      float3 col = (v3_col*mix(1.0,(float(i))/(float(_dof_rings)),dof_bias)*p)/s; \n      bilinear_Plot(float2(posx,posy),float4(col.x,col.y,col.z,color.w/(_dof_rings*_dof_rings)),1);\n    \}\n  \}\n\}\n//-------END OF BOKEH FUNCTIONS---------\n\n\n\n//-------------------------------------\n// Process\n//-------------------------------------\n  void process(int2 pos) \{\n    float4 _sample = ppos(pos.x,pos.y); //Get the XYZ Coordinates\n    float2 posf = float2(pos.x,pos.y);\n\n    if (_sample.w != 0.0f) \{  //No need to process if there is no data.\n\n      //Convert worldspace coordinates to screenspcace coordinates.\n      vWorld = float3(_sample.x,_sample.y,_sample.z)*(zoom);\n      int ret = computePixelCoordinates(vWorld, vRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1]);\n      if (ret) \{ //Only create points that are visible on screen\n        if (_pointRender)\{\n          point_render(pos,vRaster);\n        \}\n      \} //Pointrender over\n\n      if (_wireRender && _maxPlexConnections>=1) \{\n        if (max(pos.x,pos.y)<=max_line_connections || (_maxPlexType==0))\{ // Don't process more wires than allowed in nearest mode.\n          wire_render(pos);\n        \}\n      \} //WireRender over\n\n      if (_facetRender) \{\n        facet_render(pos,float3(_sample.x,_sample.y,_sample.z));\n      \}  //FacetRender over\n      \n    \}\n  \} //----> process\n\};\n"
  useGPUIfAvailable false
  rebuild ""
  PointRender3D_cam_Matrix {
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
    }
  PointRender3D_focallength {{parent.Camera1.focal}}
  PointRender3D_hapeture {{parent.Camera1.haperture}}
  PointRender3D_format {{Settings_Format.width} {Settings_Format.height}}
  PointRender3D_vertexformat {{parent.InputFormat.box.r-1} {parent.InputFormat.box.t-1}}
  PointRender3D__alphaMultiplier {{parent.AlphaMultiplier}}
  PointRender3D__pointRender {{parent.RenderMode==0}}
  PointRender3D__wireRender {{parent.RenderMode==1}}
  PointRender3D__facetRender {{parent.RenderMode==2}}
  PointRender3D__maxLDistance {{parent.wire_maxdistance}}
  PointRender3D__maxLConnections {{parent.wire_connections}}
  PointRender3D__maxPlexType {{-parent.wire_type}}
  PointRender3D__plexLinedefXY {{!parent.connect_xy}}
  PointRender3D__plexLinedefX {{!parent.connect_x}}
  PointRender3D__plexLinedefY {{!parent.connect_y}}
  PointRender3D__plexLinedefAUX {{!connect_aux}}
  PointRender3D__plexConnectX {{parent.CloseX}}
  PointRender3D__plexConnectY {{parent.CloseY}}
  PointRender3D__L_gamma {{parent.wire_Threshold}}
  "PointRender3D_Enable Depth of Field" {{parent.dof_enable}}
  PointRender3D_samples {{3*(parent.Dof_Quality*parent.Dof_Quality+1)}}
  PointRender3D_rings {{3*(parent.Dof_Quality*parent.Dof_Quality+1)}}
  PointRender3D_focalDepth {{parent.dof_focaldepth}}
  PointRender3D__depthOfField {{parent.dof_dof}}
  PointRender3D__depthMult {{parent.DofMultiplier}}
  PointRender3D__maxDofSize {{parent.dof_maxSize*400}}
  PointRender3D_dof_aspect {{parent.dof_Aspect}}
  PointRender3D_dof_bias {{parent.dof_bias}}
  PointRender3D__flatshading {{parent.facet_flatShading}}
  PointRender3D__backfacing {{parent.facet_backface}}
  PointRender3D__frontfacing {{parent.facet_front}}
  PointRender3D__vertexMode {{parent.renderMode}}
  PointRender3D__depthBuffer {{parent.facet_depth}}
  PointRender3D__texoffset {-0.5 0.5}
  PointRender3D__pointSize 0
  PointRender3D__depthOcclusion {{parent.UseOcclusionMap}}
  PointRender3D__maxLineSteps {{parent.maxSamples}}
  PointRender3D__lineOffset {{parent.lineoffset}}
  PointRender3D__lineInMultiplier {{parent.inGain}}
  PointRender3D__lineOutMultiplier {{parent.outGain}}
  format "1280 720 0 0 1280 720 1 HD_720"
  rebuild_finalise ""
  name BlinkScript1
  selected true
  xpos -27
  ypos 159
 }
 Reformat {
  format {{{Settings_Format.format}}}
  resize none
  center false
  name Reformat1
  xpos -27
  ypos 343
 }
 Group {
  name SoftLook
  xpos -27
  ypos 460
  disable {{!parent.HighlightCompression}}
  addUserKnob {20 User}
  addUserKnob {26 ""}
  addUserKnob {7 Add R 0 4}
  Add {{parent.HighlightCeiling}}
  addUserKnob {7 Offset R 0 4}
  Offset {{parent.Compression}}
 }
  Input {
   inputs 0
   name Input1
   xpos -248
   ypos 500
  }
set N54f85cc0 [stack 0]
  Expression {
   expr0 r/(r+parent.Offset)*parent.Add
   expr1 g/(g+parent.Offset)*parent.Add
   expr2 b/(b+parent.Offset)*parent.Add
   expr3 a/(a+parent.Offset)*parent.Add
   name Expression1
   xpos -339
   ypos 576
  }
push $N54f85cc0
  ShuffleCopy {
   inputs 2
   red red
   green green
   blue blue
   alpha alpha2
   name ShuffleCopy1
   xpos -248
   ypos 576
  }
  Output {
   name Output1
   xpos -248
   ypos 651
  }
 end_group
 TimeBlur {
  divisions {{parent.Samples}}
  shutter {{parent.Shutter}}
  shutteroffset centred
  shuttercustomoffset 0
  name MotionBlur
  xpos -27
  ypos 581
  disable {{1-parent.mb_enable x89 0}}
 }
 ShuffleCopy {
  inputs 2
  in pos
  red red
  green green
  blue blue
  out pos
  name ShuffleCopy1
  xpos -27
  ypos 673
  disable true
 }
 Output {
  name Output1
  xpos -27
  ypos 710
 }
 Input {
  inputs 0
  name InputCamera
  xpos -1129
  ypos 116
  number 1
 }
 Camera2 {
  focal {{parent.FocalLength}}
  haperture {{parent.horizontalApeture}}
  name Camera1
  xpos -1119
  ypos 223
  addUserKnob {20 Ivy}
  addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.toolbox.v1.nodes.docs', fromlist=\['open_docs_name']).open_docs_name('IvyTab')" +STARTLINE}
  addUserKnob {26 divider4 l "" +STARTLINE}
  addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
  _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
  addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
  addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
  addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
  _expressions {{curve}}
  addUserKnob {26 divider0 l "" +STARTLINE}
  addUserKnob {20 dbinfo l "DB Info" n 1}
  dbinfo 0
  addUserKnob {1 twig_dnuuid l "Twig Id"}
  addUserKnob {1 stalk_dnuuid l "Stalk Id"}
  addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
  addUserKnob {1 leaf_dnuuid l "Leaf Id"}
  addUserKnob {26 divider1 l "" +STARTLINE}
  addUserKnob {1 twigtype l "Twig Type"}
  addUserKnob {1 leaf_label l Leaf}
  addUserKnob {1 ivy_version l Version}
  addUserKnob {43 ivy_notes l Notes}
  addUserKnob {26 divider2 l "" +STARTLINE}
  addUserKnob {1 build_label l "Build Label"}
  addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
 }
 Reformat {
  inputs 0
  format "2156 1806 0 0 2156 1806 2 JOYRIDE Working"
  resize none
  center false
  name Settings_Format
  xpos -1404
  ypos 241
 }
push $N54f4b610
 PositionToPoints2 {
  display textured
  render_mode textured
  P_channel pos
  detail 0.25
  pointSize 0.6
  name PreviewNode
  xpos -22
  ypos 8
  disable {{!parent.Enable3DPreview}}
 }
push $N551e4060
 Reformat {
  type "to box"
  box_width 100
  box_height 100
  box_fixed true
  scale 0.1
  resize none
  filter impulse
  black_outside true
  name Reformat3
  xpos -633
  ypos -1109
  disable {{!wire_type==1}}
 }
push $N550251a0
 Crop {
  box {0 0 {width} {height}}
  reformat true
  crop false
  name InputFormat
  xpos -456
  ypos -402
 }
end_group
TimeOffset {
 time_offset -1182
 time ""
 name TimeOffset2
 selected true
 xpos 10083
 ypos 32680
}
Dot {
 name Dot297
 selected true
 xpos 10117
 ypos 32962
}
FileOut {
 name FileOut12
 tile_color 0xbfbf00ff
 label 2DparticleFX_2
 selected true
 xpos 10083
 ypos 33010
 icon smartgrade.png
 channels rgba
 _destination /jobs
 _stemstatus ""
 file ""
 proxy ""
 fileProxy ""
 views {main}
 first 1001
 last 1400
 pbb true
 smart_grade on
 dw_compression_level 0
 tex_metadata "default metadata and exr/*"
 disable_autolabel_format true
 _defaults "\{'smart_grade': 0, 'compression': 1, 'tile_color': 3216965887, 'pbb': True, 'dw_compression_level': 0, 'label': u'2DparticleFX_2', 'exr_metadata': 2\}"
 _format ""
 _generator "NukeRenderGenerator dnnuke.core.render.v1"
 _ivyVals "\{'variant': None, 'host': None, 'versionNum': '3', 'twigType': 'spider://query@TwigType.one?TwigType.code==2d', 'twigNameTags': \{'subtask': u'precomp', 'task': u'comp', 'label': u'2DparticleFX_2', 'out_dir': u'ELEMENT'\}, 'job': 'STONE', 'stalk': None, 'stalkAttrs': \{'framerange': '1017-1053'\}, 'twig': None, 'stem': 'spider://query@Stem.one?Stem.dnuuid==cfb45239-1375-4623-b0a4-12b2a5fba3d0&Stem.stemname==110_fof_0010&Stem.stemtype==shot'\}"
 _old_filetype exr
 _stalkname E_110_fof_0010_comp_precomp_2DparticleFX_2_v003
 _twigtype 2d
 _wrapper "FileOut dnnuke.nodes.file_out.wrapper"
 beforeRender ""
 beforeFrameRender ""
 afterFrameRender ""
 afterRender ""
 renderProgress ""
 _invert_grade /tools/STONE/ivyasset/110_fof_0010/ivy/grade/GRD_110_fof_0010_neutral_v001/GRD_110_fof_0010_neutral_v001.grade
}
BagAndTagKeep {
 name BagAndTagKeep3
 selected true
 xpos 10083
 ypos 33122
}
Read {
 inputs 0
 file_type exr
 file /jobs/JOYRIDE/hap0850/ELEMENT/E_hap0850_comp_precomp_2DparticleFX_2_v003/2156x1806/E_hap0850_comp_precomp_2DparticleFX_2_v003.####.exr
 localizationPolicy off
 format "2156 1806 0 0 2156 1806 2 JOYRIDE Working"
 proxy_format "640 480 0 0 640 480 1 PC_Video"
 first 1001
 last 1400
 origfirst 1001
 origlast 1400
 origset true
 smartGrade true
 name Read192
 selected true
 xpos 10090
 ypos 33213
 postage_stamp_frame 1200
 addUserKnob {20 Ivy}
 addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.toolbox.v1.nodes.docs', fromlist=\['open_docs_name']).open_docs_name('IvyTab')" +STARTLINE}
 addUserKnob {26 divider4 l "" +STARTLINE}
 addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
 _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
 addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
 addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
 _ivyFile /jobs/JOYRIDE/hap0850/ELEMENT/E_hap0850_comp_precomp_2DparticleFX_2_v003/2156x1806/E_hap0850_comp_precomp_2DparticleFX_2_v003.####.exr
 addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
 _expressions {{curve}}
 addUserKnob {26 divider0 l "" +STARTLINE}
 addUserKnob {20 dbinfo l "DB Info" n 1}
 dbinfo 0
 addUserKnob {1 twig_dnuuid l "Twig Id"}
 twig_dnuuid 776d86dd-5bde-4453-9885-d4e475541d96
 addUserKnob {1 stalk_dnuuid l "Stalk Id"}
 stalk_dnuuid c5999af3-68a2-4d10-9b51-0013934c02c6
 addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
 twigtype_dnuuid e9f824fa-c932-4c3e-acbd-c612fb5ea846
 addUserKnob {1 leaf_dnuuid l "Leaf Id"}
 leaf_dnuuid bdbf5872-f813-453c-bb94-28a817852a06
 addUserKnob {26 divider1 l "" +STARTLINE}
 addUserKnob {1 twigtype l "Twig Type"}
 twigtype elmr
 addUserKnob {1 leaf_label l Leaf}
 leaf_label main_proxy0
 addUserKnob {1 ivy_version l Version}
 ivy_version 3
 addUserKnob {43 ivy_notes l Notes}
 addUserKnob {26 divider2 l "" +STARTLINE}
 addUserKnob {1 build_label l "Build Label"}
 addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
}
BagAndTagKeep {
 name BagAndTagKeep4
 selected true
 xpos 10090
 ypos 33366
}
push $cut_paste_input
Camera2 {
 translate {5 0.1 0.07756583}
 rotate {0 87.69209641 0}
 name Camera6
 selected true
 xpos 11271
 ypos 32602
 addUserKnob {20 Ivy}
 addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.toolbox.v1.nodes.docs', fromlist=\['open_docs_name']).open_docs_name('IvyTab')" +STARTLINE}
 addUserKnob {26 divider4 l "" +STARTLINE}
 addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
 _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
 addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
 addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
 addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
 _expressions {{curve}}
 addUserKnob {26 divider0 l "" +STARTLINE}
 addUserKnob {20 dbinfo l "DB Info" n 1}
 dbinfo 0
 addUserKnob {1 twig_dnuuid l "Twig Id"}
 addUserKnob {1 stalk_dnuuid l "Stalk Id"}
 addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
 addUserKnob {1 leaf_dnuuid l "Leaf Id"}
 addUserKnob {26 divider1 l "" +STARTLINE}
 addUserKnob {1 twigtype l "Twig Type"}
 addUserKnob {1 leaf_label l Leaf}
 addUserKnob {1 ivy_version l Version}
 addUserKnob {43 ivy_notes l Notes}
 addUserKnob {26 divider2 l "" +STARTLINE}
 addUserKnob {1 build_label l "Build Label"}
 addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
}
Group {
 inputs 0
 name Point_Grid3
 tile_color 0x434343ff
 note_font_color 0x7dadf9ff
 selected true
 xpos 11241
 ypos 32107
 addUserKnob {20 User}
 addUserKnob {26 text l "" +STARTLINE T "Point Grid v1.0\n\nThis node generates a grid.\nAs it is defined in a non-euclidian space, \nmost of the shaders and wire or facet rendering won't work. "}
 addUserKnob {26 ""}
 addUserKnob {41 size_x l "Number of Points" T CONTROLER.size_x}
 addUserKnob {41 size_y l "" -STARTLINE T CONTROLER.size_y}
 addUserKnob {41 size_z l "" -STARTLINE T CONTROLER.size_z}
 addUserKnob {18 Position}
 Position {0 0 0}
 addUserKnob {6 Position_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Position_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Position_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {18 Scale}
 Scale {3 5 3}
 addUserKnob {6 Scale_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Scale_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Scale_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
}
 NoOp {
  inputs 0
  name CONTROLER
  xpos 224
  ypos -62
  addUserKnob {20 User}
  addUserKnob {3 VoxelDensity}
  VoxelDensity {{ceil(pow(size_x*size_y*size_z,1/3))}}
  addUserKnob {3 size_x l "Voxel Grid Size"}
  size_x 140
  addUserKnob {3 size_y l "" -STARTLINE}
  size_y 100
  addUserKnob {3 size_z l "" -STARTLINE}
  size_z 130
 }
 Crop {
  inputs 0
  box {0 0 {ceil(sqrt(pow(parent.CONTROLER.VoxelDensity,3)))} {sqrt(pow(parent.CONTROLER.VoxelDensity,3))}}
  reformat true
  crop false
  name Crop3
  xpos 372
  ypos -108
 }
 BlinkScript {
  recompileCount 9
  ProgramGroup 1
  KernelDescription "2 \"InvertKernel\" iterate pixelWise 21048e0522d3524e03cb582229852f2e33dbe569cd86686b92f460148f8700cf 2 \"src\" Read Point \"dst\" Write Point 1 \"Cube Size\" Int 3 IAAAACAAAAAgAAAAAAAAAA== 1 \"cube_size\" 3 1 0"
  kernelSource "kernel InvertKernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;  \n  Image<eWrite> dst;\n\n  param:\n    int3 cube_size;\n\n  local:\n    \n\n  void define() \{\n    defineParam(cube_size, \"Cube Size\", int3(32,32,32));\n  \}\n\n  void init() \{\n    \n  \}\n\n  void process(int2 pos) \{\n    int t_offset = (pos.x+(pos.y*src.bounds.width()));\n    float4 position;\n    float maxSize = max(max(cube_size.x,cube_size.y),cube_size.z);\n\n    position.x = fmod(t_offset,cube_size.x)/float(cube_size.x-1);\n    position.y = fmod(int(t_offset/cube_size.x),cube_size.y)/float(cube_size.y-1);\n    position.z = fmod(int(t_offset/(cube_size.x*cube_size.y)),cube_size.z)/float(cube_size.z-1);\n    position.w = 1-min(fmod(int(t_offset/(cube_size.x*cube_size.y*cube_size.z)),maxSize),1.0f);\n\n    dst() = float4(position.x*position.w,position.y*position.w,position.z*position.w,position.w);\n   \}\n\};\n\n"
  rebuild ""
  "InvertKernel_Cube Size" {{parent.CONTROLER.size_x} {parent.CONTROLER.size_y} {parent.CONTROLER.size_z}}
  rebuild_finalise ""
  name BlinkScript8
  selected true
  xpos 372
  ypos -79
 }
 Grade {
  add -0.5
  black_clamp false
  name Grade1
  xpos 372
  ypos -47
 }
 Grade {
  white {{parent.Scale.r} {parent.Scale.g} {parent.Scale.b} 0.9}
  add {{parent.Position.r} {parent.Position.g} {parent.Position.b} 0}
  black_clamp false
  name Grade2
  xpos 372
  ypos -26
 }
 Shuffle {
  red white
  green white
  blue white
  black red
  white green
  red2 blue
  green2 alpha
  out2 pos
  name Shuffle1
  xpos 372
  ypos -2
 }
 ModifyMetaData {
  metadata {
   {set pointrender/n_points "\[expr \[value parent.size_x]*\[value parent.size_y] *\[value parent.size_z]]"}
   {set pointrender/gen_type 3}
  }
  name SetMetaData
  xpos 372
  ypos 22
 }
 Grade {
  white {{1/((parent.size_x*parent.size_y*parent.size_z)/200000)}}
  black_clamp false
  name Grade9
  xpos 372
  ypos 46
 }
 Crop {
  box {0 0 {ceil(sqrt(pow(parent.CONTROLER.VoxelDensity,3)))} {sqrt(pow(parent.CONTROLER.VoxelDensity,3))}}
  crop false
  name Crop1
  xpos 372
  ypos 70
 }
 Output {
  name Output1
  xpos 372
  ypos 149
 }
end_group
Group {
 name Fractal7
 tile_color 0x434343ff
 note_font_color 0x7dadf9ff
 selected true
 xpos 11241
 ypos 32177
 addUserKnob {20 User t test}
 addUserKnob {26 _1 l "" +STARTLINE T "Point Fractal 1.0\n"}
 addUserKnob {26 devider_noise l "<b><font color=#7DADF9>Noise Settings</font><b>"}
 addUserKnob {6 Noise_Absolute l Absolute t "Negative values in the noise offset is made positive." +STARTLINE}
 addUserKnob {3 Noise_Octaves l Octaves}
 Noise_Octaves 5
 addUserKnob {7 Noise_Gain l Gain}
 Noise_Gain 0.3
 addUserKnob {7 Noise_Lacunarity l Lacunarity R 0 4}
 Noise_Lacunarity 0.5
 addUserKnob {18 Amplitude}
 Amplitude 1.3
 addUserKnob {6 Amplitude_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Amplitude_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Amplitude_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Amplitude_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {3 Itterations}
 Itterations 5
 addUserKnob {26 invis_devider_noise l "" +STARTLINE T " "}
 addUserKnob {26 Devider_Frequency l "<b><font color=#7DADF9>Freq Control</font><b>"}
 addUserKnob {19 Freq_Offset l "General Offset" t "This is like a 3D translation, letting you move the current noise pattern in the X, Y, Z and W (4th dimention)" R 0 10}
 Freq_Offset {0 0 0 0}
 addUserKnob {6 Freq_Offset_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_Offset_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_Offset_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_Offset_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_Offset_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 Freq_GeneralScale l "Genral Scale" t "This lets you control the scale of each individual noise axis."}
 Freq_GeneralScale {1.1 1.1 1.1 1.2}
 addUserKnob {6 Freq_GeneralScale_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_GeneralScale_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_GeneralScale_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_GeneralScale_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_GeneralScale_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {26 invis_devider_freq l "" +STARTLINE T " "}
 addUserKnob {19 Freq_EvolveLow l "Evolve Low" t "This lets you evolve (auto animate) the noise in a particular direction. The \"Low\" part means that this only affects the low frequencies.\n\nTo avoid a \"scrolling\" effect you can use the 4th dimention to break up the spatial cohearence." R 0 10}
 Freq_EvolveLow {2 0 0 0.5}
 addUserKnob {6 Freq_EvolveLow_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveLow_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveLow_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveLow_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveLow_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleLow_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 Freq_EvolveHigh l "Evolve High" t "This lets you evolve (auto animate) the noise in a particular direction. The \"High\" part means that this only affects the high frequencies.\n\nTo avoid a \"scrolling\" effect you can use the 4th dimention to break up the spatial cohearence."}
 Freq_EvolveHigh {0.9 0 -1 1}
 addUserKnob {6 Freq_EvolveHigh_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveHigh_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveHigh_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveHigh_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveHigh_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {26 invis_devider_freq2 l "" +STARTLINE T " "}
 addUserKnob {19 Freq_ScaleLow l "Scale Low" t "This lets you scale the noise in a particular axis. The \"Low\" part means that this only affects the low frequencies."}
 Freq_ScaleLow {1.7 1.7 1.7 2}
 addUserKnob {6 Freq_ScaleLow_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleLow_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleLow_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleLow_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleLow_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 Freq_ScaleHigh l "Scale High" t "This lets you scale the noise in a particular axis. The \"High\" part means that this only affects the high frequencies."}
 Freq_ScaleHigh {3 3 3 3}
 addUserKnob {6 Freq_ScaleHigh_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleHigh_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleHigh_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleHigh_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleHigh_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {26 invis_devider_freq3 l "" +STARTLINE T " "}
 addUserKnob {26 Curve l "<b><font color=#7DADF9>Curve Noise</font><b>"}
 addUserKnob {6 CurveNoise_Enable l Enable t "Adds a gamma curve to the noise intensity making noise near the \"Offset\" value more flat. This is a experimental feature." +STARTLINE}
 addUserKnob {6 CurveNoise_Invert l Invert t "Inverts the effect of the curved noise." -STARTLINE}
 addUserKnob {7 CurveGain l "Curve Gain" R -10 10}
 CurveGain 2
 addUserKnob {7 CurveOffset R -2 2}
 addUserKnob {26 gabgen l "" +STARTLINE T "\n"}
 addUserKnob {26 info_mask l "<b><font color=#7DADF9>Mask</font><b>"}
 addUserKnob {41 maskChannelMask l "" t "If a node is connected to the mask input, this will let you mask off the effect of the noise.\nIts recommended that you use the Point_Texture node to ensure a correct aspect and size." -STARTLINE T Merge1.maskChannelMask}
 addUserKnob {41 inject -STARTLINE T Merge1.inject}
 addUserKnob {41 invert_mask l invert -STARTLINE T Merge1.invert_mask}
 addUserKnob {41 fringe -STARTLINE T Merge1.fringe}
 addUserKnob {41 mix T Merge1.mix}
}
 Input {
  inputs 0
  name InputMask
  xpos -714
  ypos 207
  number 1
 }
 Reformat {
  type "to box"
  box_width {{parent.InputFormat.box.r}}
  box_height {{parent.InputFormat.box.t}}
  box_fixed true
  resize distort
  name Reformat2
  xpos -714
  ypos 306
 }
 Shuffle {
  name Shuffle3
  xpos -714
  ypos 330
 }
 Input {
  inputs 0
  name InputData
  xpos -582
  ypos 73
 }
 Dot {
  name Dot1
  xpos -548
  ypos 114
 }
set N53f320c0 [stack 0]
 Shuffle {
  in pos
  name Shuffle1
  xpos -470
  ypos 110
 }
 BlinkScript {
  kernelSourceFile /Users/madshagbarth/Github/Nuke-Private/Blink/PointRender/Modify/Fractal_v06.cpp
  recompileCount 60
  ProgramGroup 1
  KernelDescription "2 \"Noise4D\" iterate pixelWise d54284af3e5573ad197bef9032773e8653de2cad590694fcc9fd5af993e97da3 2 \"src\" Read Point \"dst\" Write Point 17 \"absNoise\" Bool 1 AA== \"curveNoise\" Bool 1 AA== \"curveInvert\" Bool 1 AA== \"curveGain\" Float 1 AACAPw== \"curveOffset\" Float 1 AACAPw== \"Octaves\" Int 1 CgAAAA== \"Gain\" Float 1 AAAAPw== \"Lacunarity\" Float 1 AAAAQA== \"Gamma\" Float 1 AAAAPw== \"amplitude\" Float 3 AAAAPwAAAD8AAAA/AAAAAA== \"itterations\" Int 1 AQAAAA== \"Offset\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"Scale\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"suboffset\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"topoffset\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"subscale\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"topscale\" Float 4 AACAPwAAgD8AAIA/AACAPw== 17 \"absNoise\" 1 1 \"curveNoise\" 1 1 \"curveInvert\" 1 1 \"curveGain\" 1 1 \"curveOffset\" 1 1 \"octaves\" 1 1 \"gain\" 1 1 \"lacunarity\" 1 1 \"gamma\" 1 1 \"amplitude\" 3 1 \"itterations\" 1 1 \"offset\" 4 1 \"scale\" 4 1 \"suboffset\" 4 1 \"topoffset\" 4 1 \"subscale\" 4 1 \"topscale\" 4 1 0"
  kernelSource "//Based on https://github.com/Draradech/csworldgen/blob/master/simplexnoise.cpp\n//Ported by Mads Hagbarth Lund 2014\n\n/* Copyright (c) 2007-2012 Eliot Eshelman\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n\nint fastfloor( const float x ) \{ return x > 0 ? (int) x : (int) x - 1; \}\ninline float raw_noise_4d( const float x, const float y, const float z, const float w ) \n\{\nint simplex\[64]\[4] = \{\n    \{0,1,2,3\},\{0,1,3,2\},\{0,0,0,0\},\{0,2,3,1\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{1,2,3,0\},\n    \{0,2,1,3\},\{0,0,0,0\},\{0,3,1,2\},\{0,3,2,1\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{1,3,2,0\},\n    \{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\n    \{1,2,0,3\},\{0,0,0,0\},\{1,3,0,2\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{2,3,0,1\},\{2,3,1,0\},\n    \{1,0,2,3\},\{1,0,3,2\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{2,0,3,1\},\{0,0,0,0\},\{2,1,3,0\},\n    \{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\n    \{2,0,1,3\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{3,0,1,2\},\{3,0,2,1\},\{0,0,0,0\},\{3,1,2,0\},\n    \{2,1,0,3\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{3,1,0,2\},\{0,0,0,0\},\{3,2,0,1\},\{3,2,1,0\}\n\};\n    int perm\[512] = \{\n        151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,\n        8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,\n        35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,\n        134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,\n        55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208, 89,\n        18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,\n        250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,\n        189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,\n        172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,\n        228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,\n        107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,\n        138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180,\n\n        151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,\n        8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,\n        35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,\n        134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,\n        55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208, 89,\n        18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,\n        250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,\n        189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,\n        172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,\n        228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,\n        107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,\n        138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180\n    \};\n   int grad4\[32]\[4]= \{\n    \{0,1,1,1\},  \{0,1,1,-1\},  \{0,1,-1,1\},  \{0,1,-1,-1\},\n    \{0,-1,1,1\}, \{0,-1,1,-1\}, \{0,-1,-1,1\}, \{0,-1,-1,-1\},\n    \{1,0,1,1\},  \{1,0,1,-1\},  \{1,0,-1,1\},  \{1,0,-1,-1\},\n    \{-1,0,1,1\}, \{-1,0,1,-1\}, \{-1,0,-1,1\}, \{-1,0,-1,-1\},\n    \{1,1,0,1\},  \{1,1,0,-1\},  \{1,-1,0,1\},  \{1,-1,0,-1\},\n    \{-1,1,0,1\}, \{-1,1,0,-1\}, \{-1,-1,0,1\}, \{-1,-1,0,-1\},\n    \{1,1,1,0\},  \{1,1,-1,0\},  \{1,-1,1,0\},  \{1,-1,-1,0\},\n    \{-1,1,1,0\}, \{-1,1,-1,0\}, \{-1,-1,1,0\}, \{-1,-1,-1,0\}\n   \};\n    float F4 = (sqrt(5.0f)-1.0f)/4.0f;\n    float G4 = (5.0f-sqrt(5.0f))/20.0f;\n    float n0, n1, n2, n3, n4;\n    float s = (x + y + z + w) * F4;\n    int i = fastfloor(x + s);\n    int j = fastfloor(y + s);\n    int k = fastfloor(z + s);\n    int l = fastfloor(w + s);\n    float t = (i + j + k + l) * G4;\n    float X0 = i - t;\n    float Y0 = j - t;\n    float Z0 = k - t;\n    float W0 = l - t;\n\n    float x0 = x - X0;\n    float y0 = y - Y0;\n    float z0 = z - Z0;\n    float w0 = w - W0;\n    int c1 = (x0 > y0) ? 32 : 0;\n    int c2 = (x0 > z0) ? 16 : 0;\n    int c3 = (y0 > z0) ? 8 : 0;\n    int c4 = (x0 > w0) ? 4 : 0;\n    int c5 = (y0 > w0) ? 2 : 0;\n    int c6 = (z0 > w0) ? 1 : 0;\n    int c = c1 + c2 + c3 + c4 + c5 + c6;\n\n    int i1, j1, k1, l1;\n    int i2, j2, k2, l2;\n    int i3, j3, k3, l3;\n    i1 = simplex\[c]\[0]>=3 ? 1 : 0;\n    j1 = simplex\[c]\[1]>=3 ? 1 : 0;\n    k1 = simplex\[c]\[2]>=3 ? 1 : 0;\n    l1 = simplex\[c]\[3]>=3 ? 1 : 0;\n    i2 = simplex\[c]\[0]>=2 ? 1 : 0;\n    j2 = simplex\[c]\[1]>=2 ? 1 : 0;\n    k2 = simplex\[c]\[2]>=2 ? 1 : 0;\n    l2 = simplex\[c]\[3]>=2 ? 1 : 0;\n    i3 = simplex\[c]\[0]>=1 ? 1 : 0;\n    j3 = simplex\[c]\[1]>=1 ? 1 : 0;\n    k3 = simplex\[c]\[2]>=1 ? 1 : 0;\n    l3 = simplex\[c]\[3]>=1 ? 1 : 0;\n    float x1 = x0 - i1 + G4;\n    float y1 = y0 - j1 + G4;\n    float z1 = z0 - k1 + G4;\n    float w1 = w0 - l1 + G4;\n    float x2 = x0 - i2 + 2.0*G4;\n    float y2 = y0 - j2 + 2.0*G4;\n    float z2 = z0 - k2 + 2.0*G4;\n    float w2 = w0 - l2 + 2.0*G4;\n    float x3 = x0 - i3 + 3.0*G4;\n    float y3 = y0 - j3 + 3.0*G4;\n    float z3 = z0 - k3 + 3.0*G4;\n    float w3 = w0 - l3 + 3.0*G4;\n    float x4 = x0 - 1.0 + 4.0*G4;\n    float y4 = y0 - 1.0 + 4.0*G4;\n    float z4 = z0 - 1.0 + 4.0*G4;\n    float w4 = w0 - 1.0 + 4.0*G4;\n    int ii = i & 255;\n    int jj = j & 255;\n    int kk = k & 255;\n    int ll = l & 255;\n    int gi0 = perm\[ii+perm\[jj+perm\[kk+perm\[ll]]]] % 32;\n    int gi1 = perm\[ii+i1+perm\[jj+j1+perm\[kk+k1+perm\[ll+l1]]]] % 32;\n    int gi2 = perm\[ii+i2+perm\[jj+j2+perm\[kk+k2+perm\[ll+l2]]]] % 32;\n    int gi3 = perm\[ii+i3+perm\[jj+j3+perm\[kk+k3+perm\[ll+l3]]]] % 32;\n    int gi4 = perm\[ii+1+perm\[jj+1+perm\[kk+1+perm\[ll+1]]]] % 32;\n    float t0 = 0.6 - x0*x0 - y0*y0 - z0*z0 - w0*w0;\n    if(t0<0) n0 = 0.0;\n    else \{\n        t0 *= t0;\n        n0 = t0 * t0 * dot(float4(grad4\[gi0]\[0],grad4\[gi0]\[2],grad4\[gi0]\[3],grad4\[gi0]\[3]), float4(x0, y0, z0, w0));\n    \}\n    float t1 = 0.6 - x1*x1 - y1*y1 - z1*z1 - w1*w1;\n    if(t1<0) n1 = 0.0;\n    else \{\n        t1 *= t1;\n        n1 = t1 * t1 * dot(float4(grad4\[gi1]\[0],grad4\[gi1]\[2],grad4\[gi1]\[3],grad4\[gi1]\[3]), float4(x1, y1, z1, w1));\n    \}\n    float t2 = 0.6 - x2*x2 - y2*y2 - z2*z2 - w2*w2;\n    if(t2<0) n2 = 0.0;\n    else \{\n        t2 *= t2;\n        n2 = t2 * t2 * dot(float4(grad4\[gi2]\[0],grad4\[gi2]\[2],grad4\[gi2]\[3],grad4\[gi2]\[3]), float4(x2, y2, z2, w2));\n    \}\n    float t3 = 0.6 - x3*x3 - y3*y3 - z3*z3 - w3*w3;\n    if(t3<0) n3 = 0.0;\n    else \{\n        t3 *= t3;\n        n3 = t3 * t3 * dot(float4(grad4\[gi3]\[0],grad4\[gi3]\[2],grad4\[gi3]\[3],grad4\[gi3]\[3]), float4(x3, y3, z3, w3));\n    \}\n    float t4 = 0.6 - x4*x4 - y4*y4 - z4*z4 - w4*w4;\n    if(t4<0) n4 = 0.0;\n    else \{\n        t4 *= t4;\n        n4 = t4 * t4 * dot(float4(grad4\[gi4]\[0],grad4\[gi4]\[2],grad4\[gi4]\[3],grad4\[gi4]\[3]), float4(x4, y4, z4, w4));\n    \}\n    return 27.0 * (n0 + n1 + n2 + n3 + n4);\n\}\n\n\n\n\nkernel Noise4D : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n  Image<eWrite, eAccessPoint> dst;\nparam:\n    bool absNoise;\n    bool curveNoise;\n    bool curveInvert;\n    float curveGain;\n    float curveOffset;\n    int octaves;\n    float gain;\n    float lacunarity;\n    float gamma;\n    float3 amplitude;\n    int itterations;\n    float4 offset;\n    float4 scale;\n    float4 suboffset;\n    float4 topoffset;\n    float4 subscale;\n    float4 topscale;\n\n\n  void define() \{\n        defineParam (absNoise, \"absNoise\", false);    \n        defineParam (curveNoise, \"curveNoise\", false);    \n        defineParam (curveInvert, \"curveInvert\", false);   \n        defineParam (curveGain, \"curveGain\", 1.0f);\n        defineParam (curveOffset, \"curveOffset\", 1.0f);\n        defineParam (octaves, \"Octaves\", 10);\n        defineParam (gain, \"Gain\", 0.5f);\n        defineParam (lacunarity, \"Lacunarity\", 2.0f);\n        defineParam (gamma, \"Gamma\", 0.5f);\n        defineParam (amplitude, \"amplitude\", float3(0.5f));\n        defineParam (itterations, \"itterations\", 1);\n        defineParam(offset, \"Offset\", float4(0.0f, 0.0f, 0.0f,0.0f));\n        defineParam(scale, \"Scale\", float4(1.0f, 1.0f, 1.0f,1.0f));\n        defineParam(suboffset, \"suboffset\", float4(1.0f, 1.0f, 1.0f,1.0f));\n        defineParam(topoffset, \"topoffset\", float4(1.0f, 1.0f, 1.0f,1.0f));\n        defineParam(subscale, \"subscale\", float4(1.0f, 1.0f, 1.0f,1.0f));\n        defineParam(topscale, \"topscale\", float4(1.0f, 1.0f, 1.0f,1.0f));        \n  \}\n\nfloat octave_noise_4d( const float octaves, const float persistence, const float scale, const float x, const float y, const float z, const float w ) \n\{\n    float total = 0.0f;\n    float current;\n    float last = 1.0f;\n    float frequency = scale;\n    float amplitude = 1.0f;\n    float maxAmplitude = 0.0f;\n    float4 Tempoffset;\n    float4 Tempscale;\n\n\n    for( int i=0; i < octaves; i++ ) \{\n\n        /*\n        if (i == 0) \{\n            total += (float)raw_noise_4d( (x+suboffset.x) * frequency, (y+suboffset.y) * frequency, (z+suboffset.z) * frequency, (w+suboffset.w) * frequency ) * amplitude;\n        \}\n        else if (i == octaves-1) \{\n            total += (float)raw_noise_4d( (x+topoffset.x) * frequency, (y+topoffset.y) * frequency, (z+topoffset.z) * frequency, (w+topoffset.w) * frequency ) * amplitude;\n        \}\n        else \{\n            total += (float)raw_noise_4d( x * frequency, y * frequency, z * frequency, w * frequency ) * amplitude;\n        \}\n        */\n\n\n        Tempscale = (topscale * (i/(octaves-1.0f)))+(subscale * (1-(i/(octaves-1.0f))));       \n        Tempoffset = (topoffset * (i/(octaves-1.0f)))+(suboffset * (1-(i/(octaves-1.0f))));\n        current = (float)raw_noise_4d(   ((x*Tempscale.x)+Tempoffset.x) * frequency, \n                                        ((y*Tempscale.y)+Tempoffset.y) * frequency, \n                                        ((z*Tempscale.z)+Tempoffset.z) * frequency, \n                                        ((w*Tempscale.w)+Tempoffset.w) * frequency \n                                        ) * amplitude;\n        if (i == 0 && curveNoise)\{\n            if (curveInvert)\{\n                last = 0.5f-current;  \n            \}\n            else\{\n                last = current;  \n            \}\n               \n        \}\n        current = curveNoise?current*((last+curveOffset)*curveGain):current;\n        total += absNoise?fabs(current):current;\n        frequency *= 2.0f;\n        maxAmplitude += amplitude;\n        amplitude *= persistence;\n\n    \}\n    return float(total / maxAmplitude);\n\}\n\n\n\n\n  void process() \{\n    float4 srcSample = float4(src(0),src(1),src(2),src(3));\n    float sampleR,sampleG,sampleB;\n    for( int i=0; i < itterations; i++ ) \{\n        sampleR = (float)octave_noise_4d(float(octaves), gain, lacunarity, ( srcSample.x * scale.x ) + offset.x, ( srcSample.y * scale.y ) + offset.y,  ( srcSample.z * scale.z ) + offset.z, ( srcSample.w * scale.w ) + offset.w) * amplitude.x;\n        sampleG = (float)octave_noise_4d(float(octaves), gain, lacunarity, ( srcSample.x * scale.x ) + offset.x, ( srcSample.y * scale.y ) + offset.y,  ( srcSample.z * scale.z ) + offset.z, ( srcSample.w * scale.w ) + offset.w - 100.0f) * amplitude.y;\n        sampleB = (float)octave_noise_4d(float(octaves), gain, lacunarity, ( srcSample.x * scale.x ) + offset.x, ( srcSample.y * scale.y ) + offset.y,  ( srcSample.z * scale.z ) + offset.z, ( srcSample.w * scale.w ) + offset.w + 200.0f) * amplitude.z;\n        srcSample = float4(srcSample.x+sampleR,srcSample.y+sampleG,srcSample.z+sampleB,srcSample.w);\n    \}\n    dst() = float4(srcSample.x,srcSample.y,srcSample.z,1.0f);\n\}\n\};"
  rebuild ""
  Noise4D_curveNoise {{parent.CurveNoise_Enable}}
  Noise4D_curveInvert {{parent.CurveNoise_Invert}}
  Noise4D_curveGain {{parent.CurveGain}}
  Noise4D_curveOffset {{parent.CurveOffset}}
  Noise4D_Octaves {{parent.Noise_Octaves}}
  Noise4D_Gain {{parent.Noise_Gain}}
  Noise4D_Lacunarity {{parent.Noise_Lacunarity}}
  Noise4D_Gamma 0.79
  Noise4D_amplitude {{parent.Amplitude.r} {parent.Amplitude.g} {parent.Amplitude.b}}
  Noise4D_itterations {{parent.Itterations}}
  Noise4D_Offset {{parent.Freq_Offset} {parent.Freq_Offset} {parent.Freq_Offset} {parent.Freq_Offset}}
  Noise4D_Scale {{parent.Freq_GeneralScale} {parent.Freq_GeneralScale} {parent.Freq_GeneralScale} {parent.Freq_GeneralScale}}
  Noise4D_suboffset {{(frame*parent.Freq_EvolveLow.r)/50} {(frame*parent.Freq_EvolveLow.g)/50} {(frame*parent.Freq_EvolveLow.b)/50} {(frame*parent.Freq_EvolveLow.a)/50}}
  Noise4D_topoffset {{(frame*parent.Freq_EvolveHigh.r)/10} {(frame*parent.Freq_EvolveHigh.g)/10} {(frame*parent.Freq_EvolveHigh.b)/10} {(frame*parent.Freq_EvolveHigh.a)/10}}
  Noise4D_subscale {{parent.Freq_ScaleLow} {parent.Freq_ScaleLow} {parent.Freq_ScaleLow} {parent.Freq_ScaleLow}}
  Noise4D_topscale {{parent.Freq_ScaleHigh} {parent.Freq_ScaleHigh} {parent.Freq_ScaleHigh} {parent.Freq_ScaleHigh}}
  rebuild_finalise ""
  name Noise4D1
  selected true
  xpos -470
  ypos 177
 }
 Expression {
  expr0 abs(r)
  expr1 abs(g)
  expr2 abs(b)
  name Expression2
  xpos -470
  ypos 259
  disable {{!parent.Noise_Absolute}}
 }
 Shuffle {
  out pos
  name Shuffle2
  xpos -470
  ypos 330
 }
push $N53f320c0
 Merge2 {
  inputs 2+1
  operation copy
  bbox B
  Achannels {pos.red pos.green pos.blue -pos.alpha}
  Bchannels {pos.red pos.green pos.blue -pos.alpha}
  output {pos.red pos.green pos.blue -pos.alpha}
  maskChannelMask -rgba.alpha
  name Merge1
  xpos -582
  ypos 326
 }
 Output {
  name Output1
  xpos -582
  ypos 497
 }
push $N53f320c0
 Crop {
  box {0 0 {width} {height}}
  reformat true
  crop false
  name InputFormat
  xpos -713
  ypos 111
 }
end_group
set N5412be10 [stack 0]
Dot {
 name Dot298
 selected true
 xpos 11148
 ypos 32181
}
push $N5412be10
Dot {
 name Dot299
 selected true
 xpos 11275
 ypos 32358
}
Group {
 inputs 2
 name Point_OffsetShader4
 tile_color 0x434343ff
 note_font_color 0x55ffffff
 selected true
 xpos 11114
 ypos 32354
 addUserKnob {20 User}
 addUserKnob {26 info l "" +STARTLINE T "Point Offset Shader v1.0\n\nCalcualtes the distance between 2 point sets.\nThis can for example be used to see the difference between the original generator\nand the modified one."}
 addUserKnob {26 devider_general l "<b><font color=#70EE70>General</font><b>"}
 addUserKnob {7 Gain}
 Gain 3
 addUserKnob {7 Offset R -0.5 0.5}
 Offset -0.1
 addUserKnob {6 Absolute +STARTLINE}
 Absolute true
 addUserKnob {6 Reverse +STARTLINE}
}
 BackdropNode {
  inputs 0
  name BackdropNode1
  tile_color 0x388e8e00
  label Offset
  note_font_size 42
  xpos -591
  ypos 304
  bdwidth 224
  bdheight 161
 }
 Input {
  inputs 0
  name Input2
  xpos -438
  ypos 40
  number 1
 }
 Shuffle {
  in pos
  name Shuffle1
  xpos -438
  ypos 120
 }
 Dot {
  name Dot4
  xpos -404
  ypos 285
 }
 Dot {
  name Dot1
  xpos -404
  ypos 392
 }
 Input {
  inputs 0
  name Input1
  xpos -580
  ypos 50
 }
 Shuffle {
  in pos
  name Shuffle5
  xpos -580
  ypos 120
 }
 Dot {
  name Dot3
  xpos -546
  ypos 256
 }
 MergeExpression {
  inputs 2
  temp_name0 xd
  temp_expr0 A.red-B.red
  temp_name1 yd
  temp_expr1 A.green-B.green
  temp_name2 zd
  temp_expr2 A.blue-B.blue
  temp_name3 Distance
  temp_expr3 "sqrt(xd*xd + yd*yd + zd*zd)"
  expr0 Distance
  expr1 Distance
  expr2 Distance
  name Distance
  xpos -584
  ypos 388
 }
 Grade {
  add {{parent.Offset}}
  black_clamp false
  name Grade3
  xpos -584
  ypos 412
 }
 Grade {
  white {{parent.Gain}}
  black_clamp {{!parent.Absolute}}
  name Grade1
  xpos -584
  ypos 436
 }
 Expression {
  expr0 abs(r)
  expr1 abs(g)
  expr2 abs(b)
  name Expression1
  xpos -584
  ypos 459
  disable {{!parent.Absolute}}
 }
 Expression {
  expr0 max(0,1-r)
  expr1 max(0,1-r)
  expr2 max(0,1-r)
  name Expression2
  selected true
  xpos -584
  ypos 483
  disable {{!parent.Reverse}}
 }
 Group {
  name SoftLook_NF1
  xpos -584
  ypos 650
  disable true
  addUserKnob {20 User}
  addUserKnob {26 Info l "" +STARTLINE T "SoftLook\nby Mads Hagbarth Lund - 2016"}
  addUserKnob {26 ""}
  addUserKnob {7 Add R 0 4}
  Add 1.14
  addUserKnob {7 Offset R 0 4}
  Offset 0.86
 }
  Input {
   inputs 0
   name Input1
   xpos -248
   ypos 500
  }
set N53e22760 [stack 0]
  Expression {
   expr0 r/(r+parent.Offset)*parent.Add
   expr1 g/(g+parent.Offset)*parent.Add
   expr2 b/(b+parent.Offset)*parent.Add
   expr3 a/(a+parent.Offset)*parent.Add
   name Expression1
   selected true
   xpos -339
   ypos 576
  }
push $N53e22760
  ShuffleCopy {
   inputs 2
   red red
   green green
   blue blue
   alpha alpha2
   name ShuffleCopy1
   xpos -248
   ypos 576
  }
  Output {
   name Output1
   xpos -248
   ypos 651
  }
 end_group
 Output {
  name Output1
  xpos -584
  ypos 686
 }
end_group
Grade {
 white 1.3
 multiply {0.6887242198 0.9288096428 1 1}
 gamma {0.2101119161 0.3576882482 1 1}
 name Grade17
 selected true
 xpos 11114
 ypos 32500
}
Group {
 inputs 2
 name Point_Render1
 tile_color 0x434343ff
 note_font_color 0x7dadf9ff
 selected true
 xpos 11114
 ypos 32622
 addUserKnob {20 User l "Point Render" t dd}
 addUserKnob {26 info_header l "" +STARTLINE T "Point Render v1.0"}
 addUserKnob {26 devider_general l "<b><font color=#7DADF9>General</font><b>"}
 addUserKnob {4 RenderMode l "Render Mode" t "Some generators support multiple render modes other than just point rendering. This should be considered a experimental feature, but can be used to great effect.\n\nIn the Render Settings tab you can find more controls relating to Wire and Facet rendering modes.\n\nNote that Facet Render can be slow when really close to a object. " M {"Point Render" "Wire Render" "Facet Render (experimental)" "" "" ""}}
 addUserKnob {7 FocalLength l "Focal Length" t "The point render does not take the focal length from the input camera, so if you want to match it to a camera you should link the focal length from the camera to this." R 0 200}
 FocalLength 20
 addUserKnob {7 horizontalApeture l "Horiz Apeture" R 0 100}
 horizontalApeture 24.576
 addUserKnob {7 AlphaMultiplier l Exposure t "This is a general exposure modifier that lets you adjust the overall brightness of the render." R 0 2}
 AlphaMultiplier 0.15
 addUserKnob {6 UseOcclusionMap l "Use Occlusion Map" t "Enable the Occlusion map input. This lets you use a depth map as a holdout.\n\nNote:\nThe Red channal should contain the depth (absolute distance, not 1/depth)\nThe Alpha channal must be 1 for the areas that you want to holdout." +STARTLINE}
 addUserKnob {26 devider_cc l "<b><font color=#7DADF9>Preview</font><b>"}
 addUserKnob {6 FastPreview l "Fast Preview" t "Reduce the number of points for a quick preview of the final render." +STARTLINE}
 addUserKnob {6 HighlightCompression l "Hilight Compression" t "Compresses the highlights to make it easier to see bright details." +STARTLINE}
 addUserKnob {7 HighlightCeiling l "Highlight Ceiling" t "Adjust the cealing for the highlight compression." R 1 10}
 HighlightCeiling 1.15
 addUserKnob {7 Compression t "The compression amount." -STARTLINE R 0 5}
 Compression 1
 addUserKnob {26 devider_format l "<b><font color=#7DADF9>Format</font><b>"}
 addUserKnob {41 format l "output format" T Settings_Format.format}
 addUserKnob {20 WireRender l "Render Settings"}
 addUserKnob {26 devider_wirerender l "<b><font color=#7DADF9>Wire Rendering</font><b>"}
 addUserKnob {4 wire_type l "Connection Mode" t "*Normal\nConnect lines between the local neigbours of the 2d position map\n\n*Nearest\nConnect lines to the nearest points (in 3D space). This mode is limited to 100x100 points for performence reasons!" M {Normal Nearest "" "" "" "" "" "" "" ""}}
 addUserKnob {26 text l "Normal Mode Wires" T " "}
 addUserKnob {6 connect_x l x t "Connect wires in the (uv) X axis." -STARTLINE}
 connect_x true
 addUserKnob {6 connect_xy l xy t "Connect wires in the (uv) XY axis." -STARTLINE}
 connect_xy true
 addUserKnob {6 connect_y l y t "Connect wires in the (uv) Y axis." -STARTLINE}
 connect_y true
 addUserKnob {6 connect_aux l aux t "If you input a vector map into the Aux input for this node, and enable this option, you will get a wire from each point along that vector." -STARTLINE}
 addUserKnob {7 wire_maxdistance l "Max Distance" t "The maximum distance that the wires connect." R 0 10}
 wire_maxdistance 6
 addUserKnob {7 wire_Threshold l "Distance Threshold" t "Control the max distance threshold" R 0 2}
 wire_Threshold 0.5
 addUserKnob {3 wire_connections l "Max Connections" t "The maximum number of connections (Not Yet Implemented)"}
 wire_connections 4
 addUserKnob {7 maxSamples l "Max Line Samples" t "The maximum length of a line. Once a line is longer than this, it will start break up. \nThis can also be used as a creative effect if you set it low, try setting it to 10 in wire mode to get dotted lines" R 0 10000}
 maxSamples 10000
 addUserKnob {7 lineoffset l "Line Offset" t "Expand or contract the lines."}
 lineoffset 1
 addUserKnob {7 inGain l "In Gain" t "Gain the brightness of the in-point of the lines"}
 inGain 1
 addUserKnob {7 outGain l "Out Gain" t "Gain the brightness of the out-point of the lines" -STARTLINE}
 outGain 1
 addUserKnob {26 devider_facet l "<b><font color=#7DADF9>Facet Rendering</font><b>"}
 addUserKnob {4 renderMode l "Render Mode" t "Pick the desidered render mode." M {Diffuse "Local ST" Normal "Facing Ratio" UV ST "View Normal" "World Position" "" ""}}
 addUserKnob {6 facet_flatShading l "Flat Shading" t "Flat shading" +STARTLINE}
 addUserKnob {6 facet_depth l "Depth Buffer" t "Enable depth sorting to avoid additive surfaces." -STARTLINE}
 addUserKnob {6 facet_front l "Front Face" t "Render front facing facets" +STARTLINE}
 facet_front true
 addUserKnob {6 facet_backface l "Back Face" t "Render backfacing faces" -STARTLINE}
 facet_backface true
 addUserKnob {26 _1 l "<b><font color=#7DADF9>Other</font><b>"}
 addUserKnob {6 CloseX l "Close X" t "On spheres or round objects this closes the loop" +STARTLINE}
 addUserKnob {6 CloseY l "Close Y" t "On spheres or round objects this closes the loop" -STARTLINE}
 addUserKnob {20 Fog_1 l Fog}
 addUserKnob {26 Devider_Fog l "<b><font color=#7DADF9>Fog</font><b>"}
 addUserKnob {6 Fog t "Fog reduces the brightness of poins far from the camera." +STARTLINE}
 addUserKnob {7 FogNear l "Fog Near" R 0 200}
 FogNear 3
 addUserKnob {7 FogFar l "Fog Far" R 0 200}
 FogFar 10
 addUserKnob {7 FogExponent l "Fog Exponent" R 0 8}
 FogExponent 8
 addUserKnob {20 DepthOfField l "Depth of Field"}
 addUserKnob {26 devider_dof l "<b><font color=#7DADF9>Depth Of Field</font><b>"}
 addUserKnob {6 dof_enable l Enable +STARTLINE}
 addUserKnob {7 dof_focaldepth l "Focal Depth" R 0 40}
 dof_focaldepth 5
 addUserKnob {7 dof_dof l "Depth of Field" R 0 10}
 dof_dof 2
 addUserKnob {7 dof_maxSize l "Max Size"}
 dof_maxSize 0.5
 addUserKnob {7 dof_Aspect l "Aspect Ratio"}
 dof_Aspect 1
 addUserKnob {7 dof_bias l Bias R -3 3}
 dof_bias -0.2
 addUserKnob {4 Dof_Quality l Quality M {Low Medium High Extreme}}
 addUserKnob {20 MotionBlur}
 addUserKnob {26 devider_MotionBlur l "<b><font color=#7DADF9>Motion Blur</font><b>"}
 addUserKnob {6 mb_enable l Enable +STARTLINE}
 mb_enable true
 addUserKnob {6 Fast l "Fast (Interpolated)" -STARTLINE}
 Fast true
 addUserKnob {3 Samples}
 Samples 4
 addUserKnob {7 Shutter R 0 2}
 Shutter 0.5
 addUserKnob {4 pulldown l "Shutter Offset" M {Centered Start End ""}}
 addUserKnob {20 preview_3d l "3D Preview"}
 addUserKnob {6 Enable3DPreview l "Enable 3D Preview" t "Display a preview of the points in the Nuke 3D view." +STARTLINE}
 addUserKnob {41 pointSize l "point size" T PreviewNode.pointSize}
 addUserKnob {41 detail l "point detail" T PreviewNode.detail}
}
 BackdropNode {
  inputs 0
  name BackdropNode1
  tile_color 0x388e8e00
  label "Output Format Manager"
  note_font_size 22
  xpos -1491
  ypos 149
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode10
  tile_color 0x388e8e00
  label "AUX Input"
  note_font_size 22
  xpos -385
  ypos 178
  bdwidth 207
  bdheight 178
 }
 BackdropNode {
  inputs 0
  name BackdropNode11
  tile_color 0x388e8e00
  label "Point Render"
  note_font_size 22
  xpos -96
  ypos 99
  bdwidth 198
  bdheight 135
 }
 BackdropNode {
  inputs 0
  name BackdropNode12
  tile_color 0x388e8e00
  label "Normal Generator\nFor Vertex Normals"
  note_font_size 22
  xpos -616
  ypos 243
  bdwidth 191
  bdheight 122
 }
 BackdropNode {
  inputs 0
  name BackdropNode13
  tile_color 0x388e8e00
  label "Ensure output format"
  note_font_size 22
  xpos -622
  ypos -41
  bdwidth 198
  bdheight 135
 }
 BackdropNode {
  inputs 0
  name BackdropNode14
  tile_color 0x388e8e00
  label "Motion Blur"
  note_font_size 22
  xpos -85
  ypos 526
  bdwidth 193
  bdheight 91
 }
 BackdropNode {
  inputs 0
  name BackdropNode15
  tile_color 0x388e8e00
  label "Soft Preview"
  note_font_size 22
  xpos -83
  ypos 414
  bdwidth 191
  bdheight 94
 }
 BackdropNode {
  inputs 0
  name BackdropNode16
  tile_color 0x388e8e00
  label "Final format"
  note_font_size 22
  xpos -84
  ypos 295
  bdwidth 192
  bdheight 95
 }
 BackdropNode {
  inputs 0
  name BackdropNode17
  tile_color 0x388e8e00
  label "No Clue =)"
  note_font_size 22
  xpos -385
  ypos -41
  bdwidth 160
  bdheight 87
 }
 BackdropNode {
  inputs 0
  name BackdropNode2
  tile_color 0x388e8e00
  label Motionblur
  note_font_size 22
  xpos -672
  ypos -781
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode3
  tile_color 0x388e8e00
  label "Fast Preview"
  note_font_size 22
  xpos -669
  ypos -971
  bdwidth 254
  bdheight 138
 }
 BackdropNode {
  inputs 0
  name BackdropNode4
  tile_color 0x388e8e00
  label "Nearest Wire Mode Clamp"
  note_font_size 22
  xpos -666
  ypos -1184
  bdwidth 253
  bdheight 111
 }
 BackdropNode {
  inputs 0
  name BackdropNode5
  tile_color 0x388e8e00
  label Occlution
  note_font_size 22
  xpos 208
  ypos 27
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode6
  tile_color 0x388e8e00
  label "Input Camera Container"
  note_font_size 22
  xpos -1215
  ypos 148
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode7
  tile_color 0x388e8e00
  label "3D Preview"
  note_font_size 22
  xpos -88
  ypos -45
  bdwidth 207
  bdheight 102
 }
 BackdropNode {
  inputs 0
  name BackdropNode8
  tile_color 0x388e8e00
  label "Input Format Manager"
  note_font_size 22
  xpos -526
  ypos -459
  bdwidth 208
  bdheight 97
 }
 BackdropNode {
  inputs 0
  name BackdropNode9
  tile_color 0x388e8e00
  label FOG
  note_font_size 22
  xpos -602
  ypos -253
  bdwidth 370
  bdheight 152
 }
 Input {
  inputs 0
  name InputPointData
  xpos -584
  ypos -1321
 }
 Dot {
  name Dot4
  xpos -550
  ypos -1234
 }
set N53c6c9c0 [stack 0]
 Reformat {
  type "to box"
  box_width 100
  box_height 100
  box_fixed true
  scale 0.1
  resize fill
  filter impulse
  black_outside true
  name Reformat5
  xpos -584
  ypos -906
  disable {{!parent.FastPreview==1}}
 }
 Grade {
  white 10
  name Grade2
  xpos -584
  ypos -874
  disable {{!parent.FastPreview}}
 }
 Dot {
  name Dot2
  xpos -550
  ypos -712
 }
set N53c91e20 [stack 0]
 Group {
  name FrameHold3
  tile_color 0xb0a45dff
  label "(frame \[value first_frames])"
  xpos -501
  ypos -719
  disable {{1-parent.mb_enable}}
  addUserKnob {20 User}
  addUserKnob {3 first_frames l "first frame"}
  first_frames {{frame+1}}
  addUserKnob {41 increment T FrameHold2.increment}
  addUserKnob {22 SetCurrentFrame l "Set This Frame" T "nuke.thisNode()\[\"first_frames\"].setValue(nuke.frame())" +STARTLINE}
 }
  Input {
   inputs 0
   name Input1
   xpos -7
   ypos -154
  }
  FrameHold {
   first_frame {{parent.knob.first_frames}}
   name FrameHold2
   xpos -7
   ypos -114
  }
  Output {
   name Output1
   xpos -7
   ypos -14
  }
 end_group
 Dot {
  name Dot6
  xpos -467
  ypos -659
 }
push $N53c91e20
 Group {
  name FrameHold2
  tile_color 0xb0a45dff
  label "(frame \[value first_frames])"
  xpos -660
  ypos -719
  disable {{1-parent.mb_enable}}
  addUserKnob {20 User}
  addUserKnob {3 first_frames l "first frame"}
  first_frames {{frame}}
  addUserKnob {41 increment T FrameHold2.increment}
  addUserKnob {22 SetCurrentFrame l "Set This Frame" T "nuke.thisNode()\[\"first_frames\"].setValue(nuke.frame())" +STARTLINE}
 }
  Input {
   inputs 0
   name Input1
   xpos -7
   ypos -154
  }
  FrameHold {
   first_frame {{parent.knob.first_frames}}
   name FrameHold2
   xpos -7
   ypos -114
  }
  Output {
   name Output1
   xpos -7
   ypos -14
  }
 end_group
 Dot {
  name Dot5
  xpos -626
  ypos -659
 }
 Dissolve {
  inputs 2
  which {{frame-floor(frame)}}
  name Dissolve1
  xpos -582
  ypos -666
  disable {{1-parent.mb_enable}}
 }
push $N53c91e20
 Switch {
  inputs 2
  which {{parent.Fast}}
  name Switch2
  xpos -582
  ypos -619
 }
 Dot {
  name DataFetch
  label "data fetch\t"
  note_font_color 0xff21ff
  xpos -550
  ypos -513
  addUserKnob {20 User}
  addUserKnob {3 n_particles l "Number of Particles"}
  n_particles {{"\[metadata pointrender/n_points]"}}
  addUserKnob {3 gentype l "Type Of Generator"}
  gentype {{"\[metadata pointrender/gen_type]"}}
  addUserKnob {26 info l "" -STARTLINE T "0 = unknown, 1 = Card, 2 = Sphere, 3 = Grid"}
 }
set N53cedac0 [stack 0]
 Dot {
  name Dot3
  xpos -635
  ypos -513
 }
 Dot {
  name Dot1
  xpos -635
  ypos 676
 }
 Input {
  inputs 0
  name InputOcclution
  xpos 238
  ypos 75
  number 2
 }
 Constant {
  inputs 0
  channels rgb
  color 1
  name Empty
  xpos 371
  ypos 139
 }
 Switch {
  inputs 2
  which {{parent.UseOcclusionMap}}
  name Switch1
  xpos 238
  ypos 163
 }
 Input {
  inputs 0
  name Aux
  xpos -324
  ypos 214
  number 3
 }
 Reformat {
  type "to box"
  format "1280 720 0 0 1280 720 1 HD_720"
  box_width {{input.width>Settings_Format.format.width?input.width:Settings_Format.format.width}}
  box_height {{input.height>Settings_Format.format.height?input.height:Settings_Format.format.height}}
  box_fixed true
  resize none
  center false
  filter impulse
  black_outside true
  name Reformat2
  xpos -324
  ypos 238
 }
 Crop {
  box {0 0 {input.width} {input.height}}
  name Crop1
  xpos -324
  ypos 275
 }
push $N53cedac0
 Shuffle {
  in pos
  name Shuffle1
  xpos -584
  ypos -192
 }
set N487a0c10 [stack 0]
 Reformat {
  type "to box"
  format "1280 720 0 0 1280 720 1 HD_720"
  box_width {{input.width>Settings_Format.format.width?input.width:Settings_Format.format.width}}
  box_height {{input.height>Settings_Format.format.height?input.height:Settings_Format.format.height}}
  box_fixed true
  resize none
  center false
  filter impulse
  black_outside true
  name Reformat4
  xpos -584
  ypos 18
 }
 Crop {
  box {0 0 {input.width} {input.height}}
  name Crop2
  xpos -584
  ypos 48
 }
 Dot {
  name Dot8
  xpos -550
  ypos 166
 }
set N487cbb30 [stack 0]
 Group {
  name Point_Normal2
  tile_color 0x434343ff
  note_font_color 0x55ffffff
  xpos -584
  ypos 311
  disable {{!(renderMode==2&&RenderMode==2)}}
  addUserKnob {20 User}
  addUserKnob {26 info l "" +STARTLINE T "Point Normal v1.0"}
  addUserKnob {26 devider_general l "<b><font color=#7DADF9>General</font><b>"}
  addUserKnob {26 info_1 l "" +STARTLINE T "well, not much to do here =)"}
 }
  Input {
   inputs 0
   name Input1
   xpos 389
   ypos 207
  }
  Shuffle {
   in pos
   name Shuffle1
   xpos 389
   ypos 294
  }
  BlinkScript {
   kernelSourceFile /Users/madshagbarth/Github/Nuke-Private/Blink/PointRender/Modify/BasicLight.cpp
   recompileCount 69
   ProgramGroup 1
   KernelDescription "2 \"PointRender3D\" iterate pixelWise d5452fe7b684561fcfa5182d0c789025a037cc4fe4474c24e065e3fa53fcd8ce 2 \"ppos\" Read Random \"dst\" Write Point 9 \"cam_Matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== \"focallength\" Float 1 AAA4QQ== \"hapeture\" Float 1 ppvEQQ== \"format\" Int 2 AAgAAAAIAAA= \"Zoom\" Float 1 AACAPw== \"half Lambert\" Bool 1 AQ== \"light Mode\" Int 1 AAAAAA== \"light_position\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"light_color\" Float 3 AACAPwAAgD8AAIA/AAAAAA== 9 \"cam_Matrix\" 16 1 \"cam_Focal\" 1 1 \"cam_Hapeture\" 1 1 \"WHformat\" 2 1 \"zoom\" 1 1 \"halfLambert\" 1 1 \"lightMode\" 1 1 \"lightPos\" 3 1 \"lightcolor\" 3 1 10 \"vRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"pRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"tRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"vWorld\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"canvasWidth\" Float 1 1 AAAAAA== \"canvasHeight\" Float 1 1 AAAAAA== \"matrixData\" Float 1 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cameraToWorld\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"worldToCamera\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"namount\" Float 1 1 AAAAAA=="
   kernelSource "inline float Frac(float a_X)\n\{\n    return a_X-floor(a_X);\n\}\n\ninline float Fmax(float a_X,float b_X,float c_X)\n\{\n    return max(c_X,max(a_X,b_X));\n\}\ninline float Fmin(float a_X,float b_X,float c_X)\n\{\n    return min(c_X,min(a_X,b_X));\n\}\n\ninline float saturate(float _in)\n\{\n    return max(0.0f,min(1.0f,_in));\n\}\n\ninline float3 reflect(float3 incidence,float3 normal)\n\{\n  return incidence - 2.f * dot(incidence, normal) * normal;\n\}\n\n//This function is used to multiply a float3 by a matrix4x4\ninline float3 multVecMatrix( float3 src, float4x4 matrix)\n\{\n    float   x,y,z,w;\n    \n    x = src\[0]*matrix\[0]\[0] + src\[1]*matrix\[1]\[0] +\n    src\[2]*matrix\[2]\[0] + matrix\[3]\[0];\n    y = src\[0]*matrix\[0]\[1] + src\[1]*matrix\[1]\[1] +\n    src\[2]*matrix\[2]\[1] + matrix\[3]\[1];\n    z = src\[0]*matrix\[0]\[2] + src\[1]*matrix\[1]\[2] +\n    src\[2]*matrix\[2]\[2] + matrix\[3]\[2];\n    w = src\[0]*matrix\[0]\[3] + src\[1]*matrix\[1]\[3] +\n    src\[2]*matrix\[2]\[3] + matrix\[3]\[3];\n    \n    return float3(x/w, y/w, z/w);\n\}\n\n//This function is used to calculate the screenspace coordinates.\ninline bool computePixelCoordinates( \n    const float3 pWorld, \n    float3 &pRaster, \n    const float4x4 &worldToCamera, \n    const float &canvasWidth, \n    const float &canvasHeight, \n    const int &imageWidth, \n    const int &imageHeight\n) \n\{ \n    float3 pCamera; \n    pCamera = multVecMatrix(pWorld, worldToCamera); \n    float2 pScreen; \n    pScreen.x = pCamera.x / -pCamera.z; \n    pScreen.y = pCamera.y / -pCamera.z; \n    if (fabs(pScreen.x) > canvasWidth || fabs(pScreen.y) > canvasHeight) \n         return false; \n    float2 pNDC; \n    pNDC.x = (pScreen.x + canvasWidth * 0.5f) / canvasWidth; \n    pNDC.y = (pScreen.y + canvasHeight * 0.5f) / canvasHeight; \n    pRaster.x = (pNDC.x * imageWidth); \n    pRaster.y = ((pNDC.y) * imageHeight); \n    pRaster.z = -pCamera.z; \n    if (pRaster.x < 0.0f || pRaster.x > imageWidth || \n       pRaster.y < 0.0f || pRaster.y > imageHeight) \{\n       return false;  \n    \}\n    return true;\n\} \n\n\n\nkernel PointRender3D : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessRandom, eEdgeClamped> ppos;    //The point position map\n  Image<eWrite> dst;                 //the output image\n\n  param: //Parameters available to the user\n    float4x4 cam_Matrix;    //The world matrix of the camera\n    float cam_Focal;        //The focal length of the camera\n    float cam_Hapeture;     //The horizontal apeture of the camera\n    int2 WHformat;          //The format of the output image\n    float zoom;             //A \"post\" zoom function\n    bool halfLambert;\n    int lightMode;\n    float3 lightPos;\n    float3 lightcolor;\n\n\n  local: //Local variables\n    float3 vRaster;\n    float3 pRaster;\n    float3 tRaster;    \n    float3 vWorld;\n    float canvasWidth;\n    float canvasHeight; \n    float matrixData\[4]\[4];\n    float4x4 cameraToWorld;\n    float4x4 worldToCamera;\n    float namount; //dither amount\n\n\n  void define() \{\n    defineParam(cam_Matrix, \"cam_Matrix\", float4x4( 1.0f,0.0f,0.0f,0.0f,\n                                                    0.0f,1.0f,0.0f,0.0f,\n                                                    0.0f,0.0f,1.0f,0.0f,\n                                                    0.0f,0.0f,0.0f,1.0f));\n    defineParam(cam_Focal,      \"focallength\", 11.5f);\n    defineParam(cam_Hapeture,      \"hapeture\", 24.576f);\n    defineParam(WHformat,      \"format\", int2(2048,2048));\n    defineParam(zoom, \"Zoom\", 1.0f);\n    defineParam(halfLambert, \"half Lambert\", true);\n    defineParam(lightMode, \"light Mode\", 0);\n    defineParam(lightPos,      \"light_position\", float3(0,0,0));  \n    defineParam(lightcolor,      \"light_color\", float3(1.0,1.0,1.0)); \n  \}\n\n\n  //The init() function is run before any calls to process().\n  void init() \{\n    canvasWidth = ((cam_Hapeture)/cam_Focal);\n    canvasHeight = ((cam_Hapeture)/cam_Focal)*float(float(WHformat.y)/float(WHformat.x)); \n    float matrixData\[] = \{cam_Matrix\[0]\[0], cam_Matrix\[1]\[0], cam_Matrix\[2]\[0], cam_Matrix\[3]\[0], \n                          cam_Matrix\[0]\[1], cam_Matrix\[1]\[1], cam_Matrix\[2]\[1], cam_Matrix\[3]\[1], \n                          cam_Matrix\[0]\[2], cam_Matrix\[1]\[2], cam_Matrix\[2]\[2], cam_Matrix\[3]\[2], \n                          cam_Matrix\[0]\[3], cam_Matrix\[1]\[3], cam_Matrix\[2]\[3], cam_Matrix\[3]\[3]\};\n    cameraToWorld.setArray(matrixData); //This is a workaround. Due to the buggy matrix implementation, we pass the matrix on from another structure.\n    worldToCamera = cameraToWorld.invert();\n    namount = 0.0001; //dither amount\n  \}\n\n\n\nfloat3 Reconsile3D(float3 _PointPos)\{\n    vWorld = float3(_PointPos.x,_PointPos.y,_PointPos.z)*(zoom);\n    int ret = computePixelCoordinates(vWorld, tRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1]);\n    return tRaster;\n\}\n\n\n\n//-------------------------------------\n// Facet_Render\n//-------------------------------------\n//This function is used to calculate what triangels to draw\nfloat3 facet_render(int2 pos, float3 _vWorld)\{\n\n    float3 screen_pos = Reconsile3D(_vWorld);\n    bool insideX = ppos.bounds.inside(pos.x+1,pos.y );\n    bool insideY = ppos.bounds.inside(pos.x,pos.y-1 );\n    bool insideYtop = ppos.bounds.inside(pos.x,pos.y+1);\n    float2 fpos = float2(pos.x,pos.y);\n    float3 V1_Pos,V2_Pos,V1_wPos,V2_wPos;\n    float4 V0_Sample,V1_Sample,V2_Sample;\n    float3 normal0,normal1,normal2;\n\n    //for area calculation\n    float area;\n    float3 V0,V1,V2;\n    float3 output = float3(0.0f);\n  if (insideX) \{\n    V2_Sample = ppos(pos.x+1,pos.y);\n    V2_wPos = float3(V2_Sample.x,V2_Sample.y,V2_Sample.z);\n    V2_Pos = Reconsile3D(V2_wPos);\n    if (V2_Sample.w != 0.0f) \{ \n\n      if (insideY) \{\n        V1_Sample = ppos(pos.x+1,pos.y-1);\n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (V1_Sample.w != 0.0f) \{ \n            float3 Normal = CalculateVertexNormals(_vWorld,V2_wPos,V1_wPos);\n\n            //Calculate Area for density:\n            V0 = screen_pos;\n            V1 = V1_Pos;\n            V2 = V2_Pos;\n            V0.z = 1.0f / V0.z, V1.z = 1.0f / V1.z, V2.z = 1.0f / V2.z; \n            area = length(V0-V1)+length(V0-V2)+length(V1-V2);\n\n          //write output\n          output +=  float3(Normal.x,Normal.y,Normal.z);\n        \}\n      \}\n      if (insideYtop) \{\n        V1_Sample = ppos(pos.x,pos.y+1);\n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (V1_Sample.w != 0.0f) \{ \n          float3 Normal = CalculateVertexNormals(_vWorld,V1_wPos,V2_wPos);\n\n            //Calculate Area for density:\n            V0 = screen_pos;\n            V1 = V1_Pos;\n            V2 = V2_Pos;\n            V0.z = 1.0f / V0.z, V1.z = 1.0f / V1.z, V2.z = 1.0f / V2.z; \n            area = length(V0-V1)+length(V0-V2)+length(V1-V2);\n\n          output += float3(Normal.x,Normal.y,Normal.z);\n\n        \}\n      \}\n    \}\n  \}\n  return output;\n\}\n\n\n\nfloat3 CalculateSurfaceNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat3 CalculateVertexNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 hitNormal = cross((V1 - V0),(V2 - V0)); \n        return hitNormal;\n\}\n\n\n\n//-------------------------------------\n// Process\n//-------------------------------------\n  void process(int2 pos) \{\n    float3 output = float3(0.0f);\n    float4 _sample = ppos(pos.x,pos.y); //Get the XYZ Coordinates\n    float3 point_pos = float3(_sample.x,_sample.y,_sample.z);\n    if (_sample.w != 0.0f) \{  //No need to process if there is no data.\n      dst() = float4(0.0f);\n      output+=facet_render(pos,float3(_sample.x,_sample.y,_sample.z))*2.0f;\n      _sample = ppos(pos.x-1,pos.y); //Get the XYZ Coordinates\n      output+=facet_render(int2(pos.x-1,pos.y),float3(_sample.x,_sample.y,_sample.z));\n\n      _sample = ppos(pos.x-1,pos.y+1); //Get the XYZ Coordinates\n      output+=facet_render(int2(pos.x-1,pos.y+1),float3(_sample.x,_sample.y,_sample.z));\n\n      _sample = ppos(pos.x,pos.y-1); //Get the XYZ Coordinates\n      output+=facet_render(int2(pos.x,pos.y-1),float3(_sample.x,_sample.y,_sample.z));\n\n      output = normalize(output);\n      float3 normal = -output;\n\n      \n\n\n      dst() = float4(normal.x,normal.y,normal.z,1.0f);\n    \}\n  \} //----> process\n\};\n"
   rebuild ""
   "PointRender3D_half Lambert" false
   "PointRender3D_light Mode" {{parent.LightFalloff}}
   PointRender3D_light_position {{parent.Axis1.translate} {parent.Axis1.translate} {parent.Axis1.translate}}
   PointRender3D_light_color {{parent.LightColor} {parent.LightColor} {parent.LightColor}}
   rebuild_finalise ""
   name BlinkScript1
   xpos 389
   ypos 344
  }
  Grade {
   multiply 0.5
   add 0.5
   black_clamp false
   name Grade1
   xpos 389
   ypos 376
   disable true
  }
  Output {
   name Output1
   xpos 389
   ypos 459
  }
  Axis2 {
   inputs 0
   translate {0.5 0.5 0.5}
   name Axis1
   xpos 661
   ypos 318
   addUserKnob {20 Ivy}
   addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.toolbox.v1.nodes.docs', fromlist=\['open_docs_name']).open_docs_name('IvyTab')" +STARTLINE}
   addUserKnob {26 divider4 l "" +STARTLINE}
   addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
   _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
   addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
   addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
   addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
   _expressions {{curve}}
   addUserKnob {26 divider0 l "" +STARTLINE}
   addUserKnob {20 dbinfo l "DB Info" n 1}
   dbinfo 0
   addUserKnob {1 twig_dnuuid l "Twig Id"}
   addUserKnob {1 stalk_dnuuid l "Stalk Id"}
   addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
   addUserKnob {1 leaf_dnuuid l "Leaf Id"}
   addUserKnob {26 divider1 l "" +STARTLINE}
   addUserKnob {1 twigtype l "Twig Type"}
   addUserKnob {1 leaf_label l Leaf}
   addUserKnob {1 ivy_version l Version}
   addUserKnob {43 ivy_notes l Notes}
   addUserKnob {26 divider2 l "" +STARTLINE}
   addUserKnob {1 build_label l "Build Label"}
   addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
  }
 end_group
 Switch {
  inputs 2
  which {{parent.connect_aux}}
  name Switch3
  xpos -324
  ypos 311
 }
push $N487a0c10
 Expression {
  temp_name0 xd
  temp_expr0 red-Camera1.world_matrix.3
  temp_name1 yd
  temp_expr1 green-Camera1.world_matrix.7
  temp_name2 zd
  temp_expr2 blue-Camera1.world_matrix.11
  temp_name3 Distance
  temp_expr3 "sqrt(xd*xd + yd*yd + zd*zd)"
  expr0 Distance
  expr1 Distance
  expr2 Distance
  expr3 Distance
  name Expression1
  xpos -456
  ypos -192
 }
 Grade {
  channels rgba
  blackpoint {{parent.FogFar}}
  whitepoint {{parent.FogNear}}
  gamma {{1/(parent.FogExponent+0.000000001)}}
  white_clamp true
  name Grade1
  xpos -456
  ypos -168
 }
push $N53cedac0
 Dot {
  name Dot7
  xpos -307
  ypos -513
 }
 Merge2 {
  inputs 2
  operation multiply
  name Merge1
  xpos -341
  ypos -168
  disable {{!parent.Fog}}
 }
 Shuffle {
  name Shuffle3
  xpos -341
  ypos 8
 }
set N48681f40 [stack 0]
push $N487cbb30
 BlinkScript {
  inputs 4
  kernelSourceFile /Users/madshagbarth/Github/Nuke-Private/Blink/PointRender/Render/3D_PointRender_v15.cpp
  recompileCount 792
  ProgramGroup 1
  KernelDescription "2 \"PointRender3D\" iterate pixelWise e0ecbbf4cba39730471d23bc9f9ec846fcae1bbb869971a11b15641cf6fd5620 5 \"ppos\" Read Random \"src\" Read Random \"normals\" Read Random \"occlusion\" Read Random \"dst\" Write Random 48 \"cam_Matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== \"focallength\" Float 1 AAA4QQ== \"hapeture\" Float 1 ppvEQQ== \"format\" Int 2 AAgAAAAIAAA= \"vertexformat\" Int 2 CgAAAAoAAAA= \"Zoom\" Float 1 AACAPw== \"Filtering Method\" Int 1 AQAAAA== \"_alphaMultiplier\" Float 1 AACAPw== \"_pointRender\" Bool 1 AQ== \"_wireRender\" Bool 1 AQ== \"_facetRender\" Bool 1 AQ== \"_maxLDistance\" Float 1 AACAPw== \"_maxLConnections\" Int 1 AQAAAA== \"_maxPlexType\" Int 1 AAAAAA== \"_plexLinedefXY\" Bool 1 AA== \"_plexLinedefX\" Bool 1 AA== \"_plexLinedefY\" Bool 1 AA== \"_plexLinedefXtoY\" Bool 1 AA== \"_plexLinedefAUX\" Bool 1 AA== \"_plexConnectX\" Bool 1 AA== \"_plexConnectY\" Bool 1 AA== \"_L_gamma\" Float 1 AACAPw== \"Enable Depth of Field\" Bool 1 AA== \"samples\" Int 1 AwAAAA== \"rings\" Int 1 BQAAAA== \"focalDepth\" Float 1 AACAPw== \"_depthOfField\" Float 1 AACAQA== \"_depthMult\" Float 1 zczMPQ== \"_maxDofSize\" Float 1 AAAAQQ== \"dof_aspect\" Float 1 AACAPw== \"dof_threshold\" Float 1 AACAPw== \"dof_gain\" Float 1 AAAAAA== \"dof_bias\" Float 1 AAAAwA== \"dof_fringe\" Float 1 AAAAAA== \"_flatshading\" Bool 1 AQ== \"_backfacing\" Bool 1 AQ== \"_frontfacing\" Bool 1 AQ== \"_vertexMode\" Int 1 AAAAAA== \"_depthBuffer\" Bool 1 AQ== \"_texoffset\" Float 2 AAAAPwAAAD8= \"_pointSize\" Int 1 AQAAAA== \"_gaussigma\" Float 1 AACAPw== \"_depthOcclusion\" Bool 1 AQ== \"depthMultiplier\" Float 1 AACAPw== \"_maxLineSteps\" Float 1 AAB6RQ== \"_lineOffset\" Float 1 AACAPw== \"_lineInMultiplier\" Float 1 AACAPw== \"_lineOutMultiplier\" Float 1 AACAPw== 48 \"cam_Matrix\" 16 1 \"cam_Focal\" 1 1 \"cam_Hapeture\" 1 1 \"WHformat\" 2 1 \"Vformat\" 2 1 \"zoom\" 1 1 \"_filtering\" 1 1 \"_alphaMultiplier\" 1 1 \"_pointRender\" 1 1 \"_wireRender\" 1 1 \"_facetRender\" 1 1 \"_maxPlexDistance\" 1 1 \"_maxPlexConnections\" 1 1 \"_maxPlexType\" 1 1 \"_plexLinedefXY\" 1 1 \"_plexLinedefX\" 1 1 \"_plexLinedefY\" 1 1 \"_plexLinedefXtoY\" 1 1 \"_plexLinedefAUX\" 1 1 \"_plexConnectX\" 1 1 \"_plexConnectY\" 1 1 \"_plex_gamma\" 1 1 \"_dof_enable\" 1 1 \"_dof_samples\" 1 1 \"_dof_rings\" 1 1 \"focalDepth\" 1 1 \"_depthOfField\" 1 1 \"_depthMult\" 1 1 \"_maxDofSize\" 1 1 \"dof_aspect\" 1 1 \"dof_threshold\" 1 1 \"dof_gain\" 1 1 \"dof_bias\" 1 1 \"dof_fringe\" 1 1 \"_flatshading\" 1 1 \"_backfacing\" 1 1 \"_frontfacing\" 1 1 \"_vertexMode\" 1 1 \"_depthBuffer\" 1 1 \"_texoffset\" 2 1 \"_pointSize\" 1 1 \"_gaussigma\" 1 1 \"_depthOcclusion\" 1 1 \"depthMultiplier\" 1 1 \"_maxLineSteps\" 1 1 \"_lineOffset\" 1 1 \"_lineInMultiplier\" 1 1 \"_lineOutMultiplier\" 1 1 10 \"max_line_connections\" Int 1 1 AAAAAA== \"vRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"pRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"tRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"vWorld\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"canvasWidth\" Float 1 1 AAAAAA== \"canvasHeight\" Float 1 1 AAAAAA== \"matrixData\" Float 1 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cameraToWorld\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"worldToCamera\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "//Some basic generic functions.\ninline float Frac(float a_X)\n\{\n    return a_X-floor(a_X);\n\}\n\ninline float3 Cross(float3 A,float3 B)\n\{\n    return float3(A.y*B.z - A.z*B.y,A.z*B.x - A.x*B.z,A.x*B.y - A.y*B.x);\n\}\n\ninline float Fmax(float a_X,float b_X,float c_X)\n\{\n    return max(c_X,max(a_X,b_X));\n\}\ninline float Fmin(float a_X,float b_X,float c_X)\n\{\n    return min(c_X,min(a_X,b_X));\n\}     \n\ninline float3 mix(float3 _X,float3 _Y,float _A)\{\n  return _X*(1.0f-_A)+_Y*_A;\n\}\ninline float mix(float _X,float _Y,float _A)\{\n  return _X*(1.0f-_A)+_Y*_A;\n\}                                                                                              \n\n//This function is used to multiply a float3 by a matrix4x4\ninline float3 multVecMatrix( float3 src, float4x4 matrix)\n\{\n    float   x,y,z,w;\n\n    x = src\[0]*matrix\[0]\[0] + src\[1]*matrix\[1]\[0] +\n    src\[2]*matrix\[2]\[0] + matrix\[3]\[0];\n    y = src\[0]*matrix\[0]\[1] + src\[1]*matrix\[1]\[1] +\n    src\[2]*matrix\[2]\[1] + matrix\[3]\[1];\n    z = src\[0]*matrix\[0]\[2] + src\[1]*matrix\[1]\[2] +\n    src\[2]*matrix\[2]\[2] + matrix\[3]\[2];\n    w = src\[0]*matrix\[0]\[3] + src\[1]*matrix\[1]\[3] +\n    src\[2]*matrix\[2]\[3] + matrix\[3]\[3];\n    \n    return float3(x/w, y/w, z/w);\n\}\n\n//This function is used to calculate the screenspace coordinates.\ninline bool computePixelCoordinates( \n    const float3 pWorld, \n    float3 &pRaster, \n    const float4x4 &worldToCamera, \n    const float &canvasWidth, \n    const float &canvasHeight, \n    const int &imageWidth, \n    const int &imageHeight\n) \n\{ \n    float3 pCamera; \n    pCamera = multVecMatrix(pWorld, worldToCamera); \n    float2 pScreen; \n    pScreen.x = pCamera.x / -pCamera.z; \n    pScreen.y = pCamera.y / -pCamera.z; \n    float2 pNDC; \n    pNDC.x = (pScreen.x + canvasWidth * 0.5f) / canvasWidth; \n    pNDC.y = (pScreen.y + canvasHeight * 0.5f) / canvasHeight; \n    pRaster.x = (pNDC.x * imageWidth); \n    pRaster.y = ((pNDC.y) * imageHeight); \n    pRaster.z = -pCamera.z; \n    if (pRaster.x < 0.0f || pRaster.x > imageWidth || \n       pRaster.y < 0.0f || pRaster.y > imageHeight || pRaster.z < 0.0f) \{\n       return false;  \n    \}\n    return true;\n\} \n\n\nkernel PointRender3D : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessRandom, eEdgeClamped> ppos;    //The point position map\n  Image<eRead, eAccessRandom, eEdgeClamped> src;     //The texture map\n  Image<eRead, eAccessRandom, eEdgeClamped> normals;     //The texture map  \n  Image<eRead, eAccessRandom, eEdgeClamped> occlusion;     //The texture map \n  Image<eWrite, eAccessRandom> dst;                 //the output image\n\n  param: //Parameters available to the user\n    float4x4 cam_Matrix;    //The world matrix of the camera\n    float cam_Focal;        //The focal length of the camera\n    float cam_Hapeture;     //The horizontal apeture of the camera\n    int2 WHformat,Vformat;          //The format of the output image\n    float zoom;             //A \"post\" zoom function\n    int _filtering;        //Filter method\n    float _alphaMultiplier; //Additive multiplier\n    bool _pointRender,_wireRender,_facetRender;\n    float _maxPlexDistance; //Additive multiplier\n    int _maxPlexConnections;\n    int _maxPlexType; // 0==Grid, -1==Nearest\n    bool _plexLinedefXY,_plexLinedefX,_plexLinedefY,_plexLinedefXtoY,_plexLinedefAUX; // Define what connections NOT to include\n    bool _plexConnectX,_plexConnectY; //Connect from the edge of x to 0, or edge of y to 0, usually for spheres\n    float _plex_gamma; //The threshold making shorter paths bright and longer paths dark\n    bool _dof_enable; // Enable DOF\n    int _dof_samples; // How many samples per DOF ring\n    int _dof_rings; // How many rings \n    float focalDepth,_depthOfField,_depthMult,_maxDofSize; //DOF Settings\n    float dof_aspect; //Pixel aspect ratio\n    float dof_threshold;\n    float dof_gain;\n    float dof_bias; //bokeh edge bias\n    float dof_fringe; //bokeh chromatic aberration/fringing\n    bool _flatshading,_backfacing,_frontfacing; //Vertex rendering settings\n    int _vertexMode;  //The rendering output mode, (think AOV)\n    bool _depthBuffer; //Non-additive, only render front most pixel\n    float2 _texoffset;\n    int _pointSize;\n    float _gaussigma;\n    bool _depthOcclusion;\n    float depthMultiplier;\n    float _maxLineSteps; //cap the line length to avoid process lock\n    float _lineOffset; //Alow you to shrink or extend the lines\n    float _lineInMultiplier,_lineOutMultiplier; //Control the brightness of the wires at the tips.\n\n  local: //Local variables\n    int max_line_connections;\n    float3 vRaster;\n    float3 pRaster;\n    float3 tRaster;    \n    float3 vWorld;\n    float canvasWidth;\n    float canvasHeight; \n    float matrixData\[4]\[4];\n    float4x4 cameraToWorld;\n    float4x4 worldToCamera;\n\n  void define() \{\n    defineParam(cam_Matrix, \"cam_Matrix\", float4x4( 1.0f,0.0f,0.0f,0.0f,\n                                                    0.0f,1.0f,0.0f,0.0f,\n                                                    0.0f,0.0f,1.0f,0.0f,\n                                                    0.0f,0.0f,0.0f,1.0f));\n    defineParam(cam_Focal,      \"focallength\", 11.5f);\n    defineParam(cam_Hapeture,      \"hapeture\", 24.576f);\n    defineParam(WHformat,      \"format\", int2(2048,2048));\n    defineParam(Vformat,      \"vertexformat\", int2(10,10));\n    defineParam(zoom, \"Zoom\", 1.0f);\n    defineParam(_filtering, \"Filtering Method\", 1); \n    defineParam(_alphaMultiplier, \"_alphaMultiplier\", 1.0f);     \n    defineParam(_pointRender, \"_pointRender\", true);  \n    defineParam(_wireRender, \"_wireRender\", true);\n    defineParam(_facetRender, \"_facetRender\", true);\n    defineParam(_maxPlexDistance, \"_maxLDistance\", 1.0f);    \n    defineParam(_maxPlexConnections, \"_maxLConnections\", 1);    \n    defineParam(_maxPlexType, \"_maxPlexType\", 0); \n    defineParam(_plexLinedefXY, \"_plexLinedefXY\", false);      \n    defineParam(_plexLinedefXtoY, \"_plexLinedefXtoY\", false); //NYI\n    defineParam(_plexLinedefAUX, \"_plexLinedefAUX\", false); \n    defineParam(_plexLinedefX, \"_plexLinedefX\", false);  \n    defineParam(_plexLinedefY, \"_plexLinedefY\", false);  \n    defineParam(_plexConnectX, \"_plexConnectX\", false);      \n    defineParam(_plexConnectY, \"_plexConnectY\", false);   \n    defineParam(_plex_gamma, \"_L_gamma\", 1.0f);\n    //DOF SETTINGS   \n    defineParam(_dof_enable, \"Enable Depth of Field\", false);   \n    defineParam(_dof_samples, \"samples\", 3);    \n    defineParam(_dof_rings, \"rings\", 5);   \n    defineParam(focalDepth, \"focalDepth\", 1.0f);  \n    defineParam(_depthOfField, \"_depthOfField\", 4.0f);  \n    defineParam(_depthMult, \"_depthMult\", 0.1f);  \n    defineParam(_maxDofSize, \"_maxDofSize\", 8.0f);  \n    defineParam(dof_aspect, \"dof_aspect\", 1.0f);  \n    defineParam(dof_threshold, \"dof_threshold\", 1.0f);  \n    defineParam(dof_gain, \"dof_gain\", 0.0f);  \n    defineParam(dof_bias, \"dof_bias\", -2.0f);  \n    defineParam(dof_fringe, \"dof_fringe\", 0.0f); \n    //SHADING SETTINGS \n    defineParam(_flatshading, \"_flatshading\", true);  \n    defineParam(_vertexMode, \"_vertexMode\", 0);  \n    defineParam(_backfacing, \"_backfacing\", true);    \n    defineParam(_frontfacing, \"_frontfacing\", true);        \n    defineParam(_depthBuffer, \"_depthBuffer\", true);  \n    defineParam(_texoffset, \"_texoffset\", float2(0.5f,0.5f)); \n    defineParam(_pointSize, \"_pointSize\", 1); \n    defineParam(_gaussigma, \"_gaussigma\", 1.0f); \n    defineParam(_depthOcclusion, \"_depthOcclusion\", true); \n    defineParam(depthMultiplier, \"depthMultiplier\", 1.0f); \n    defineParam(_maxLineSteps, \"_maxLineSteps\", 4000.0f); \n    defineParam(_lineOffset, \"_lineOffset\", 1.0f); \n    defineParam(_lineInMultiplier, \"_lineInMultiplier\", 1.0f);   \n    defineParam(_lineOutMultiplier, \"_lineOutMultiplier\", 1.0f);     \n\n  \}\n\n  //The init() function is run before any calls to process().\n  void init() \{\n    max_line_connections = 80;\n    canvasWidth = ((cam_Hapeture)/cam_Focal);\n    canvasHeight = ((cam_Hapeture)/cam_Focal)*float(float(WHformat.y)/float(WHformat.x)); \n    float matrixData\[] = \{cam_Matrix\[0]\[0], cam_Matrix\[1]\[0], cam_Matrix\[2]\[0], cam_Matrix\[3]\[0], \n                          cam_Matrix\[0]\[1], cam_Matrix\[1]\[1], cam_Matrix\[2]\[1], cam_Matrix\[3]\[1], \n                          cam_Matrix\[0]\[2], cam_Matrix\[1]\[2], cam_Matrix\[2]\[2], cam_Matrix\[3]\[2], \n                          cam_Matrix\[0]\[3], cam_Matrix\[1]\[3], cam_Matrix\[2]\[3], cam_Matrix\[3]\[3]\};\n    cameraToWorld.setArray(matrixData); //This is a workaround. Due to the buggy matrix implementation, we pass the matrix on from another structure.\n    worldToCamera = cameraToWorld.invert();\n  \}\n\n  //Convert a 3d point position into a 2d raster position.\n  float3 Reconsile3D(float3 _PointPos)\{\n      vWorld = float3(_PointPos.x,_PointPos.y,_PointPos.z)*(zoom);\n      int ret = computePixelCoordinates(vWorld, tRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1]);\n      return tRaster;\n  \}\n\n//------------------------------\n//-------DRAW FUNCTIONS---------\n//------------------------------\n  //Write pixels to output.\n  void writepixel(float posx,float posy, float4 color,int index,float weight=1.0f)\n  \{ \n      if (_depthOcclusion)\{\n        float4 depthSample = occlusion(posx,posy);\n        if (depthSample.x<=vRaster.z && depthSample.w>0.0f)\{\n\n          float depth = (vRaster.z-depthSample.x);\n          color = color*(1.0f-depthSample.w);\n          color = color / (((depth*depth)*depthMultiplier)+1.0f);\n          //return;\n        \}\n      \}\n      float4 finalOutput; //This is used to store the final output\n      float4 dstSample; //This is used to store a sample of the destination\n      if ( dst.bounds.inside( posx, posy ) ) \{ //Test if the pixel written to is inside the output image. \n        if (_depthBuffer) \{\n          dstSample = (float4)dst(posx,posy); //Sample the destination image\n          if ((dstSample.w>color.w)||dstSample.w==0.0f) \{\n            dst(posx,posy) = color;\n          \}\n        \}\n        else \{\n          dstSample = (float4)dst(posx,posy); //Sample the destination image\n          finalOutput = dstSample + (color*_alphaMultiplier*weight);\n          finalOutput.w = dstSample.w + ((color.w*_alphaMultiplier*weight));\n\n          finalOutput.w = (dstSample.w + ((color.w*_alphaMultiplier*weight)))-(dstSample.w * ((color.w*_alphaMultiplier*weight)));\n\n          dst(posx,posy) = finalOutput;\n        \}\n      \} \n  \}\n\n  //Calculate a Bilinear Plot\n  void bilinear_Plot(float2 temppos,float4 color,int index)\n  \{\n    float2 p;\n    p.x=Frac(temppos.x);\n    p.y=Frac(temppos.y);\n    float weights\[] = \{(1.0f-p.x)*(1.0f-p.y), p.x*(1.0f-p.y), (1.0f-p.x)*p.y, p.x*p.y\};\n    int2 _position = int2(floor(temppos.x)-0,floor(temppos.y)-0); \n    writepixel(_position.x,_position.y,color,index,weights\[0]);\n    writepixel(_position.x+1,_position.y,color,index,weights\[1]);\n    writepixel(_position.x,_position.y+1,color,index,weights\[2]);\n    writepixel(_position.x+1,_position.y+1,color,index,weights\[3]);\n  \}\n\n  //NYI, unused!\n  void gaussian(float2 temppos,float4 color,int index)\{\n    float in_x = temppos.x;\n    float in_y = temppos.y;\n    int kernelSize = (_pointSize+1)*2;\n    int subsize = (kernelSize /2)-1;\n    float gKernel\[64]\[64];\n    float sigma = _gaussigma;\n    float intSigma = float(_pointSize);\n    float r, s = intSigma * sigma * sigma;\n\n    float sum = 0.0f;\n\n    // generate 5x5 kernel\n    for (int x = -subsize; x <= subsize; x++)\n    \{\n        for(int y = -subsize; y <= subsize; y++)\n        \{\n            r = float(sqrt(x*x + y*y));\n            gKernel\[x + subsize]\[y + subsize] = (exp(-(r*r)/s))/(3.141592654f * s);\n            sum += gKernel\[x + subsize]\[y + subsize];\n        \}\n    \}\n\n    // normalize the Kernel\n    for (int x = -subsize; x <= subsize; x++)\n    \{\n        for(int y = -subsize; y <= subsize; y++)\n        \{\n            gKernel\[x + subsize]\[y + subsize] /= sum;\n            writepixel(in_x+x,in_y+y,color,index,gKernel\[x + subsize]\[y + subsize]);\n        \}\n    \}\n  \}\n\n//-------------------------------------\n// DrawLine\n// ----------\n// Draw a line between two points, \n// x,y being 2d screenspace pos and z being depth.\n//-------------------------------------\n  void DrawLine(float3 origin, float3 endpoint,float4 _colorA,float4 _colorB) \{\n    float4 _color;\n    float3 delta = origin-endpoint;\n    float3 curPoint = origin;\n    float mag = sqrt(delta.x*delta.x+delta.y*delta.y);\n    mag = min(mag,_maxLineSteps); //Lets not go crazy, we cap it at 10.000 to avoid insane unwated processing time \n    for( float a = 0; a < mag*_lineOffset; a = a + 1.0f )\{\n      curPoint -= (delta/mag);\n      _color = (_colorA*(1.0f-(a/mag*1.0f)))+(_colorB*(a/mag*1.00f));\n      if (_dof_enable)\{\n        Bokeh(curPoint,_color);\n      \}\n      else \{\n        bilinear_Plot(float2(curPoint.x,curPoint.y),_color,1);\n      \}\n      \n    \}\n  \}\n\n//-------------------------------------\n// Point_Render\n//-------------------------------------\nvoid point_render(int2 pos, float3 screen_pos)\{\n  float4 color = src(pos.x,pos.y);\n\n  if (_filtering == 1)\{\n      if (_dof_enable)\{\n        Bokeh(screen_pos,color);\n      \}\n      else \{\n        bilinear_Plot(float2(screen_pos.x,screen_pos.y),color,1);\n      \}\n  \}\n  /*\n  //THIS PART NEEDS TO BE RE-WRITTEN.\n  else if (_filtering == 2)\{ \n      if (_dof_enable)\{\n        Bokeh(screen_pos,color);\n      \}\n      else \{\n        gaussian(float2(screen_pos.x,screen_pos.y),color,1);\n      \}\n  \}\n  */\n  else \{\n      int2 _position = int2(floor(screen_pos.x),floor(screen_pos.y)); \n      if (_depthBuffer) \{color.w = screen_pos.z;\}\n      writepixel(_position.x,_position.y, color,1,1.0f); //OutputSample\n  \}\n\n\}\n\n//-------------------------------------\n// Facet_Render\n//-------------------------------------\n//This function is used to calculate what triangels to draw\nvoid facet_render(int2 pos, float3 _vWorld)\{\n\n    float3 screen_pos = Reconsile3D(_vWorld);\n\n    bool insideX = ppos.bounds.inside(pos.x+1,pos.y );\n    bool insideY = ppos.bounds.inside(pos.x+1,pos.y-1 );\n    bool insideYtop = ppos.bounds.inside(pos.x,pos.y+1);\n    float2 fpos = float2(pos.x,pos.y);\n    float3 V1_Pos,V2_Pos,V1_wPos,V2_wPos,V0_N,V1_N,V2_N;\n    float2 V0_ST,V1_ST,V2_ST;\n    float4 V1_Sample,V2_Sample;\n    float4 _tn;\n    float3 normal0,normal1,normal2;\n    float2 UV_Format = float2(Vformat.x,Vformat.y);\n\n\n    int2 P0 = int2(pos.x-1,pos.y-1);\n    int2 P1 = int2(pos.x+1,pos.y+1);\n    if (_plexConnectX && pos.x == int(Vformat.x))\{\n      insideX == true;\n      P1 = int2(0.0f,pos.y+1);\n    \}\n    if (_plexConnectY && pos.y == int(Vformat.y))\{\n      insideYtop == true;\n      P1 = int2(pos.x+1,0);\n    \} \n\n    if (_plexConnectY && pos.y == 0)\{\n      insideY == true;\n      P0 = int2(pos.x-1,int(UV_Format.y));\n    \} \n\n    if (!_flatshading) \{\n      _tn = normals(pos.x,pos.y);\n      V0_N =float3(_tn.x,_tn.y,_tn.z);\n    \}\n    V0_ST = float2(pos.x,pos.y)/UV_Format;\n\n  if (insideX) \{\n    V2_Sample = ppos(P1.x,pos.y);\n    V2_ST = float2(P1.x,pos.y)/UV_Format;\n    V2_wPos = float3(V2_Sample.x,V2_Sample.y,V2_Sample.z);\n    V2_Pos = Reconsile3D(V2_wPos);\n    if (!_flatshading) \{\n      _tn = normals(P1.x,pos.y);\n      V2_N =float3(_tn.x,_tn.y,_tn.z);\n    \}\n        \n\n    if (V2_Sample.w != 0.0f) \{ \n\n      if (insideY) \{\n        V1_Sample = ppos(P1.x,P0.y);\n        V1_ST = float2(P1.x,P0.y)/UV_Format;\n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (!_flatshading) \{\n          _tn = normals(P1.x,P0.y);\n          V1_N =float3(_tn.x,_tn.y,_tn.z);\n        \}\n        if (V1_Sample.w != 0.0f) \{ \n          DrawTriangle(screen_pos,V2_Pos,V1_Pos,_vWorld,V2_wPos,V1_wPos,V0_N,V2_N,V1_N,V0_ST,V2_ST,V1_ST);\n        \}\n      \}\n      if (insideYtop) \{\n        V1_Sample = ppos(pos.x,P1.y);\n        V1_ST = float2(pos.x,P1.y)/UV_Format;        \n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (!_flatshading) \{\n          _tn = normals(pos.x,P1.y);\n          V1_N =float3(_tn.x,_tn.y,_tn.z);\n        \}        \n        if (V1_Sample.w != 0.0f) \{ \n          DrawTriangle(screen_pos,V1_Pos,V2_Pos,_vWorld,V1_wPos,V2_wPos,V0_N,V1_N,V2_N,V0_ST,V1_ST,V2_ST);\n        \}\n      \}\n    \}\n  \}\n\}\n\n\n\n//This function will calculate if pixel C is inside the triangle\nfloat edgeFunction(float3 a, float3 b, float3 c) \n\{ \n    return ((c.x - a.x) * (b.y - a.y) - (c.y - a.y) * (b.x - a.x)); \n\} \n\nfloat3 CalculateSurfaceNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat3 CalculateVertexNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat Distance(float3 _a,float3 _b)\n\{\n          float xd = _a.x - _b.x;\n          float yd = _a.y - _b.y;\n          float zd = _a.z - _b.z;\n          return sqrt(xd*xd + yd*yd + zd*zd);\n\}\n\nvoid DrawTriangle(float3 V0, float3 V1, float3 V2,float3 WP0, float3 WP1, float3 WP2,float3 N0, float3 N1, float3 N2, float2 st0,float2 st1,float2 st2) \{\n\n  // Precompute reciprocal of vertex z-coordinate \n  V0.z = 1.0f / V0.z, V1.z = 1.0f / V1.z, V2.z = 1.0f / V2.z; \n\n  float2 st0n = st0 * V0.z;\n  float2 st1n = st1 * V1.z; \n  float2 st2n = st2 * V2.z; //Normal version of ST\n\n  bool inside; \n  float X0 = Fmin(V0.x,V1.x,V2.x)-1.0f;\n  float X1 = Fmax(V0.x,V1.x,V2.x)+1.0f;\n  float Y0 = Fmin(V0.y,V1.y,V2.y)-1.0f;\n  float Y1 = Fmax(V0.y,V1.y,V2.y)+1.0f;\n  float area = edgeFunction(V2, V1, V0);\n\n\n  float2 sampos = float2(st0.x*float(Vformat.x),st0.y*float(Vformat.y));\n  float4 text0 = src(sampos.x,sampos.y);\n  sampos = float2(st1.x*float(Vformat.x),st1.y*float(Vformat.y));\n  float4 text1 = src(sampos.x,sampos.y);\n  sampos = float2(st2.x*float(Vformat.x),st2.y*float(Vformat.y));  //Why do we have to do this? =(\n  float4 text2 = src(sampos.x,sampos.y);\n  sampos = float2(min(min(st0.x,st1.x),st2.x)*float(Vformat.x),min(min(st0.y,st1.y),st2.y)*float(Vformat.y));\n  float4 text3 = src(sampos.x,sampos.y);\n\n\n  for( int x = X0; x < X1 ; x++) \{\n    for( int y = Y0; y < Y1 ; y++) \{\n      float3 pixelSample(x + _texoffset.x, y + _texoffset.y,0.0f); \n\n      //This is the part where we test if the current pixel is inside the triangle\n      //We check both for front facing and back faing options\n      float w0 = edgeFunction(V1, V0, pixelSample); //Front Facing\n      float w1 = edgeFunction(V2, V1, pixelSample); \n      float w2 = edgeFunction(V0, V2, pixelSample); \n      float w3 = edgeFunction(V0, V1, pixelSample); //Back Facing\n      float w4 = edgeFunction(V1, V2, pixelSample); \n      float w5 = edgeFunction(V2, V0, pixelSample);\n\n      //writepixel(x,y, float4(w1),1,1.0f);\n      if ((w0 >= 0 && w1 >= 0 && w2 >= 0 && _frontfacing) || (w3 >= 0 && w4 >= 0 && w5 >= 0 && _backfacing)) \{ //The curent pixel is inside the triangle\n\n       // calculate vectors from point f to vertices p1, p2 and p3:\n       float3 f1 = V0-pixelSample;\n       float3 f2 = V1-pixelSample;\n       float3 f3 = V2-pixelSample;\n       // calculate the areas and factors (order of parameters doesn't matter):\n       float a = length(cross(V0-V1,V0-V2 )); // main triangle area a\n       area = length(V0-V1)+length(V0-V2)+length(V1-V2);\n\n        w0 /= area; \n        w1 /= area; \n        w2 /= area; \n\n        w3 /= area; \n        w4 /= area; \n        w5 /= area; \n\n       float a1 = length(cross(f2, f3)) / a; // p1's triangle area / a\n       float a2 = length(cross(f3, f1)) / a; // p2's triangle area / a \n       float a3 = length(cross(f1, f2)) / a; // p3's triangle area / a\n       float a_magnitude = a1+a2+a3;\n       a1 = a1/a_magnitude;\n       a2 = a2/a_magnitude;\n       a3 = a3/a_magnitude;\n       float z = 1.0f / (V0.z * a1 + V1.z * a2 + V2.z * a3); \n\n\n        // find the uv corresponding to point f (uv1/uv2/uv3 are associated to p1/p2/p3):\n        float2 uv = st0 * a1 + st1 * a2 + st2 * a3;\n        float2 st = st0 * w0 + st1 * w1 + st2 * w2; \n        st *= z;      \n\n\n        //Calculate normals. Eighter we have flat shading, else we calculate a normal per pixel\n        float3 normalB;\n        if (_flatshading) \{\n          normalB = CalculateSurfaceNormals(WP0,WP1,WP2);\n\n        \}\n        else \{\n          float3 c0 = N2/float3(V0.z); \n          float3 c1 = N0/float3(V1.z); \n          float3 c2 = N1/float3(V2.z);  \n\n          normalB.x = w0 * c0.x + w1 * c1.x + w2 * c2.x; \n          normalB.y = w0 * c0.y + w1 * c1.y + w2 * c2.y; \n          normalB.z = w0 * c0.z + w1 * c1.z + w2 * c2.z; \n\n          normalB.x *= z, normalB.y *= z, normalB.z *= z; \n        \}\n        normalB = normalize(normalB);\n\n        //CALCULATE THE OBJECT TEXTURE COORDINATES\n        float zn = 1.0f / (V0.z * w0 + V1.z * w1 + V2.z * w2); \n        st = st0n * w0 + st1n * w1 + st2n * w2; \n        st *= zn;   \n        //--END \n\n        float3 Wpos = WP0*a1 + WP1*a2 + WP2*a3; //World Position.\n        float3 ViewNormal = normalize(float3(cameraToWorld\[3]\[0],cameraToWorld\[3]\[1],cameraToWorld\[3]\[2])-Wpos);\n\n        float nDotView =  dot(normalB,ViewNormal);\n        nDotView = 1.0f-fabs(nDotView); //make sure that the view normal ramps back around when doing backface\n        float4 tempout;\n\n        //Flatshading or regular?\n        if (!_flatshading) \{\n          tempout = text0 * a1 + text1 * a2 + text2 * a3; \n        \}\n        else\{\n          tempout = text3;\n        \}\n\n        //Additional Render Modes\n        if (_vertexMode == 1)\{\n          tempout = float4(a1,a2,a3,1.0f);\n        \}\n        else if (_vertexMode == 2)\{\n          tempout = float4(normalB.x,normalB.y,normalB.z,1.0f);\n        \}\n        else if (_vertexMode == 3)\{\n          tempout = float4(nDotView,nDotView,nDotView,1.0f);\n        \}\n        else if (_vertexMode == 4)\{\n          tempout = float4(uv.x,uv.y,0.0f,1.0f);\n        \}       \n        else if (_vertexMode == 5)\{\n          tempout = float4(st.x,st.y,0.0f,1.0f);\n        \}               \n        else if (_vertexMode == 6)\{\n          tempout = float4(ViewNormal.x,ViewNormal.y,ViewNormal.z,1.0f);\n        \}             \n        else if (_vertexMode == 7)\{\n          tempout = float4(Wpos.x,Wpos.y,Wpos.z,1.0f);\n        \}   \n\n        if (_depthBuffer)\{\n          writepixel(x,y, float4(tempout.x,tempout.y,tempout.z,z),1,1.0f);  \n        \}\n        else \{\n          if (_dof_enable)\{\n            Bokeh(float3(x,y,z),float4(tempout.x,tempout.y,tempout.z,z));\n          \}\n          else \{\n            bilinear_Plot(float2(x,y),float4(tempout.x,tempout.y,tempout.z,z),1);\n          \}\n        \}\n\n      \}  \n\n    \}\n  \}\n\}\n\n//-------------------------------------\n// Wire_Render\n//-------------------------------------\nvoid wire_render(int2 pos) \{\n  float4 temp = float4(0.0f,0.0f,0.0f,FLT_MAX);\n  float4 wire_ref_sample;\n  int2 tempXY = int2(0,0);\n  float4 plexlist\[11] = \{temp,temp,temp,temp,temp,temp,temp,temp,temp,temp,temp\}; \n  int2 plexlistXY\[11] = \{tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY\};\n  int plex_count = 0; //We use this to figure how many points that should connect.\n  float plex_dist;\n  float3 plex_position,plex_position_b;\n  float4 temp_pos, temp_pos_b; //Temporary Position Containers\n  if (_maxPlexType == -1) \{ //Used for random connection types\n    for( int x = 0; x < max_line_connections ; x++)\{ //THIS 80 NUMBER IS THE LIMIT TO AVOID TOO SLOW PROCESSING!\n      for( int y = 0; y < max_line_connections ; y++)\{\n        wire_ref_sample = ppos(x,y);\n        if (wire_ref_sample.w != 0.0f && pos.x!=x && pos.y != y) \{ \n          plex_position = float3(wire_ref_sample.x,wire_ref_sample.y,wire_ref_sample.z)*(zoom);\n          float xd = plex_position.x - vWorld.x;\n          float yd = plex_position.y - vWorld.y;\n          float zd = plex_position.z - vWorld.z;\n          float plex_dist = sqrt(xd*xd + yd*yd + zd*zd);\n          if (plex_dist<_maxPlexDistance)\{\n            plex_count = min(10,plex_count+1); //Add one to the count\n            for( int h = 0; h < plex_count+1 ; h++) \{ //Loop thought all the points. If the distance is shorter then insert it into the array and push the rest of the array down\n              if (plex_dist < plexlist\[h].w) \{                  \n                for( int i = plex_count+1; i > h ; i--) \{\n                  plexlist\[i] = plexlist\[i-1];\n                  plexlistXY\[i] = plexlistXY\[i-1];\n                \}\n                plexlist\[h] = float4(plex_position.x,plex_position.y,plex_position.z,plex_dist);\n                plexlistXY\[h] = int2(x,y);\n                break;        \n              \}\n            \}\n          \} \n        \}\n      \}\n    \}\n  \}\n  else\{ //Used for standard connection types\n    float4 temp_pos;\n    bool insideX = !(Vformat.x < pos.x+1);\n    bool insideY = !(Vformat.y < pos.y+1);\n\n\n    if (!_plexLinedefAUX)\{\n      temp_pos = normals(pos.x,pos.y);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,vWorld+plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    if ( insideX && !_plexLinedefX) \{\n      temp_pos = ppos(pos.x+1,pos.y );\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && !_plexLinedefX) \{\n      temp_pos = ppos(0,pos.y);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    if ( insideY && !_plexLinedefY) \{\n      temp_pos = ppos(pos.x,pos.y+1);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\}                          \n    \}\n    else if ( _plexConnectY  && !_plexLinedefY) \{\n      temp_pos = ppos(pos.x,0);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    //_plexConnect\n    if ( insideX && insideY && !_plexLinedefXY) \{              \n      temp_pos = ppos(pos.x+1,pos.y+1);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && _plexConnectY && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && insideY && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectY && insideX && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n  \}   \n\n  //now that all the connections have been sorted by distance then we connect the dots.\n  for( int x = 0; x < min(_maxPlexConnections,plex_count) ; x++)\{\n    plex_position = float3(plexlist\[x].x,plexlist\[x].y,plexlist\[x].z);\n    plex_dist = plexlist\[x].w;\n\n\n    float plex_distribution = 1.0f-((plexlist\[x].w-plexlist\[0].w)/((plexlist\[min(_maxPlexConnections,plex_count)].w-plexlist\[0].w)+0.00001f)); //Where does it lie between the best and the worst distance?\n    //plexlistXY\n\n    float4 plex_col = float4(pow(1.0f-(plex_dist/_maxPlexDistance),1.0f/_plex_gamma))*float4(plex_distribution); //This one is quite cool aswell, but does leave the center ones a bit too focused \n    float4 plex_colorA = src(pos.x,pos.y);\n    float4 plex_colorB = src( plexlistXY\[x].x,plexlistXY\[x].y);\n    plex_col *= 0.1f;\n\n    computePixelCoordinates(plex_position, pRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1]);\n    if (dst.bounds.inside(int(vRaster.x),int(vRaster.y)) || dst.bounds.inside(int(pRaster.x),int(pRaster.y)))\{\n        DrawLine(vRaster,pRaster,(plex_colorA*plex_col)*_lineInMultiplier,(plex_colorB*plex_col)*_lineOutMultiplier);\n    \}\n  \}\n\}\n\nvoid wire_connection(float3 p_source,float3 p_target, float4 (&p_plexlist)\[11], int2 (&p_plexlistXY)\[11],int &p_plexcount,int2 position) \{\n  float xd = p_target.x - p_source.x;\n  float yd = p_target.y - p_source.y;\n  float zd = p_target.z - p_source.z;\n  float plex_dist = sqrt(xd*xd + yd*yd + zd*zd);\n  if (plex_dist<_maxPlexDistance)\{\n    p_plexcount = min(11,p_plexcount+1); //Add one to the count\n    for( int h = 0; h < p_plexcount+1 ; h++) \{ //Loop thought all the points. If the distance is shorter then insert it into the array and push the rest of the array down\n      if (plex_dist < p_plexlist\[h].w) \{                  \n        for( int i = p_plexcount+1; i > h ; i--) \{\n          p_plexlist\[i] = p_plexlist\[i-1];\n          p_plexlistXY\[i] = p_plexlistXY\[i-1];\n        \}\n        p_plexlist\[h] = float4(p_target.x,p_target.y,p_target.z,plex_dist);\n        p_plexlistXY\[h] = int2(position.x,position.y);\n        break;        \n      \}\n    \}  \n  \}\n\}\n//-------END OF WIRE RENDER FUNCTIONS---------\n\n\n\n\n//-------------------------------\n//-------BOKEH FUNCTIONS---------\n//thanks to: http://devlog-martinsh.blogspot.dk/2011/11/glsl-depth-of-field-with-bokeh-v21.html\nfloat2 rand(float2 coord) //generating noise/pattern texture for dithering\n\{\n  float noiseX = ((Frac(1.0-coord.x*(WHformat\[0]/2.0))*0.25)+(Frac(coord.y*(WHformat\[1]/2.0))*0.75))*2.0-1.0;\n  float noiseY = ((Frac(1.0-coord.x*(WHformat\[0]/2.0))*0.75)+(Frac(coord.y*(WHformat\[1]/2.0))*0.25))*2.0-1.0;\n  noiseX = clamp(Frac(sin(dot(coord ,float2(12.9898f,78.233f))) * 43758.5453f),0.0f,1.0f)*2.0f-1.0f;\n  noiseY = clamp(Frac(sin(dot(coord ,float2(12.9898f,78.233f)*2.0f)) * 43758.5453f),0.0f,1.0f)*2.0-1.0f;\n  return float2(noiseX,noiseY);\n\}\n//-------------------------------------\n// Bokeh\n//-------------------------------------\nvoid Bokeh(float3 pos,float4 color)\{\n  float blur = 0.0;\n  blur = clamp((fabs(pos.z - focalDepth)/_depthOfField)*100.0f,-_maxDofSize,_maxDofSize);\n  \n  float w = (1.0/WHformat.x)*blur;//+noise.x;\n  float h = (1.0/(WHformat.x*dof_aspect))*blur;//+noise.y;\n  float3 v3_col = float3(color.x,color.y,color.z);\n  int ringsamples;\n  float s = 1.0;  \n\n  for (int i = 1; i <= _dof_rings; i += 1)\n  \{   \n    ringsamples = i * _dof_samples; \n    for (int j = 0 ; j < ringsamples ; j += 1)  \n    \{ \n      s += (1.0f*mix(1.0f,(float(i))/(float(_dof_rings)),dof_bias)*1.0f); //No need to do this in the loop\n    \}\n  \}\n\n  for (int i = 1; i <= _dof_rings; i += 1)\n  \{   \n    ringsamples = i * _dof_samples;\n     \n    for (int j = 0 ; j < ringsamples ; j += 1)   \n    \{\n      float step = PI*2.0 / float(ringsamples);\n      float pw = (cos(float(j)*step)*(float(i)/_dof_rings));\n      float ph = (sin(float(j)*step)*(float(i)/_dof_rings));\n      float p = 1.0;\n\n      float posx = pos.x+((pw*w)*blur);\n      float posy = pos.y+((ph*h)*blur);\n\n\n      float3 lumcoeff = float3(0.299,0.587,0.114);\n      float lum = dot(v3_col, lumcoeff);\n      float thresh = max((lum-dof_threshold)*dof_gain, 0.0f);\n      v3_col+mix(float3(0.0),v3_col,thresh*blur);\n\n      float3 col = (v3_col*mix(1.0,(float(i))/(float(_dof_rings)),dof_bias)*p)/s; \n      bilinear_Plot(float2(posx,posy),float4(col.x,col.y,col.z,color.w/(_dof_rings*_dof_rings)),1);\n    \}\n  \}\n\}\n//-------END OF BOKEH FUNCTIONS---------\n\n\n\n//-------------------------------------\n// Process\n//-------------------------------------\n  void process(int2 pos) \{\n    float4 _sample = ppos(pos.x,pos.y); //Get the XYZ Coordinates\n    float2 posf = float2(pos.x,pos.y);\n\n    if (_sample.w != 0.0f) \{  //No need to process if there is no data.\n\n      //Convert worldspace coordinates to screenspcace coordinates.\n      vWorld = float3(_sample.x,_sample.y,_sample.z)*(zoom);\n      int ret = computePixelCoordinates(vWorld, vRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1]);\n      if (ret) \{ //Only create points that are visible on screen\n        if (_pointRender)\{\n          point_render(pos,vRaster);\n        \}\n      \} //Pointrender over\n\n      if (_wireRender && _maxPlexConnections>=1) \{\n        if (max(pos.x,pos.y)<=max_line_connections || (_maxPlexType==0))\{ // Don't process more wires than allowed in nearest mode.\n          wire_render(pos);\n        \}\n      \} //WireRender over\n\n      if (_facetRender) \{\n        facet_render(pos,float3(_sample.x,_sample.y,_sample.z));\n      \}  //FacetRender over\n      \n    \}\n  \} //----> process\n\};\n"
  useGPUIfAvailable false
  rebuild ""
  PointRender3D_cam_Matrix {
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
    }
  PointRender3D_focallength {{parent.Camera1.focal}}
  PointRender3D_hapeture {{parent.Camera1.haperture}}
  PointRender3D_format {{Settings_Format.width} {Settings_Format.height}}
  PointRender3D_vertexformat {{parent.InputFormat.box.r-1} {parent.InputFormat.box.t-1}}
  PointRender3D__alphaMultiplier {{parent.AlphaMultiplier}}
  PointRender3D__pointRender {{parent.RenderMode==0}}
  PointRender3D__wireRender {{parent.RenderMode==1}}
  PointRender3D__facetRender {{parent.RenderMode==2}}
  PointRender3D__maxLDistance {{parent.wire_maxdistance}}
  PointRender3D__maxLConnections {{parent.wire_connections}}
  PointRender3D__maxPlexType {{-parent.wire_type}}
  PointRender3D__plexLinedefXY {{!parent.connect_xy}}
  PointRender3D__plexLinedefX {{!parent.connect_x}}
  PointRender3D__plexLinedefY {{!parent.connect_y}}
  PointRender3D__plexLinedefAUX {{!connect_aux}}
  PointRender3D__plexConnectX {{parent.CloseX}}
  PointRender3D__plexConnectY {{parent.CloseY}}
  PointRender3D__L_gamma {{parent.wire_Threshold}}
  "PointRender3D_Enable Depth of Field" {{parent.dof_enable}}
  PointRender3D_samples {{3*(parent.Dof_Quality*parent.Dof_Quality+1)}}
  PointRender3D_rings {{3*(parent.Dof_Quality*parent.Dof_Quality+1)}}
  PointRender3D_focalDepth {{parent.dof_focaldepth}}
  PointRender3D__depthOfField {{parent.dof_dof}}
  PointRender3D__depthMult {{parent.DofMultiplier}}
  PointRender3D__maxDofSize {{parent.dof_maxSize*400}}
  PointRender3D_dof_aspect {{parent.dof_Aspect}}
  PointRender3D_dof_bias {{parent.dof_bias}}
  PointRender3D__flatshading {{parent.facet_flatShading}}
  PointRender3D__backfacing {{parent.facet_backface}}
  PointRender3D__frontfacing {{parent.facet_front}}
  PointRender3D__vertexMode {{parent.renderMode}}
  PointRender3D__depthBuffer {{parent.facet_depth}}
  PointRender3D__texoffset {-0.5 0.5}
  PointRender3D__pointSize 0
  PointRender3D__depthOcclusion {{parent.UseOcclusionMap}}
  PointRender3D__maxLineSteps {{parent.maxSamples}}
  PointRender3D__lineOffset {{parent.lineoffset}}
  PointRender3D__lineInMultiplier {{parent.inGain}}
  PointRender3D__lineOutMultiplier {{parent.outGain}}
  format "1280 720 0 0 1280 720 1 HD_720"
  rebuild_finalise ""
  name BlinkScript1
  selected true
  xpos -27
  ypos 159
 }
 Reformat {
  format {{{Settings_Format.format}}}
  resize none
  center false
  name Reformat1
  xpos -27
  ypos 343
 }
 Group {
  name SoftLook
  xpos -27
  ypos 460
  disable {{!parent.HighlightCompression}}
  addUserKnob {20 User}
  addUserKnob {26 ""}
  addUserKnob {7 Add R 0 4}
  Add {{parent.HighlightCeiling}}
  addUserKnob {7 Offset R 0 4}
  Offset {{parent.Compression}}
 }
  Input {
   inputs 0
   name Input1
   xpos -248
   ypos 500
  }
set N486bc5f0 [stack 0]
  Expression {
   expr0 r/(r+parent.Offset)*parent.Add
   expr1 g/(g+parent.Offset)*parent.Add
   expr2 b/(b+parent.Offset)*parent.Add
   expr3 a/(a+parent.Offset)*parent.Add
   name Expression1
   xpos -339
   ypos 576
  }
push $N486bc5f0
  ShuffleCopy {
   inputs 2
   red red
   green green
   blue blue
   alpha alpha2
   name ShuffleCopy1
   xpos -248
   ypos 576
  }
  Output {
   name Output1
   xpos -248
   ypos 651
  }
 end_group
 TimeBlur {
  divisions {{parent.Samples}}
  shutter {{parent.Shutter}}
  shutteroffset centred
  shuttercustomoffset 0
  name MotionBlur
  xpos -27
  ypos 581
  disable {{1-parent.mb_enable x89 0}}
 }
 ShuffleCopy {
  inputs 2
  in pos
  red red
  green green
  blue blue
  out pos
  name ShuffleCopy1
  xpos -27
  ypos 673
  disable true
 }
 Output {
  name Output1
  xpos -27
  ypos 710
 }
 Input {
  inputs 0
  name InputCamera
  xpos -1129
  ypos 116
  number 1
 }
 Camera2 {
  focal {{parent.FocalLength}}
  haperture {{parent.horizontalApeture}}
  name Camera1
  xpos -1119
  ypos 223
  addUserKnob {20 Ivy}
  addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.toolbox.v1.nodes.docs', fromlist=\['open_docs_name']).open_docs_name('IvyTab')" +STARTLINE}
  addUserKnob {26 divider4 l "" +STARTLINE}
  addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
  _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
  addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
  addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
  addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
  _expressions {{curve}}
  addUserKnob {26 divider0 l "" +STARTLINE}
  addUserKnob {20 dbinfo l "DB Info" n 1}
  dbinfo 0
  addUserKnob {1 twig_dnuuid l "Twig Id"}
  addUserKnob {1 stalk_dnuuid l "Stalk Id"}
  addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
  addUserKnob {1 leaf_dnuuid l "Leaf Id"}
  addUserKnob {26 divider1 l "" +STARTLINE}
  addUserKnob {1 twigtype l "Twig Type"}
  addUserKnob {1 leaf_label l Leaf}
  addUserKnob {1 ivy_version l Version}
  addUserKnob {43 ivy_notes l Notes}
  addUserKnob {26 divider2 l "" +STARTLINE}
  addUserKnob {1 build_label l "Build Label"}
  addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
 }
 Reformat {
  inputs 0
  format "2156 1806 0 0 2156 1806 2 JOYRIDE Working"
  resize none
  center false
  name Settings_Format
  xpos -1404
  ypos 241
 }
push $N48681f40
 PositionToPoints2 {
  display textured
  render_mode textured
  P_channel pos
  detail 0.25
  pointSize 0.6
  name PreviewNode
  xpos -22
  ypos 8
  disable {{!parent.Enable3DPreview}}
 }
push $N53c6c9c0
 Reformat {
  type "to box"
  box_width 100
  box_height 100
  box_fixed true
  scale 0.1
  resize none
  filter impulse
  black_outside true
  name Reformat3
  xpos -633
  ypos -1109
  disable {{!wire_type==1}}
 }
push $N53cedac0
 Crop {
  box {0 0 {width} {height}}
  reformat true
  crop false
  name InputFormat
  xpos -456
  ypos -402
 }
end_group
TimeOffset {
 time_offset -1182
 time ""
 name TimeOffset3
 selected true
 xpos 11114
 ypos 32674
}
Dot {
 name Dot300
 selected true
 xpos 11148
 ypos 32933
}
FileOut {
 name FileOut10
 tile_color 0xbfbf00ff
 label 2DsmokeFX_2
 selected true
 xpos 11114
 ypos 32993
 icon smartgrade.png
 channels rgba
 _destination /jobs
 _stemstatus ""
 file ""
 proxy ""
 fileProxy ""
 views {main}
 first 1001
 last 1400
 pbb true
 smart_grade on
 dw_compression_level 0
 tex_metadata "default metadata and exr/*"
 disable_autolabel_format true
 _defaults "\{'smart_grade': 0, 'compression': 1, 'tile_color': 3216965887, 'pbb': True, 'dw_compression_level': 0, 'label': u'2DsmokeFX_2', 'exr_metadata': 2\}"
 _format ""
 _generator "NukeRenderGenerator dnnuke.core.render.v1"
 _ivyVals "\{'variant': None, 'host': None, 'versionNum': '1', 'twigType': 'spider://query@TwigType.one?TwigType.code==2d', 'twigNameTags': \{'subtask': u'precomp', 'task': u'comp', 'label': u'2DsmokeFX_2', 'out_dir': u'ELEMENT'\}, 'job': 'STONE', 'stalk': None, 'stalkAttrs': \{'framerange': '1017-1053'\}, 'twig': None, 'stem': 'spider://query@Stem.one?Stem.dnuuid==cfb45239-1375-4623-b0a4-12b2a5fba3d0&Stem.stemname==110_fof_0010&Stem.stemtype==shot'\}"
 _old_filetype exr
 _stalkname E_110_fof_0010_comp_precomp_2DsmokeFX_2_v001
 _twigtype 2d
 _wrapper "FileOut dnnuke.nodes.file_out.wrapper"
 beforeRender ""
 beforeFrameRender ""
 afterFrameRender ""
 afterRender ""
 renderProgress ""
 _invert_grade /tools/STONE/ivyasset/110_fof_0010/ivy/grade/GRD_110_fof_0010_neutral_v001/GRD_110_fof_0010_neutral_v001.grade
}
BagAndTagKeep {
 name BagAndTagKeep5
 selected true
 xpos 11114
 ypos 33103
}
Read {
 inputs 0
 file_type exr
 file /jobs/JOYRIDE/hap0850/ELEMENT/E_hap0850_comp_precomp_2DsmokeFX_2_v001/2156x1806/E_hap0850_comp_precomp_2DsmokeFX_2_v001.####.exr
 localizationPolicy off
 format "2156 1806 0 0 2156 1806 2 JOYRIDE Working"
 proxy_format "640 480 0 0 640 480 1 PC_Video"
 first 1001
 last 1400
 origfirst 1001
 origlast 1400
 origset true
 smartGrade true
 name Read193
 selected true
 xpos 11109
 ypos 33156
 postage_stamp_frame 1200
 addUserKnob {20 Ivy}
 addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.toolbox.v1.nodes.docs', fromlist=\['open_docs_name']).open_docs_name('IvyTab')" +STARTLINE}
 addUserKnob {26 divider4 l "" +STARTLINE}
 addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
 _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
 addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
 addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
 _ivyFile /jobs/JOYRIDE/hap0850/ELEMENT/E_hap0850_comp_precomp_2DsmokeFX_2_v001/2156x1806/E_hap0850_comp_precomp_2DsmokeFX_2_v001.####.exr
 addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
 _expressions {{curve}}
 addUserKnob {26 divider0 l "" +STARTLINE}
 addUserKnob {20 dbinfo l "DB Info" n 1}
 dbinfo 0
 addUserKnob {1 twig_dnuuid l "Twig Id"}
 twig_dnuuid b592375e-0cd3-439a-8a47-1c90296c0c62
 addUserKnob {1 stalk_dnuuid l "Stalk Id"}
 stalk_dnuuid 24a3e3d1-e1d8-4399-96d8-ff511b8b5dea
 addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
 twigtype_dnuuid e9f824fa-c932-4c3e-acbd-c612fb5ea846
 addUserKnob {1 leaf_dnuuid l "Leaf Id"}
 leaf_dnuuid 072ea0f3-a0a0-47e2-bd3e-7a17291fd551
 addUserKnob {26 divider1 l "" +STARTLINE}
 addUserKnob {1 twigtype l "Twig Type"}
 twigtype elmr
 addUserKnob {1 leaf_label l Leaf}
 leaf_label main_proxy0
 addUserKnob {1 ivy_version l Version}
 ivy_version 1
 addUserKnob {43 ivy_notes l Notes}
 addUserKnob {26 divider2 l "" +STARTLINE}
 addUserKnob {1 build_label l "Build Label"}
 addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
}
BagAndTagKeep {
 name BagAndTagKeep6
 selected true
 xpos 11109
 ypos 33329
}
push $cut_paste_input
Camera2 {
 translate {5 0.1 0.07756583}
 rotate {0 87.69209641 0}
 name Camera7
 selected true
 xpos 12155
 ypos 32618
 addUserKnob {20 Ivy}
 addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.toolbox.v1.nodes.docs', fromlist=\['open_docs_name']).open_docs_name('IvyTab')" +STARTLINE}
 addUserKnob {26 divider4 l "" +STARTLINE}
 addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
 _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
 addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
 addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
 addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
 _expressions {{curve}}
 addUserKnob {26 divider0 l "" +STARTLINE}
 addUserKnob {20 dbinfo l "DB Info" n 1}
 dbinfo 0
 addUserKnob {1 twig_dnuuid l "Twig Id"}
 addUserKnob {1 stalk_dnuuid l "Stalk Id"}
 addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
 addUserKnob {1 leaf_dnuuid l "Leaf Id"}
 addUserKnob {26 divider1 l "" +STARTLINE}
 addUserKnob {1 twigtype l "Twig Type"}
 addUserKnob {1 leaf_label l Leaf}
 addUserKnob {1 ivy_version l Version}
 addUserKnob {43 ivy_notes l Notes}
 addUserKnob {26 divider2 l "" +STARTLINE}
 addUserKnob {1 build_label l "Build Label"}
 addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
}
Camera2 {
 translate {5 0.1 0.07756583}
 rotate {0 87.69209641 0}
 name Camera3
 selected true
 xpos 12155
 ypos 32618
 addUserKnob {20 Ivy}
 addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.toolbox.v1.nodes.docs', fromlist=\['open_docs_name']).open_docs_name('IvyTab')" +STARTLINE}
 addUserKnob {26 divider4 l "" +STARTLINE}
 addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
 _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
 addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
 addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
 addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
 _expressions {{curve}}
 addUserKnob {26 divider0 l "" +STARTLINE}
 addUserKnob {20 dbinfo l "DB Info" n 1}
 dbinfo 0
 addUserKnob {1 twig_dnuuid l "Twig Id"}
 addUserKnob {1 stalk_dnuuid l "Stalk Id"}
 addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
 addUserKnob {1 leaf_dnuuid l "Leaf Id"}
 addUserKnob {26 divider1 l "" +STARTLINE}
 addUserKnob {1 twigtype l "Twig Type"}
 addUserKnob {1 leaf_label l Leaf}
 addUserKnob {1 ivy_version l Version}
 addUserKnob {43 ivy_notes l Notes}
 addUserKnob {26 divider2 l "" +STARTLINE}
 addUserKnob {1 build_label l "Build Label"}
 addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
}
set N4782de30 [stack 0]
Group {
 inputs 0
 name Point_Grid8
 tile_color 0x434343ff
 note_font_color 0x7dadf9ff
 selected true
 xpos 12474
 ypos 32137
 addUserKnob {20 User}
 addUserKnob {26 text l "" +STARTLINE T "Point Grid v1.0\n\nThis node generates a grid.\nAs it is defined in a non-euclidian space, \nmost of the shaders and wire or facet rendering won't work. "}
 addUserKnob {26 ""}
 addUserKnob {41 size_x l "Number of Points" T CONTROLER.size_x}
 addUserKnob {41 size_y l "" -STARTLINE T CONTROLER.size_y}
 addUserKnob {41 size_z l "" -STARTLINE T CONTROLER.size_z}
 addUserKnob {18 Position}
 Position {0 0 0}
 addUserKnob {6 Position_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Position_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Position_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {18 Scale}
 Scale {2 4 2}
 addUserKnob {6 Scale_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Scale_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Scale_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
}
 NoOp {
  inputs 0
  name CONTROLER
  xpos 224
  ypos -62
  addUserKnob {20 User}
  addUserKnob {3 VoxelDensity}
  VoxelDensity {{ceil(pow(size_x*size_y*size_z,1/3))}}
  addUserKnob {3 size_x l "Voxel Grid Size"}
  size_x 140
  addUserKnob {3 size_y l "" -STARTLINE}
  size_y 100
  addUserKnob {3 size_z l "" -STARTLINE}
  size_z 130
 }
 Crop {
  inputs 0
  box {0 0 {ceil(sqrt(pow(parent.CONTROLER.VoxelDensity,3)))} {sqrt(pow(parent.CONTROLER.VoxelDensity,3))}}
  reformat true
  crop false
  name Crop3
  xpos 372
  ypos -108
 }
 BlinkScript {
  recompileCount 9
  ProgramGroup 1
  KernelDescription "2 \"InvertKernel\" iterate pixelWise 21048e0522d3524e03cb582229852f2e33dbe569cd86686b92f460148f8700cf 2 \"src\" Read Point \"dst\" Write Point 1 \"Cube Size\" Int 3 IAAAACAAAAAgAAAAAAAAAA== 1 \"cube_size\" 3 1 0"
  kernelSource "kernel InvertKernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;  \n  Image<eWrite> dst;\n\n  param:\n    int3 cube_size;\n\n  local:\n    \n\n  void define() \{\n    defineParam(cube_size, \"Cube Size\", int3(32,32,32));\n  \}\n\n  void init() \{\n    \n  \}\n\n  void process(int2 pos) \{\n    int t_offset = (pos.x+(pos.y*src.bounds.width()));\n    float4 position;\n    float maxSize = max(max(cube_size.x,cube_size.y),cube_size.z);\n\n    position.x = fmod(t_offset,cube_size.x)/float(cube_size.x-1);\n    position.y = fmod(int(t_offset/cube_size.x),cube_size.y)/float(cube_size.y-1);\n    position.z = fmod(int(t_offset/(cube_size.x*cube_size.y)),cube_size.z)/float(cube_size.z-1);\n    position.w = 1-min(fmod(int(t_offset/(cube_size.x*cube_size.y*cube_size.z)),maxSize),1.0f);\n\n    dst() = float4(position.x*position.w,position.y*position.w,position.z*position.w,position.w);\n   \}\n\};\n\n"
  rebuild ""
  "InvertKernel_Cube Size" {{parent.CONTROLER.size_x} {parent.CONTROLER.size_y} {parent.CONTROLER.size_z}}
  rebuild_finalise ""
  name BlinkScript8
  selected true
  xpos 372
  ypos -79
 }
 Grade {
  add -0.5
  black_clamp false
  name Grade1
  xpos 372
  ypos -47
 }
 Grade {
  white {{parent.Scale.r} {parent.Scale.g} {parent.Scale.b} 0.9}
  add {{parent.Position.r} {parent.Position.g} {parent.Position.b} 0}
  black_clamp false
  name Grade2
  xpos 372
  ypos -26
 }
 Shuffle {
  red white
  green white
  blue white
  black red
  white green
  red2 blue
  green2 alpha
  out2 pos
  name Shuffle1
  xpos 372
  ypos -2
 }
 ModifyMetaData {
  metadata {
   {set pointrender/n_points "\[expr \[value parent.size_x]*\[value parent.size_y] *\[value parent.size_z]]"}
   {set pointrender/gen_type 3}
  }
  name SetMetaData
  xpos 372
  ypos 22
 }
 Grade {
  white {{1/((parent.size_x*parent.size_y*parent.size_z)/200000)}}
  black_clamp false
  name Grade9
  xpos 372
  ypos 46
 }
 Crop {
  box {0 0 {ceil(sqrt(pow(parent.CONTROLER.VoxelDensity,3)))} {sqrt(pow(parent.CONTROLER.VoxelDensity,3))}}
  crop false
  name Crop1
  xpos 372
  ypos 70
 }
 Output {
  name Output1
  xpos 372
  ypos 149
 }
end_group
Group {
 name Fractal16
 tile_color 0x434343ff
 note_font_color 0x7dadf9ff
 selected true
 xpos 12474
 ypos 32223
 addUserKnob {20 User t test}
 addUserKnob {26 _1 l "" +STARTLINE T "Point Fractal 1.0\n"}
 addUserKnob {26 devider_noise l "<b><font color=#7DADF9>Noise Settings</font><b>"}
 addUserKnob {6 Noise_Absolute l Absolute t "Negative values in the noise offset is made positive." +STARTLINE}
 addUserKnob {3 Noise_Octaves l Octaves}
 Noise_Octaves 8
 addUserKnob {7 Noise_Gain l Gain}
 Noise_Gain 0.3
 addUserKnob {7 Noise_Lacunarity l Lacunarity R 0 4}
 Noise_Lacunarity 1.18
 addUserKnob {18 Amplitude}
 Amplitude 0.4
 addUserKnob {6 Amplitude_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Amplitude_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Amplitude_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Amplitude_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {3 Itterations}
 Itterations 5
 addUserKnob {26 invis_devider_noise l "" +STARTLINE T " "}
 addUserKnob {26 Devider_Frequency l "<b><font color=#7DADF9>Freq Control</font><b>"}
 addUserKnob {19 Freq_Offset l "General Offset" t "This is like a 3D translation, letting you move the current noise pattern in the X, Y, Z and W (4th dimention)" R 0 10}
 Freq_Offset {0 0 0 0}
 addUserKnob {6 Freq_Offset_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_Offset_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_Offset_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_Offset_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_Offset_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 Freq_GeneralScale l "Genral Scale" t "This lets you control the scale of each individual noise axis."}
 Freq_GeneralScale {1 1 1 1}
 addUserKnob {6 Freq_GeneralScale_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_GeneralScale_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_GeneralScale_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_GeneralScale_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_GeneralScale_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {26 invis_devider_freq l "" +STARTLINE T " "}
 addUserKnob {19 Freq_EvolveLow l "Evolve Low" t "This lets you evolve (auto animate) the noise in a particular direction. The \"Low\" part means that this only affects the low frequencies.\n\nTo avoid a \"scrolling\" effect you can use the 4th dimention to break up the spatial cohearence." R 0 10}
 Freq_EvolveLow {3 0 0 0.5}
 addUserKnob {6 Freq_EvolveLow_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveLow_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveLow_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveLow_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveLow_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleLow_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 Freq_EvolveHigh l "Evolve High" t "This lets you evolve (auto animate) the noise in a particular direction. The \"High\" part means that this only affects the high frequencies.\n\nTo avoid a \"scrolling\" effect you can use the 4th dimention to break up the spatial cohearence."}
 Freq_EvolveHigh {0.9 0 -1 1}
 addUserKnob {6 Freq_EvolveHigh_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveHigh_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveHigh_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveHigh_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveHigh_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {26 invis_devider_freq2 l "" +STARTLINE T " "}
 addUserKnob {19 Freq_ScaleLow l "Scale Low" t "This lets you scale the noise in a particular axis. The \"Low\" part means that this only affects the low frequencies."}
 Freq_ScaleLow {2 2 2 2}
 addUserKnob {6 Freq_ScaleLow_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleLow_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleLow_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleLow_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleLow_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 Freq_ScaleHigh l "Scale High" t "This lets you scale the noise in a particular axis. The \"High\" part means that this only affects the high frequencies."}
 Freq_ScaleHigh {2 2 2 2}
 addUserKnob {6 Freq_ScaleHigh_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleHigh_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleHigh_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleHigh_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleHigh_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {26 invis_devider_freq3 l "" +STARTLINE T " "}
 addUserKnob {26 Curve l "<b><font color=#7DADF9>Curve Noise</font><b>"}
 addUserKnob {6 CurveNoise_Enable l Enable t "Adds a gamma curve to the noise intensity making noise near the \"Offset\" value more flat. This is a experimental feature." +STARTLINE}
 addUserKnob {6 CurveNoise_Invert l Invert t "Inverts the effect of the curved noise." -STARTLINE}
 addUserKnob {7 CurveGain l "Curve Gain" R -10 10}
 CurveGain 3
 addUserKnob {7 CurveOffset R -2 2}
 addUserKnob {26 gabgen l "" +STARTLINE T "\n"}
 addUserKnob {26 info_mask l "<b><font color=#7DADF9>Mask</font><b>"}
 addUserKnob {41 maskChannelMask l "" t "If a node is connected to the mask input, this will let you mask off the effect of the noise.\nIts recommended that you use the Point_Texture node to ensure a correct aspect and size." -STARTLINE T Merge1.maskChannelMask}
 addUserKnob {41 inject -STARTLINE T Merge1.inject}
 addUserKnob {41 invert_mask l invert -STARTLINE T Merge1.invert_mask}
 addUserKnob {41 fringe -STARTLINE T Merge1.fringe}
 addUserKnob {41 mix T Merge1.mix}
}
 Input {
  inputs 0
  name InputMask
  xpos -714
  ypos 207
  number 1
 }
 Reformat {
  type "to box"
  box_width {{parent.InputFormat.box.r}}
  box_height {{parent.InputFormat.box.t}}
  box_fixed true
  resize distort
  name Reformat2
  xpos -714
  ypos 306
 }
 Shuffle {
  name Shuffle3
  xpos -714
  ypos 330
 }
 Input {
  inputs 0
  name InputData
  xpos -582
  ypos 73
 }
 Dot {
  name Dot1
  xpos -548
  ypos 114
 }
set N476e0f70 [stack 0]
 Shuffle {
  in pos
  name Shuffle1
  xpos -470
  ypos 110
 }
 BlinkScript {
  kernelSourceFile /Users/madshagbarth/Github/Nuke-Private/Blink/PointRender/Modify/Fractal_v06.cpp
  recompileCount 60
  ProgramGroup 1
  KernelDescription "2 \"Noise4D\" iterate pixelWise d54284af3e5573ad197bef9032773e8653de2cad590694fcc9fd5af993e97da3 2 \"src\" Read Point \"dst\" Write Point 17 \"absNoise\" Bool 1 AA== \"curveNoise\" Bool 1 AA== \"curveInvert\" Bool 1 AA== \"curveGain\" Float 1 AACAPw== \"curveOffset\" Float 1 AACAPw== \"Octaves\" Int 1 CgAAAA== \"Gain\" Float 1 AAAAPw== \"Lacunarity\" Float 1 AAAAQA== \"Gamma\" Float 1 AAAAPw== \"amplitude\" Float 3 AAAAPwAAAD8AAAA/AAAAAA== \"itterations\" Int 1 AQAAAA== \"Offset\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"Scale\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"suboffset\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"topoffset\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"subscale\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"topscale\" Float 4 AACAPwAAgD8AAIA/AACAPw== 17 \"absNoise\" 1 1 \"curveNoise\" 1 1 \"curveInvert\" 1 1 \"curveGain\" 1 1 \"curveOffset\" 1 1 \"octaves\" 1 1 \"gain\" 1 1 \"lacunarity\" 1 1 \"gamma\" 1 1 \"amplitude\" 3 1 \"itterations\" 1 1 \"offset\" 4 1 \"scale\" 4 1 \"suboffset\" 4 1 \"topoffset\" 4 1 \"subscale\" 4 1 \"topscale\" 4 1 0"
  kernelSource "//Based on https://github.com/Draradech/csworldgen/blob/master/simplexnoise.cpp\n//Ported by Mads Hagbarth Lund 2014\n\n/* Copyright (c) 2007-2012 Eliot Eshelman\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n\nint fastfloor( const float x ) \{ return x > 0 ? (int) x : (int) x - 1; \}\ninline float raw_noise_4d( const float x, const float y, const float z, const float w ) \n\{\nint simplex\[64]\[4] = \{\n    \{0,1,2,3\},\{0,1,3,2\},\{0,0,0,0\},\{0,2,3,1\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{1,2,3,0\},\n    \{0,2,1,3\},\{0,0,0,0\},\{0,3,1,2\},\{0,3,2,1\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{1,3,2,0\},\n    \{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\n    \{1,2,0,3\},\{0,0,0,0\},\{1,3,0,2\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{2,3,0,1\},\{2,3,1,0\},\n    \{1,0,2,3\},\{1,0,3,2\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{2,0,3,1\},\{0,0,0,0\},\{2,1,3,0\},\n    \{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\n    \{2,0,1,3\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{3,0,1,2\},\{3,0,2,1\},\{0,0,0,0\},\{3,1,2,0\},\n    \{2,1,0,3\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{3,1,0,2\},\{0,0,0,0\},\{3,2,0,1\},\{3,2,1,0\}\n\};\n    int perm\[512] = \{\n        151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,\n        8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,\n        35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,\n        134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,\n        55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208, 89,\n        18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,\n        250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,\n        189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,\n        172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,\n        228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,\n        107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,\n        138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180,\n\n        151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,\n        8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,\n        35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,\n        134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,\n        55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208, 89,\n        18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,\n        250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,\n        189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,\n        172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,\n        228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,\n        107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,\n        138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180\n    \};\n   int grad4\[32]\[4]= \{\n    \{0,1,1,1\},  \{0,1,1,-1\},  \{0,1,-1,1\},  \{0,1,-1,-1\},\n    \{0,-1,1,1\}, \{0,-1,1,-1\}, \{0,-1,-1,1\}, \{0,-1,-1,-1\},\n    \{1,0,1,1\},  \{1,0,1,-1\},  \{1,0,-1,1\},  \{1,0,-1,-1\},\n    \{-1,0,1,1\}, \{-1,0,1,-1\}, \{-1,0,-1,1\}, \{-1,0,-1,-1\},\n    \{1,1,0,1\},  \{1,1,0,-1\},  \{1,-1,0,1\},  \{1,-1,0,-1\},\n    \{-1,1,0,1\}, \{-1,1,0,-1\}, \{-1,-1,0,1\}, \{-1,-1,0,-1\},\n    \{1,1,1,0\},  \{1,1,-1,0\},  \{1,-1,1,0\},  \{1,-1,-1,0\},\n    \{-1,1,1,0\}, \{-1,1,-1,0\}, \{-1,-1,1,0\}, \{-1,-1,-1,0\}\n   \};\n    float F4 = (sqrt(5.0f)-1.0f)/4.0f;\n    float G4 = (5.0f-sqrt(5.0f))/20.0f;\n    float n0, n1, n2, n3, n4;\n    float s = (x + y + z + w) * F4;\n    int i = fastfloor(x + s);\n    int j = fastfloor(y + s);\n    int k = fastfloor(z + s);\n    int l = fastfloor(w + s);\n    float t = (i + j + k + l) * G4;\n    float X0 = i - t;\n    float Y0 = j - t;\n    float Z0 = k - t;\n    float W0 = l - t;\n\n    float x0 = x - X0;\n    float y0 = y - Y0;\n    float z0 = z - Z0;\n    float w0 = w - W0;\n    int c1 = (x0 > y0) ? 32 : 0;\n    int c2 = (x0 > z0) ? 16 : 0;\n    int c3 = (y0 > z0) ? 8 : 0;\n    int c4 = (x0 > w0) ? 4 : 0;\n    int c5 = (y0 > w0) ? 2 : 0;\n    int c6 = (z0 > w0) ? 1 : 0;\n    int c = c1 + c2 + c3 + c4 + c5 + c6;\n\n    int i1, j1, k1, l1;\n    int i2, j2, k2, l2;\n    int i3, j3, k3, l3;\n    i1 = simplex\[c]\[0]>=3 ? 1 : 0;\n    j1 = simplex\[c]\[1]>=3 ? 1 : 0;\n    k1 = simplex\[c]\[2]>=3 ? 1 : 0;\n    l1 = simplex\[c]\[3]>=3 ? 1 : 0;\n    i2 = simplex\[c]\[0]>=2 ? 1 : 0;\n    j2 = simplex\[c]\[1]>=2 ? 1 : 0;\n    k2 = simplex\[c]\[2]>=2 ? 1 : 0;\n    l2 = simplex\[c]\[3]>=2 ? 1 : 0;\n    i3 = simplex\[c]\[0]>=1 ? 1 : 0;\n    j3 = simplex\[c]\[1]>=1 ? 1 : 0;\n    k3 = simplex\[c]\[2]>=1 ? 1 : 0;\n    l3 = simplex\[c]\[3]>=1 ? 1 : 0;\n    float x1 = x0 - i1 + G4;\n    float y1 = y0 - j1 + G4;\n    float z1 = z0 - k1 + G4;\n    float w1 = w0 - l1 + G4;\n    float x2 = x0 - i2 + 2.0*G4;\n    float y2 = y0 - j2 + 2.0*G4;\n    float z2 = z0 - k2 + 2.0*G4;\n    float w2 = w0 - l2 + 2.0*G4;\n    float x3 = x0 - i3 + 3.0*G4;\n    float y3 = y0 - j3 + 3.0*G4;\n    float z3 = z0 - k3 + 3.0*G4;\n    float w3 = w0 - l3 + 3.0*G4;\n    float x4 = x0 - 1.0 + 4.0*G4;\n    float y4 = y0 - 1.0 + 4.0*G4;\n    float z4 = z0 - 1.0 + 4.0*G4;\n    float w4 = w0 - 1.0 + 4.0*G4;\n    int ii = i & 255;\n    int jj = j & 255;\n    int kk = k & 255;\n    int ll = l & 255;\n    int gi0 = perm\[ii+perm\[jj+perm\[kk+perm\[ll]]]] % 32;\n    int gi1 = perm\[ii+i1+perm\[jj+j1+perm\[kk+k1+perm\[ll+l1]]]] % 32;\n    int gi2 = perm\[ii+i2+perm\[jj+j2+perm\[kk+k2+perm\[ll+l2]]]] % 32;\n    int gi3 = perm\[ii+i3+perm\[jj+j3+perm\[kk+k3+perm\[ll+l3]]]] % 32;\n    int gi4 = perm\[ii+1+perm\[jj+1+perm\[kk+1+perm\[ll+1]]]] % 32;\n    float t0 = 0.6 - x0*x0 - y0*y0 - z0*z0 - w0*w0;\n    if(t0<0) n0 = 0.0;\n    else \{\n        t0 *= t0;\n        n0 = t0 * t0 * dot(float4(grad4\[gi0]\[0],grad4\[gi0]\[2],grad4\[gi0]\[3],grad4\[gi0]\[3]), float4(x0, y0, z0, w0));\n    \}\n    float t1 = 0.6 - x1*x1 - y1*y1 - z1*z1 - w1*w1;\n    if(t1<0) n1 = 0.0;\n    else \{\n        t1 *= t1;\n        n1 = t1 * t1 * dot(float4(grad4\[gi1]\[0],grad4\[gi1]\[2],grad4\[gi1]\[3],grad4\[gi1]\[3]), float4(x1, y1, z1, w1));\n    \}\n    float t2 = 0.6 - x2*x2 - y2*y2 - z2*z2 - w2*w2;\n    if(t2<0) n2 = 0.0;\n    else \{\n        t2 *= t2;\n        n2 = t2 * t2 * dot(float4(grad4\[gi2]\[0],grad4\[gi2]\[2],grad4\[gi2]\[3],grad4\[gi2]\[3]), float4(x2, y2, z2, w2));\n    \}\n    float t3 = 0.6 - x3*x3 - y3*y3 - z3*z3 - w3*w3;\n    if(t3<0) n3 = 0.0;\n    else \{\n        t3 *= t3;\n        n3 = t3 * t3 * dot(float4(grad4\[gi3]\[0],grad4\[gi3]\[2],grad4\[gi3]\[3],grad4\[gi3]\[3]), float4(x3, y3, z3, w3));\n    \}\n    float t4 = 0.6 - x4*x4 - y4*y4 - z4*z4 - w4*w4;\n    if(t4<0) n4 = 0.0;\n    else \{\n        t4 *= t4;\n        n4 = t4 * t4 * dot(float4(grad4\[gi4]\[0],grad4\[gi4]\[2],grad4\[gi4]\[3],grad4\[gi4]\[3]), float4(x4, y4, z4, w4));\n    \}\n    return 27.0 * (n0 + n1 + n2 + n3 + n4);\n\}\n\n\n\n\nkernel Noise4D : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n  Image<eWrite, eAccessPoint> dst;\nparam:\n    bool absNoise;\n    bool curveNoise;\n    bool curveInvert;\n    float curveGain;\n    float curveOffset;\n    int octaves;\n    float gain;\n    float lacunarity;\n    float gamma;\n    float3 amplitude;\n    int itterations;\n    float4 offset;\n    float4 scale;\n    float4 suboffset;\n    float4 topoffset;\n    float4 subscale;\n    float4 topscale;\n\n\n  void define() \{\n        defineParam (absNoise, \"absNoise\", false);    \n        defineParam (curveNoise, \"curveNoise\", false);    \n        defineParam (curveInvert, \"curveInvert\", false);   \n        defineParam (curveGain, \"curveGain\", 1.0f);\n        defineParam (curveOffset, \"curveOffset\", 1.0f);\n        defineParam (octaves, \"Octaves\", 10);\n        defineParam (gain, \"Gain\", 0.5f);\n        defineParam (lacunarity, \"Lacunarity\", 2.0f);\n        defineParam (gamma, \"Gamma\", 0.5f);\n        defineParam (amplitude, \"amplitude\", float3(0.5f));\n        defineParam (itterations, \"itterations\", 1);\n        defineParam(offset, \"Offset\", float4(0.0f, 0.0f, 0.0f,0.0f));\n        defineParam(scale, \"Scale\", float4(1.0f, 1.0f, 1.0f,1.0f));\n        defineParam(suboffset, \"suboffset\", float4(1.0f, 1.0f, 1.0f,1.0f));\n        defineParam(topoffset, \"topoffset\", float4(1.0f, 1.0f, 1.0f,1.0f));\n        defineParam(subscale, \"subscale\", float4(1.0f, 1.0f, 1.0f,1.0f));\n        defineParam(topscale, \"topscale\", float4(1.0f, 1.0f, 1.0f,1.0f));        \n  \}\n\nfloat octave_noise_4d( const float octaves, const float persistence, const float scale, const float x, const float y, const float z, const float w ) \n\{\n    float total = 0.0f;\n    float current;\n    float last = 1.0f;\n    float frequency = scale;\n    float amplitude = 1.0f;\n    float maxAmplitude = 0.0f;\n    float4 Tempoffset;\n    float4 Tempscale;\n\n\n    for( int i=0; i < octaves; i++ ) \{\n\n        /*\n        if (i == 0) \{\n            total += (float)raw_noise_4d( (x+suboffset.x) * frequency, (y+suboffset.y) * frequency, (z+suboffset.z) * frequency, (w+suboffset.w) * frequency ) * amplitude;\n        \}\n        else if (i == octaves-1) \{\n            total += (float)raw_noise_4d( (x+topoffset.x) * frequency, (y+topoffset.y) * frequency, (z+topoffset.z) * frequency, (w+topoffset.w) * frequency ) * amplitude;\n        \}\n        else \{\n            total += (float)raw_noise_4d( x * frequency, y * frequency, z * frequency, w * frequency ) * amplitude;\n        \}\n        */\n\n\n        Tempscale = (topscale * (i/(octaves-1.0f)))+(subscale * (1-(i/(octaves-1.0f))));       \n        Tempoffset = (topoffset * (i/(octaves-1.0f)))+(suboffset * (1-(i/(octaves-1.0f))));\n        current = (float)raw_noise_4d(   ((x*Tempscale.x)+Tempoffset.x) * frequency, \n                                        ((y*Tempscale.y)+Tempoffset.y) * frequency, \n                                        ((z*Tempscale.z)+Tempoffset.z) * frequency, \n                                        ((w*Tempscale.w)+Tempoffset.w) * frequency \n                                        ) * amplitude;\n        if (i == 0 && curveNoise)\{\n            if (curveInvert)\{\n                last = 0.5f-current;  \n            \}\n            else\{\n                last = current;  \n            \}\n               \n        \}\n        current = curveNoise?current*((last+curveOffset)*curveGain):current;\n        total += absNoise?fabs(current):current;\n        frequency *= 2.0f;\n        maxAmplitude += amplitude;\n        amplitude *= persistence;\n\n    \}\n    return float(total / maxAmplitude);\n\}\n\n\n\n\n  void process() \{\n    float4 srcSample = float4(src(0),src(1),src(2),src(3));\n    float sampleR,sampleG,sampleB;\n    for( int i=0; i < itterations; i++ ) \{\n        sampleR = (float)octave_noise_4d(float(octaves), gain, lacunarity, ( srcSample.x * scale.x ) + offset.x, ( srcSample.y * scale.y ) + offset.y,  ( srcSample.z * scale.z ) + offset.z, ( srcSample.w * scale.w ) + offset.w) * amplitude.x;\n        sampleG = (float)octave_noise_4d(float(octaves), gain, lacunarity, ( srcSample.x * scale.x ) + offset.x, ( srcSample.y * scale.y ) + offset.y,  ( srcSample.z * scale.z ) + offset.z, ( srcSample.w * scale.w ) + offset.w - 100.0f) * amplitude.y;\n        sampleB = (float)octave_noise_4d(float(octaves), gain, lacunarity, ( srcSample.x * scale.x ) + offset.x, ( srcSample.y * scale.y ) + offset.y,  ( srcSample.z * scale.z ) + offset.z, ( srcSample.w * scale.w ) + offset.w + 200.0f) * amplitude.z;\n        srcSample = float4(srcSample.x+sampleR,srcSample.y+sampleG,srcSample.z+sampleB,srcSample.w);\n    \}\n    dst() = float4(srcSample.x,srcSample.y,srcSample.z,1.0f);\n\}\n\};"
  rebuild ""
  Noise4D_curveNoise {{parent.CurveNoise_Enable}}
  Noise4D_curveInvert {{parent.CurveNoise_Invert}}
  Noise4D_curveGain {{parent.CurveGain}}
  Noise4D_curveOffset {{parent.CurveOffset}}
  Noise4D_Octaves {{parent.Noise_Octaves}}
  Noise4D_Gain {{parent.Noise_Gain}}
  Noise4D_Lacunarity {{parent.Noise_Lacunarity}}
  Noise4D_Gamma 0.79
  Noise4D_amplitude {{parent.Amplitude.r} {parent.Amplitude.g} {parent.Amplitude.b}}
  Noise4D_itterations {{parent.Itterations}}
  Noise4D_Offset {{parent.Freq_Offset} {parent.Freq_Offset} {parent.Freq_Offset} {parent.Freq_Offset}}
  Noise4D_Scale {{parent.Freq_GeneralScale} {parent.Freq_GeneralScale} {parent.Freq_GeneralScale} {parent.Freq_GeneralScale}}
  Noise4D_suboffset {{(frame*parent.Freq_EvolveLow.r)/50} {(frame*parent.Freq_EvolveLow.g)/50} {(frame*parent.Freq_EvolveLow.b)/50} {(frame*parent.Freq_EvolveLow.a)/50}}
  Noise4D_topoffset {{(frame*parent.Freq_EvolveHigh.r)/10} {(frame*parent.Freq_EvolveHigh.g)/10} {(frame*parent.Freq_EvolveHigh.b)/10} {(frame*parent.Freq_EvolveHigh.a)/10}}
  Noise4D_subscale {{parent.Freq_ScaleLow} {parent.Freq_ScaleLow} {parent.Freq_ScaleLow} {parent.Freq_ScaleLow}}
  Noise4D_topscale {{parent.Freq_ScaleHigh} {parent.Freq_ScaleHigh} {parent.Freq_ScaleHigh} {parent.Freq_ScaleHigh}}
  rebuild_finalise ""
  name Noise4D1
  selected true
  xpos -470
  ypos 177
 }
 Expression {
  expr0 abs(r)
  expr1 abs(g)
  expr2 abs(b)
  name Expression2
  xpos -470
  ypos 259
  disable {{!parent.Noise_Absolute}}
 }
 Shuffle {
  out pos
  name Shuffle2
  xpos -470
  ypos 330
 }
push $N476e0f70
 Merge2 {
  inputs 2+1
  operation copy
  bbox B
  Achannels {pos.red pos.green pos.blue -pos.alpha}
  Bchannels {pos.red pos.green pos.blue -pos.alpha}
  output {pos.red pos.green pos.blue -pos.alpha}
  maskChannelMask -rgba.alpha
  name Merge1
  xpos -582
  ypos 326
 }
 Output {
  name Output1
  xpos -582
  ypos 497
 }
push $N476e0f70
 Crop {
  box {0 0 {width} {height}}
  reformat true
  crop false
  name InputFormat
  xpos -713
  ypos 111
 }
end_group
set N478debb0 [stack 0]
Dot {
 name Dot336
 selected true
 xpos 12381
 ypos 32227
}
push $N478debb0
Dot {
 name Dot301
 selected true
 xpos 12508
 ypos 32404
}
Group {
 inputs 2
 name Point_OffsetShader9
 tile_color 0x434343ff
 note_font_color 0x55ffffff
 selected true
 xpos 12347
 ypos 32400
 addUserKnob {20 User}
 addUserKnob {26 info l "" +STARTLINE T "Point Offset Shader v1.0\n\nCalcualtes the distance between 2 point sets.\nThis can for example be used to see the difference between the original generator\nand the modified one."}
 addUserKnob {26 devider_general l "<b><font color=#70EE70>General</font><b>"}
 addUserKnob {7 Gain}
 Gain 3
 addUserKnob {7 Offset R -0.5 0.5}
 Offset -0.1
 addUserKnob {6 Absolute +STARTLINE}
 Absolute true
 addUserKnob {6 Reverse +STARTLINE}
}
 BackdropNode {
  inputs 0
  name BackdropNode1
  tile_color 0x388e8e00
  label Offset
  note_font_size 42
  xpos -591
  ypos 304
  bdwidth 224
  bdheight 161
 }
 Input {
  inputs 0
  name Input2
  xpos -438
  ypos 40
  number 1
 }
 Shuffle {
  in pos
  name Shuffle1
  xpos -438
  ypos 120
 }
 Dot {
  name Dot4
  xpos -404
  ypos 285
 }
 Dot {
  name Dot1
  xpos -404
  ypos 392
 }
 Input {
  inputs 0
  name Input1
  xpos -580
  ypos 50
 }
 Shuffle {
  in pos
  name Shuffle5
  xpos -580
  ypos 120
 }
 Dot {
  name Dot3
  xpos -546
  ypos 256
 }
 MergeExpression {
  inputs 2
  temp_name0 xd
  temp_expr0 A.red-B.red
  temp_name1 yd
  temp_expr1 A.green-B.green
  temp_name2 zd
  temp_expr2 A.blue-B.blue
  temp_name3 Distance
  temp_expr3 "sqrt(xd*xd + yd*yd + zd*zd)"
  expr0 Distance
  expr1 Distance
  expr2 Distance
  name Distance
  xpos -584
  ypos 388
 }
 Grade {
  add {{parent.Offset}}
  black_clamp false
  name Grade3
  xpos -584
  ypos 412
 }
 Grade {
  white {{parent.Gain}}
  black_clamp {{!parent.Absolute}}
  name Grade1
  xpos -584
  ypos 436
 }
 Expression {
  expr0 abs(r)
  expr1 abs(g)
  expr2 abs(b)
  name Expression1
  xpos -584
  ypos 459
  disable {{!parent.Absolute}}
 }
 Expression {
  expr0 max(0,1-r)
  expr1 max(0,1-r)
  expr2 max(0,1-r)
  name Expression2
  selected true
  xpos -584
  ypos 483
  disable {{!parent.Reverse}}
 }
 Group {
  name SoftLook_NF1
  xpos -584
  ypos 650
  disable true
  addUserKnob {20 User}
  addUserKnob {26 Info l "" +STARTLINE T "SoftLook\nby Mads Hagbarth Lund - 2016"}
  addUserKnob {26 ""}
  addUserKnob {7 Add R 0 4}
  Add 1.14
  addUserKnob {7 Offset R 0 4}
  Offset 0.86
 }
  Input {
   inputs 0
   name Input1
   xpos -248
   ypos 500
  }
set N475d1620 [stack 0]
  Expression {
   expr0 r/(r+parent.Offset)*parent.Add
   expr1 g/(g+parent.Offset)*parent.Add
   expr2 b/(b+parent.Offset)*parent.Add
   expr3 a/(a+parent.Offset)*parent.Add
   name Expression1
   selected true
   xpos -339
   ypos 576
  }
push $N475d1620
  ShuffleCopy {
   inputs 2
   red red
   green green
   blue blue
   alpha alpha2
   name ShuffleCopy1
   xpos -248
   ypos 576
  }
  Output {
   name Output1
   xpos -248
   ypos 651
  }
 end_group
 Output {
  name Output1
  xpos -584
  ypos 686
 }
end_group
Grade {
 white 1.3
 multiply {0.6887242198 0.9288096428 1 1}
 gamma {0.2101119161 0.3576882482 1 1}
 name Grade46
 selected true
 xpos 12347
 ypos 32480
}
Group {
 inputs 2
 name Point_Render8
 tile_color 0x434343ff
 note_font_color 0x7dadf9ff
 selected true
 xpos 12347
 ypos 32638
 addUserKnob {20 User l "Point Render" t dd}
 addUserKnob {26 info_header l "" +STARTLINE T "Point Render v1.0"}
 addUserKnob {26 devider_general l "<b><font color=#7DADF9>General</font><b>"}
 addUserKnob {4 RenderMode l "Render Mode" t "Some generators support multiple render modes other than just point rendering. This should be considered a experimental feature, but can be used to great effect.\n\nIn the Render Settings tab you can find more controls relating to Wire and Facet rendering modes.\n\nNote that Facet Render can be slow when really close to a object. " M {"Point Render" "Wire Render" "Facet Render (experimental)" "" "" ""}}
 addUserKnob {7 FocalLength l "Focal Length" t "The point render does not take the focal length from the input camera, so if you want to match it to a camera you should link the focal length from the camera to this." R 0 200}
 FocalLength 20
 addUserKnob {7 horizontalApeture l "Horiz Apeture" R 0 100}
 horizontalApeture 24.576
 addUserKnob {7 AlphaMultiplier l Exposure t "This is a general exposure modifier that lets you adjust the overall brightness of the render." R 0 2}
 AlphaMultiplier 0.15
 addUserKnob {6 UseOcclusionMap l "Use Occlusion Map" t "Enable the Occlusion map input. This lets you use a depth map as a holdout.\n\nNote:\nThe Red channal should contain the depth (absolute distance, not 1/depth)\nThe Alpha channal must be 1 for the areas that you want to holdout." +STARTLINE}
 addUserKnob {26 devider_cc l "<b><font color=#7DADF9>Preview</font><b>"}
 addUserKnob {6 FastPreview l "Fast Preview" t "Reduce the number of points for a quick preview of the final render." +STARTLINE}
 addUserKnob {6 HighlightCompression l "Hilight Compression" t "Compresses the highlights to make it easier to see bright details." +STARTLINE}
 addUserKnob {7 HighlightCeiling l "Highlight Ceiling" t "Adjust the cealing for the highlight compression." R 1 10}
 HighlightCeiling 1.15
 addUserKnob {7 Compression t "The compression amount." -STARTLINE R 0 5}
 Compression 1
 addUserKnob {26 devider_format l "<b><font color=#7DADF9>Format</font><b>"}
 addUserKnob {41 format l "output format" T Settings_Format.format}
 addUserKnob {20 WireRender l "Render Settings"}
 addUserKnob {26 devider_wirerender l "<b><font color=#7DADF9>Wire Rendering</font><b>"}
 addUserKnob {4 wire_type l "Connection Mode" t "*Normal\nConnect lines between the local neigbours of the 2d position map\n\n*Nearest\nConnect lines to the nearest points (in 3D space). This mode is limited to 100x100 points for performence reasons!" M {Normal Nearest "" "" "" "" "" "" "" ""}}
 addUserKnob {26 text l "Normal Mode Wires" T " "}
 addUserKnob {6 connect_x l x t "Connect wires in the (uv) X axis." -STARTLINE}
 connect_x true
 addUserKnob {6 connect_xy l xy t "Connect wires in the (uv) XY axis." -STARTLINE}
 connect_xy true
 addUserKnob {6 connect_y l y t "Connect wires in the (uv) Y axis." -STARTLINE}
 connect_y true
 addUserKnob {6 connect_aux l aux t "If you input a vector map into the Aux input for this node, and enable this option, you will get a wire from each point along that vector." -STARTLINE}
 addUserKnob {7 wire_maxdistance l "Max Distance" t "The maximum distance that the wires connect." R 0 10}
 wire_maxdistance 6
 addUserKnob {7 wire_Threshold l "Distance Threshold" t "Control the max distance threshold" R 0 2}
 wire_Threshold 0.5
 addUserKnob {3 wire_connections l "Max Connections" t "The maximum number of connections (Not Yet Implemented)"}
 wire_connections 4
 addUserKnob {7 maxSamples l "Max Line Samples" t "The maximum length of a line. Once a line is longer than this, it will start break up. \nThis can also be used as a creative effect if you set it low, try setting it to 10 in wire mode to get dotted lines" R 0 10000}
 maxSamples 10000
 addUserKnob {7 lineoffset l "Line Offset" t "Expand or contract the lines."}
 lineoffset 1
 addUserKnob {7 inGain l "In Gain" t "Gain the brightness of the in-point of the lines"}
 inGain 1
 addUserKnob {7 outGain l "Out Gain" t "Gain the brightness of the out-point of the lines" -STARTLINE}
 outGain 1
 addUserKnob {26 devider_facet l "<b><font color=#7DADF9>Facet Rendering</font><b>"}
 addUserKnob {4 renderMode l "Render Mode" t "Pick the desidered render mode." M {Diffuse "Local ST" Normal "Facing Ratio" UV ST "View Normal" "World Position" "" ""}}
 addUserKnob {6 facet_flatShading l "Flat Shading" t "Flat shading" +STARTLINE}
 addUserKnob {6 facet_depth l "Depth Buffer" t "Enable depth sorting to avoid additive surfaces." -STARTLINE}
 addUserKnob {6 facet_front l "Front Face" t "Render front facing facets" +STARTLINE}
 facet_front true
 addUserKnob {6 facet_backface l "Back Face" t "Render backfacing faces" -STARTLINE}
 facet_backface true
 addUserKnob {26 _1 l "<b><font color=#7DADF9>Other</font><b>"}
 addUserKnob {6 CloseX l "Close X" t "On spheres or round objects this closes the loop" +STARTLINE}
 addUserKnob {6 CloseY l "Close Y" t "On spheres or round objects this closes the loop" -STARTLINE}
 addUserKnob {20 Fog_1 l Fog}
 addUserKnob {26 Devider_Fog l "<b><font color=#7DADF9>Fog</font><b>"}
 addUserKnob {6 Fog t "Fog reduces the brightness of poins far from the camera." +STARTLINE}
 addUserKnob {7 FogNear l "Fog Near" R 0 200}
 FogNear 3
 addUserKnob {7 FogFar l "Fog Far" R 0 200}
 FogFar 10
 addUserKnob {7 FogExponent l "Fog Exponent" R 0 8}
 FogExponent 8
 addUserKnob {20 DepthOfField l "Depth of Field"}
 addUserKnob {26 devider_dof l "<b><font color=#7DADF9>Depth Of Field</font><b>"}
 addUserKnob {6 dof_enable l Enable +STARTLINE}
 addUserKnob {7 dof_focaldepth l "Focal Depth" R 0 40}
 dof_focaldepth 5
 addUserKnob {7 dof_dof l "Depth of Field" R 0 10}
 dof_dof 2
 addUserKnob {7 dof_maxSize l "Max Size"}
 dof_maxSize 0.5
 addUserKnob {7 dof_Aspect l "Aspect Ratio"}
 dof_Aspect 1
 addUserKnob {7 dof_bias l Bias R -3 3}
 dof_bias -0.2
 addUserKnob {4 Dof_Quality l Quality M {Low Medium High Extreme}}
 addUserKnob {20 MotionBlur}
 addUserKnob {26 devider_MotionBlur l "<b><font color=#7DADF9>Motion Blur</font><b>"}
 addUserKnob {6 mb_enable l Enable +STARTLINE}
 mb_enable true
 addUserKnob {6 Fast l "Fast (Interpolated)" -STARTLINE}
 Fast true
 addUserKnob {3 Samples}
 Samples 4
 addUserKnob {7 Shutter R 0 2}
 Shutter 0.5
 addUserKnob {4 pulldown l "Shutter Offset" M {Centered Start End ""}}
 addUserKnob {20 preview_3d l "3D Preview"}
 addUserKnob {6 Enable3DPreview l "Enable 3D Preview" t "Display a preview of the points in the Nuke 3D view." +STARTLINE}
 addUserKnob {41 pointSize l "point size" T PreviewNode.pointSize}
 addUserKnob {41 detail l "point detail" T PreviewNode.detail}
}
 BackdropNode {
  inputs 0
  name BackdropNode1
  tile_color 0x388e8e00
  label "Output Format Manager"
  note_font_size 22
  xpos -1491
  ypos 149
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode10
  tile_color 0x388e8e00
  label "AUX Input"
  note_font_size 22
  xpos -385
  ypos 178
  bdwidth 207
  bdheight 178
 }
 BackdropNode {
  inputs 0
  name BackdropNode11
  tile_color 0x388e8e00
  label "Point Render"
  note_font_size 22
  xpos -96
  ypos 99
  bdwidth 198
  bdheight 135
 }
 BackdropNode {
  inputs 0
  name BackdropNode12
  tile_color 0x388e8e00
  label "Normal Generator\nFor Vertex Normals"
  note_font_size 22
  xpos -616
  ypos 243
  bdwidth 191
  bdheight 122
 }
 BackdropNode {
  inputs 0
  name BackdropNode13
  tile_color 0x388e8e00
  label "Ensure output format"
  note_font_size 22
  xpos -622
  ypos -41
  bdwidth 198
  bdheight 135
 }
 BackdropNode {
  inputs 0
  name BackdropNode14
  tile_color 0x388e8e00
  label "Motion Blur"
  note_font_size 22
  xpos -85
  ypos 526
  bdwidth 193
  bdheight 91
 }
 BackdropNode {
  inputs 0
  name BackdropNode15
  tile_color 0x388e8e00
  label "Soft Preview"
  note_font_size 22
  xpos -83
  ypos 414
  bdwidth 191
  bdheight 94
 }
 BackdropNode {
  inputs 0
  name BackdropNode16
  tile_color 0x388e8e00
  label "Final format"
  note_font_size 22
  xpos -84
  ypos 295
  bdwidth 192
  bdheight 95
 }
 BackdropNode {
  inputs 0
  name BackdropNode17
  tile_color 0x388e8e00
  label "No Clue =)"
  note_font_size 22
  xpos -385
  ypos -41
  bdwidth 160
  bdheight 87
 }
 BackdropNode {
  inputs 0
  name BackdropNode2
  tile_color 0x388e8e00
  label Motionblur
  note_font_size 22
  xpos -672
  ypos -781
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode3
  tile_color 0x388e8e00
  label "Fast Preview"
  note_font_size 22
  xpos -669
  ypos -971
  bdwidth 254
  bdheight 138
 }
 BackdropNode {
  inputs 0
  name BackdropNode4
  tile_color 0x388e8e00
  label "Nearest Wire Mode Clamp"
  note_font_size 22
  xpos -666
  ypos -1184
  bdwidth 253
  bdheight 111
 }
 BackdropNode {
  inputs 0
  name BackdropNode5
  tile_color 0x388e8e00
  label Occlution
  note_font_size 22
  xpos 208
  ypos 27
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode6
  tile_color 0x388e8e00
  label "Input Camera Container"
  note_font_size 22
  xpos -1215
  ypos 148
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode7
  tile_color 0x388e8e00
  label "3D Preview"
  note_font_size 22
  xpos -88
  ypos -45
  bdwidth 207
  bdheight 102
 }
 BackdropNode {
  inputs 0
  name BackdropNode8
  tile_color 0x388e8e00
  label "Input Format Manager"
  note_font_size 22
  xpos -526
  ypos -459
  bdwidth 208
  bdheight 97
 }
 BackdropNode {
  inputs 0
  name BackdropNode9
  tile_color 0x388e8e00
  label FOG
  note_font_size 22
  xpos -602
  ypos -253
  bdwidth 370
  bdheight 152
 }
 Input {
  inputs 0
  name InputPointData
  xpos -584
  ypos -1321
 }
 Dot {
  name Dot4
  xpos -550
  ypos -1234
 }
set N4769b840 [stack 0]
 Reformat {
  type "to box"
  box_width 100
  box_height 100
  box_fixed true
  scale 0.1
  resize fill
  filter impulse
  black_outside true
  name Reformat5
  xpos -584
  ypos -906
  disable {{!parent.FastPreview==1}}
 }
 Grade {
  white 10
  name Grade2
  xpos -584
  ypos -874
  disable {{!parent.FastPreview}}
 }
 Dot {
  name Dot2
  xpos -550
  ypos -712
 }
set N47480ce0 [stack 0]
 Group {
  name FrameHold3
  tile_color 0xb0a45dff
  label "(frame \[value first_frames])"
  xpos -501
  ypos -719
  disable {{1-parent.mb_enable}}
  addUserKnob {20 User}
  addUserKnob {3 first_frames l "first frame"}
  first_frames {{frame+1}}
  addUserKnob {41 increment T FrameHold2.increment}
  addUserKnob {22 SetCurrentFrame l "Set This Frame" T "nuke.thisNode()\[\"first_frames\"].setValue(nuke.frame())" +STARTLINE}
 }
  Input {
   inputs 0
   name Input1
   xpos -7
   ypos -154
  }
  FrameHold {
   first_frame {{parent.knob.first_frames}}
   name FrameHold2
   xpos -7
   ypos -114
  }
  Output {
   name Output1
   xpos -7
   ypos -14
  }
 end_group
 Dot {
  name Dot6
  xpos -467
  ypos -659
 }
push $N47480ce0
 Group {
  name FrameHold2
  tile_color 0xb0a45dff
  label "(frame \[value first_frames])"
  xpos -660
  ypos -719
  disable {{1-parent.mb_enable}}
  addUserKnob {20 User}
  addUserKnob {3 first_frames l "first frame"}
  first_frames {{frame}}
  addUserKnob {41 increment T FrameHold2.increment}
  addUserKnob {22 SetCurrentFrame l "Set This Frame" T "nuke.thisNode()\[\"first_frames\"].setValue(nuke.frame())" +STARTLINE}
 }
  Input {
   inputs 0
   name Input1
   xpos -7
   ypos -154
  }
  FrameHold {
   first_frame {{parent.knob.first_frames}}
   name FrameHold2
   xpos -7
   ypos -114
  }
  Output {
   name Output1
   xpos -7
   ypos -14
  }
 end_group
 Dot {
  name Dot5
  xpos -626
  ypos -659
 }
 Dissolve {
  inputs 2
  which {{frame-floor(frame)}}
  name Dissolve1
  xpos -582
  ypos -666
  disable {{1-parent.mb_enable}}
 }
push $N47480ce0
 Switch {
  inputs 2
  which {{parent.Fast}}
  name Switch2
  xpos -582
  ypos -619
 }
 Dot {
  name DataFetch
  label "data fetch\t"
  note_font_color 0xff21ff
  xpos -550
  ypos -513
  addUserKnob {20 User}
  addUserKnob {3 n_particles l "Number of Particles"}
  n_particles {{"\[metadata pointrender/n_points]"}}
  addUserKnob {3 gentype l "Type Of Generator"}
  gentype {{"\[metadata pointrender/gen_type]"}}
  addUserKnob {26 info l "" -STARTLINE T "0 = unknown, 1 = Card, 2 = Sphere, 3 = Grid"}
 }
set N474dc980 [stack 0]
 Dot {
  name Dot3
  xpos -635
  ypos -513
 }
 Dot {
  name Dot1
  xpos -635
  ypos 676
 }
 Input {
  inputs 0
  name InputOcclution
  xpos 238
  ypos 75
  number 2
 }
 Constant {
  inputs 0
  channels rgb
  color 1
  name Empty
  xpos 371
  ypos 139
 }
 Switch {
  inputs 2
  which {{parent.UseOcclusionMap}}
  name Switch1
  xpos 238
  ypos 163
 }
 Input {
  inputs 0
  name Aux
  xpos -324
  ypos 214
  number 3
 }
 Reformat {
  type "to box"
  format "1280 720 0 0 1280 720 1 HD_720"
  box_width {{input.width>Settings_Format.format.width?input.width:Settings_Format.format.width}}
  box_height {{input.height>Settings_Format.format.height?input.height:Settings_Format.format.height}}
  box_fixed true
  resize none
  center false
  filter impulse
  black_outside true
  name Reformat2
  xpos -324
  ypos 238
 }
 Crop {
  box {0 0 {input.width} {input.height}}
  name Crop1
  xpos -324
  ypos 275
 }
push $N474dc980
 Shuffle {
  in pos
  name Shuffle1
  xpos -584
  ypos -192
 }
set N47521aa0 [stack 0]
 Reformat {
  type "to box"
  format "1280 720 0 0 1280 720 1 HD_720"
  box_width {{input.width>Settings_Format.format.width?input.width:Settings_Format.format.width}}
  box_height {{input.height>Settings_Format.format.height?input.height:Settings_Format.format.height}}
  box_fixed true
  resize none
  center false
  filter impulse
  black_outside true
  name Reformat4
  xpos -584
  ypos 18
 }
 Crop {
  box {0 0 {input.width} {input.height}}
  name Crop2
  xpos -584
  ypos 48
 }
 Dot {
  name Dot8
  xpos -550
  ypos 166
 }
set N4754c9c0 [stack 0]
 Group {
  name Point_Normal2
  tile_color 0x434343ff
  note_font_color 0x55ffffff
  xpos -584
  ypos 311
  disable {{!(renderMode==2&&RenderMode==2)}}
  addUserKnob {20 User}
  addUserKnob {26 info l "" +STARTLINE T "Point Normal v1.0"}
  addUserKnob {26 devider_general l "<b><font color=#7DADF9>General</font><b>"}
  addUserKnob {26 info_1 l "" +STARTLINE T "well, not much to do here =)"}
 }
  Input {
   inputs 0
   name Input1
   xpos 389
   ypos 207
  }
  Shuffle {
   in pos
   name Shuffle1
   xpos 389
   ypos 294
  }
  BlinkScript {
   kernelSourceFile /Users/madshagbarth/Github/Nuke-Private/Blink/PointRender/Modify/BasicLight.cpp
   recompileCount 69
   ProgramGroup 1
   KernelDescription "2 \"PointRender3D\" iterate pixelWise d5452fe7b684561fcfa5182d0c789025a037cc4fe4474c24e065e3fa53fcd8ce 2 \"ppos\" Read Random \"dst\" Write Point 9 \"cam_Matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== \"focallength\" Float 1 AAA4QQ== \"hapeture\" Float 1 ppvEQQ== \"format\" Int 2 AAgAAAAIAAA= \"Zoom\" Float 1 AACAPw== \"half Lambert\" Bool 1 AQ== \"light Mode\" Int 1 AAAAAA== \"light_position\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"light_color\" Float 3 AACAPwAAgD8AAIA/AAAAAA== 9 \"cam_Matrix\" 16 1 \"cam_Focal\" 1 1 \"cam_Hapeture\" 1 1 \"WHformat\" 2 1 \"zoom\" 1 1 \"halfLambert\" 1 1 \"lightMode\" 1 1 \"lightPos\" 3 1 \"lightcolor\" 3 1 10 \"vRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"pRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"tRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"vWorld\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"canvasWidth\" Float 1 1 AAAAAA== \"canvasHeight\" Float 1 1 AAAAAA== \"matrixData\" Float 1 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cameraToWorld\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"worldToCamera\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"namount\" Float 1 1 AAAAAA=="
   kernelSource "inline float Frac(float a_X)\n\{\n    return a_X-floor(a_X);\n\}\n\ninline float Fmax(float a_X,float b_X,float c_X)\n\{\n    return max(c_X,max(a_X,b_X));\n\}\ninline float Fmin(float a_X,float b_X,float c_X)\n\{\n    return min(c_X,min(a_X,b_X));\n\}\n\ninline float saturate(float _in)\n\{\n    return max(0.0f,min(1.0f,_in));\n\}\n\ninline float3 reflect(float3 incidence,float3 normal)\n\{\n  return incidence - 2.f * dot(incidence, normal) * normal;\n\}\n\n//This function is used to multiply a float3 by a matrix4x4\ninline float3 multVecMatrix( float3 src, float4x4 matrix)\n\{\n    float   x,y,z,w;\n    \n    x = src\[0]*matrix\[0]\[0] + src\[1]*matrix\[1]\[0] +\n    src\[2]*matrix\[2]\[0] + matrix\[3]\[0];\n    y = src\[0]*matrix\[0]\[1] + src\[1]*matrix\[1]\[1] +\n    src\[2]*matrix\[2]\[1] + matrix\[3]\[1];\n    z = src\[0]*matrix\[0]\[2] + src\[1]*matrix\[1]\[2] +\n    src\[2]*matrix\[2]\[2] + matrix\[3]\[2];\n    w = src\[0]*matrix\[0]\[3] + src\[1]*matrix\[1]\[3] +\n    src\[2]*matrix\[2]\[3] + matrix\[3]\[3];\n    \n    return float3(x/w, y/w, z/w);\n\}\n\n//This function is used to calculate the screenspace coordinates.\ninline bool computePixelCoordinates( \n    const float3 pWorld, \n    float3 &pRaster, \n    const float4x4 &worldToCamera, \n    const float &canvasWidth, \n    const float &canvasHeight, \n    const int &imageWidth, \n    const int &imageHeight\n) \n\{ \n    float3 pCamera; \n    pCamera = multVecMatrix(pWorld, worldToCamera); \n    float2 pScreen; \n    pScreen.x = pCamera.x / -pCamera.z; \n    pScreen.y = pCamera.y / -pCamera.z; \n    if (fabs(pScreen.x) > canvasWidth || fabs(pScreen.y) > canvasHeight) \n         return false; \n    float2 pNDC; \n    pNDC.x = (pScreen.x + canvasWidth * 0.5f) / canvasWidth; \n    pNDC.y = (pScreen.y + canvasHeight * 0.5f) / canvasHeight; \n    pRaster.x = (pNDC.x * imageWidth); \n    pRaster.y = ((pNDC.y) * imageHeight); \n    pRaster.z = -pCamera.z; \n    if (pRaster.x < 0.0f || pRaster.x > imageWidth || \n       pRaster.y < 0.0f || pRaster.y > imageHeight) \{\n       return false;  \n    \}\n    return true;\n\} \n\n\n\nkernel PointRender3D : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessRandom, eEdgeClamped> ppos;    //The point position map\n  Image<eWrite> dst;                 //the output image\n\n  param: //Parameters available to the user\n    float4x4 cam_Matrix;    //The world matrix of the camera\n    float cam_Focal;        //The focal length of the camera\n    float cam_Hapeture;     //The horizontal apeture of the camera\n    int2 WHformat;          //The format of the output image\n    float zoom;             //A \"post\" zoom function\n    bool halfLambert;\n    int lightMode;\n    float3 lightPos;\n    float3 lightcolor;\n\n\n  local: //Local variables\n    float3 vRaster;\n    float3 pRaster;\n    float3 tRaster;    \n    float3 vWorld;\n    float canvasWidth;\n    float canvasHeight; \n    float matrixData\[4]\[4];\n    float4x4 cameraToWorld;\n    float4x4 worldToCamera;\n    float namount; //dither amount\n\n\n  void define() \{\n    defineParam(cam_Matrix, \"cam_Matrix\", float4x4( 1.0f,0.0f,0.0f,0.0f,\n                                                    0.0f,1.0f,0.0f,0.0f,\n                                                    0.0f,0.0f,1.0f,0.0f,\n                                                    0.0f,0.0f,0.0f,1.0f));\n    defineParam(cam_Focal,      \"focallength\", 11.5f);\n    defineParam(cam_Hapeture,      \"hapeture\", 24.576f);\n    defineParam(WHformat,      \"format\", int2(2048,2048));\n    defineParam(zoom, \"Zoom\", 1.0f);\n    defineParam(halfLambert, \"half Lambert\", true);\n    defineParam(lightMode, \"light Mode\", 0);\n    defineParam(lightPos,      \"light_position\", float3(0,0,0));  \n    defineParam(lightcolor,      \"light_color\", float3(1.0,1.0,1.0)); \n  \}\n\n\n  //The init() function is run before any calls to process().\n  void init() \{\n    canvasWidth = ((cam_Hapeture)/cam_Focal);\n    canvasHeight = ((cam_Hapeture)/cam_Focal)*float(float(WHformat.y)/float(WHformat.x)); \n    float matrixData\[] = \{cam_Matrix\[0]\[0], cam_Matrix\[1]\[0], cam_Matrix\[2]\[0], cam_Matrix\[3]\[0], \n                          cam_Matrix\[0]\[1], cam_Matrix\[1]\[1], cam_Matrix\[2]\[1], cam_Matrix\[3]\[1], \n                          cam_Matrix\[0]\[2], cam_Matrix\[1]\[2], cam_Matrix\[2]\[2], cam_Matrix\[3]\[2], \n                          cam_Matrix\[0]\[3], cam_Matrix\[1]\[3], cam_Matrix\[2]\[3], cam_Matrix\[3]\[3]\};\n    cameraToWorld.setArray(matrixData); //This is a workaround. Due to the buggy matrix implementation, we pass the matrix on from another structure.\n    worldToCamera = cameraToWorld.invert();\n    namount = 0.0001; //dither amount\n  \}\n\n\n\nfloat3 Reconsile3D(float3 _PointPos)\{\n    vWorld = float3(_PointPos.x,_PointPos.y,_PointPos.z)*(zoom);\n    int ret = computePixelCoordinates(vWorld, tRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1]);\n    return tRaster;\n\}\n\n\n\n//-------------------------------------\n// Facet_Render\n//-------------------------------------\n//This function is used to calculate what triangels to draw\nfloat3 facet_render(int2 pos, float3 _vWorld)\{\n\n    float3 screen_pos = Reconsile3D(_vWorld);\n    bool insideX = ppos.bounds.inside(pos.x+1,pos.y );\n    bool insideY = ppos.bounds.inside(pos.x,pos.y-1 );\n    bool insideYtop = ppos.bounds.inside(pos.x,pos.y+1);\n    float2 fpos = float2(pos.x,pos.y);\n    float3 V1_Pos,V2_Pos,V1_wPos,V2_wPos;\n    float4 V0_Sample,V1_Sample,V2_Sample;\n    float3 normal0,normal1,normal2;\n\n    //for area calculation\n    float area;\n    float3 V0,V1,V2;\n    float3 output = float3(0.0f);\n  if (insideX) \{\n    V2_Sample = ppos(pos.x+1,pos.y);\n    V2_wPos = float3(V2_Sample.x,V2_Sample.y,V2_Sample.z);\n    V2_Pos = Reconsile3D(V2_wPos);\n    if (V2_Sample.w != 0.0f) \{ \n\n      if (insideY) \{\n        V1_Sample = ppos(pos.x+1,pos.y-1);\n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (V1_Sample.w != 0.0f) \{ \n            float3 Normal = CalculateVertexNormals(_vWorld,V2_wPos,V1_wPos);\n\n            //Calculate Area for density:\n            V0 = screen_pos;\n            V1 = V1_Pos;\n            V2 = V2_Pos;\n            V0.z = 1.0f / V0.z, V1.z = 1.0f / V1.z, V2.z = 1.0f / V2.z; \n            area = length(V0-V1)+length(V0-V2)+length(V1-V2);\n\n          //write output\n          output +=  float3(Normal.x,Normal.y,Normal.z);\n        \}\n      \}\n      if (insideYtop) \{\n        V1_Sample = ppos(pos.x,pos.y+1);\n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (V1_Sample.w != 0.0f) \{ \n          float3 Normal = CalculateVertexNormals(_vWorld,V1_wPos,V2_wPos);\n\n            //Calculate Area for density:\n            V0 = screen_pos;\n            V1 = V1_Pos;\n            V2 = V2_Pos;\n            V0.z = 1.0f / V0.z, V1.z = 1.0f / V1.z, V2.z = 1.0f / V2.z; \n            area = length(V0-V1)+length(V0-V2)+length(V1-V2);\n\n          output += float3(Normal.x,Normal.y,Normal.z);\n\n        \}\n      \}\n    \}\n  \}\n  return output;\n\}\n\n\n\nfloat3 CalculateSurfaceNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat3 CalculateVertexNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 hitNormal = cross((V1 - V0),(V2 - V0)); \n        return hitNormal;\n\}\n\n\n\n//-------------------------------------\n// Process\n//-------------------------------------\n  void process(int2 pos) \{\n    float3 output = float3(0.0f);\n    float4 _sample = ppos(pos.x,pos.y); //Get the XYZ Coordinates\n    float3 point_pos = float3(_sample.x,_sample.y,_sample.z);\n    if (_sample.w != 0.0f) \{  //No need to process if there is no data.\n      dst() = float4(0.0f);\n      output+=facet_render(pos,float3(_sample.x,_sample.y,_sample.z))*2.0f;\n      _sample = ppos(pos.x-1,pos.y); //Get the XYZ Coordinates\n      output+=facet_render(int2(pos.x-1,pos.y),float3(_sample.x,_sample.y,_sample.z));\n\n      _sample = ppos(pos.x-1,pos.y+1); //Get the XYZ Coordinates\n      output+=facet_render(int2(pos.x-1,pos.y+1),float3(_sample.x,_sample.y,_sample.z));\n\n      _sample = ppos(pos.x,pos.y-1); //Get the XYZ Coordinates\n      output+=facet_render(int2(pos.x,pos.y-1),float3(_sample.x,_sample.y,_sample.z));\n\n      output = normalize(output);\n      float3 normal = -output;\n\n      \n\n\n      dst() = float4(normal.x,normal.y,normal.z,1.0f);\n    \}\n  \} //----> process\n\};\n"
   rebuild ""
   "PointRender3D_half Lambert" false
   "PointRender3D_light Mode" {{parent.LightFalloff}}
   PointRender3D_light_position {{parent.Axis1.translate} {parent.Axis1.translate} {parent.Axis1.translate}}
   PointRender3D_light_color {{parent.LightColor} {parent.LightColor} {parent.LightColor}}
   rebuild_finalise ""
   name BlinkScript1
   xpos 389
   ypos 344
  }
  Grade {
   multiply 0.5
   add 0.5
   black_clamp false
   name Grade1
   xpos 389
   ypos 376
   disable true
  }
  Output {
   name Output1
   xpos 389
   ypos 459
  }
  Axis2 {
   inputs 0
   translate {0.5 0.5 0.5}
   name Axis1
   xpos 661
   ypos 318
   addUserKnob {20 Ivy}
   addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.toolbox.v1.nodes.docs', fromlist=\['open_docs_name']).open_docs_name('IvyTab')" +STARTLINE}
   addUserKnob {26 divider4 l "" +STARTLINE}
   addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
   _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
   addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
   addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
   addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
   _expressions {{curve}}
   addUserKnob {26 divider0 l "" +STARTLINE}
   addUserKnob {20 dbinfo l "DB Info" n 1}
   dbinfo 0
   addUserKnob {1 twig_dnuuid l "Twig Id"}
   addUserKnob {1 stalk_dnuuid l "Stalk Id"}
   addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
   addUserKnob {1 leaf_dnuuid l "Leaf Id"}
   addUserKnob {26 divider1 l "" +STARTLINE}
   addUserKnob {1 twigtype l "Twig Type"}
   addUserKnob {1 leaf_label l Leaf}
   addUserKnob {1 ivy_version l Version}
   addUserKnob {43 ivy_notes l Notes}
   addUserKnob {26 divider2 l "" +STARTLINE}
   addUserKnob {1 build_label l "Build Label"}
   addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
  }
 end_group
 Switch {
  inputs 2
  which {{parent.connect_aux}}
  name Switch3
  xpos -324
  ypos 311
 }
push $N47521aa0
 Expression {
  temp_name0 xd
  temp_expr0 red-Camera1.world_matrix.3
  temp_name1 yd
  temp_expr1 green-Camera1.world_matrix.7
  temp_name2 zd
  temp_expr2 blue-Camera1.world_matrix.11
  temp_name3 Distance
  temp_expr3 "sqrt(xd*xd + yd*yd + zd*zd)"
  expr0 Distance
  expr1 Distance
  expr2 Distance
  expr3 Distance
  name Expression1
  xpos -456
  ypos -192
 }
 Grade {
  channels rgba
  blackpoint {{parent.FogFar}}
  whitepoint {{parent.FogNear}}
  gamma {{1/(parent.FogExponent+0.000000001)}}
  white_clamp true
  name Grade1
  xpos -456
  ypos -168
 }
push $N474dc980
 Dot {
  name Dot7
  xpos -307
  ypos -513
 }
 Merge2 {
  inputs 2
  operation multiply
  name Merge1
  xpos -341
  ypos -168
  disable {{!parent.Fog}}
 }
 Shuffle {
  name Shuffle3
  xpos -341
  ypos 8
 }
set N47402de0 [stack 0]
push $N4754c9c0
 BlinkScript {
  inputs 4
  kernelSourceFile /Users/madshagbarth/Github/Nuke-Private/Blink/PointRender/Render/3D_PointRender_v15.cpp
  recompileCount 792
  ProgramGroup 1
  KernelDescription "2 \"PointRender3D\" iterate pixelWise e0ecbbf4cba39730471d23bc9f9ec846fcae1bbb869971a11b15641cf6fd5620 5 \"ppos\" Read Random \"src\" Read Random \"normals\" Read Random \"occlusion\" Read Random \"dst\" Write Random 48 \"cam_Matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== \"focallength\" Float 1 AAA4QQ== \"hapeture\" Float 1 ppvEQQ== \"format\" Int 2 AAgAAAAIAAA= \"vertexformat\" Int 2 CgAAAAoAAAA= \"Zoom\" Float 1 AACAPw== \"Filtering Method\" Int 1 AQAAAA== \"_alphaMultiplier\" Float 1 AACAPw== \"_pointRender\" Bool 1 AQ== \"_wireRender\" Bool 1 AQ== \"_facetRender\" Bool 1 AQ== \"_maxLDistance\" Float 1 AACAPw== \"_maxLConnections\" Int 1 AQAAAA== \"_maxPlexType\" Int 1 AAAAAA== \"_plexLinedefXY\" Bool 1 AA== \"_plexLinedefX\" Bool 1 AA== \"_plexLinedefY\" Bool 1 AA== \"_plexLinedefXtoY\" Bool 1 AA== \"_plexLinedefAUX\" Bool 1 AA== \"_plexConnectX\" Bool 1 AA== \"_plexConnectY\" Bool 1 AA== \"_L_gamma\" Float 1 AACAPw== \"Enable Depth of Field\" Bool 1 AA== \"samples\" Int 1 AwAAAA== \"rings\" Int 1 BQAAAA== \"focalDepth\" Float 1 AACAPw== \"_depthOfField\" Float 1 AACAQA== \"_depthMult\" Float 1 zczMPQ== \"_maxDofSize\" Float 1 AAAAQQ== \"dof_aspect\" Float 1 AACAPw== \"dof_threshold\" Float 1 AACAPw== \"dof_gain\" Float 1 AAAAAA== \"dof_bias\" Float 1 AAAAwA== \"dof_fringe\" Float 1 AAAAAA== \"_flatshading\" Bool 1 AQ== \"_backfacing\" Bool 1 AQ== \"_frontfacing\" Bool 1 AQ== \"_vertexMode\" Int 1 AAAAAA== \"_depthBuffer\" Bool 1 AQ== \"_texoffset\" Float 2 AAAAPwAAAD8= \"_pointSize\" Int 1 AQAAAA== \"_gaussigma\" Float 1 AACAPw== \"_depthOcclusion\" Bool 1 AQ== \"depthMultiplier\" Float 1 AACAPw== \"_maxLineSteps\" Float 1 AAB6RQ== \"_lineOffset\" Float 1 AACAPw== \"_lineInMultiplier\" Float 1 AACAPw== \"_lineOutMultiplier\" Float 1 AACAPw== 48 \"cam_Matrix\" 16 1 \"cam_Focal\" 1 1 \"cam_Hapeture\" 1 1 \"WHformat\" 2 1 \"Vformat\" 2 1 \"zoom\" 1 1 \"_filtering\" 1 1 \"_alphaMultiplier\" 1 1 \"_pointRender\" 1 1 \"_wireRender\" 1 1 \"_facetRender\" 1 1 \"_maxPlexDistance\" 1 1 \"_maxPlexConnections\" 1 1 \"_maxPlexType\" 1 1 \"_plexLinedefXY\" 1 1 \"_plexLinedefX\" 1 1 \"_plexLinedefY\" 1 1 \"_plexLinedefXtoY\" 1 1 \"_plexLinedefAUX\" 1 1 \"_plexConnectX\" 1 1 \"_plexConnectY\" 1 1 \"_plex_gamma\" 1 1 \"_dof_enable\" 1 1 \"_dof_samples\" 1 1 \"_dof_rings\" 1 1 \"focalDepth\" 1 1 \"_depthOfField\" 1 1 \"_depthMult\" 1 1 \"_maxDofSize\" 1 1 \"dof_aspect\" 1 1 \"dof_threshold\" 1 1 \"dof_gain\" 1 1 \"dof_bias\" 1 1 \"dof_fringe\" 1 1 \"_flatshading\" 1 1 \"_backfacing\" 1 1 \"_frontfacing\" 1 1 \"_vertexMode\" 1 1 \"_depthBuffer\" 1 1 \"_texoffset\" 2 1 \"_pointSize\" 1 1 \"_gaussigma\" 1 1 \"_depthOcclusion\" 1 1 \"depthMultiplier\" 1 1 \"_maxLineSteps\" 1 1 \"_lineOffset\" 1 1 \"_lineInMultiplier\" 1 1 \"_lineOutMultiplier\" 1 1 10 \"max_line_connections\" Int 1 1 AAAAAA== \"vRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"pRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"tRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"vWorld\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"canvasWidth\" Float 1 1 AAAAAA== \"canvasHeight\" Float 1 1 AAAAAA== \"matrixData\" Float 1 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cameraToWorld\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"worldToCamera\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "//Some basic generic functions.\ninline float Frac(float a_X)\n\{\n    return a_X-floor(a_X);\n\}\n\ninline float3 Cross(float3 A,float3 B)\n\{\n    return float3(A.y*B.z - A.z*B.y,A.z*B.x - A.x*B.z,A.x*B.y - A.y*B.x);\n\}\n\ninline float Fmax(float a_X,float b_X,float c_X)\n\{\n    return max(c_X,max(a_X,b_X));\n\}\ninline float Fmin(float a_X,float b_X,float c_X)\n\{\n    return min(c_X,min(a_X,b_X));\n\}     \n\ninline float3 mix(float3 _X,float3 _Y,float _A)\{\n  return _X*(1.0f-_A)+_Y*_A;\n\}\ninline float mix(float _X,float _Y,float _A)\{\n  return _X*(1.0f-_A)+_Y*_A;\n\}                                                                                              \n\n//This function is used to multiply a float3 by a matrix4x4\ninline float3 multVecMatrix( float3 src, float4x4 matrix)\n\{\n    float   x,y,z,w;\n\n    x = src\[0]*matrix\[0]\[0] + src\[1]*matrix\[1]\[0] +\n    src\[2]*matrix\[2]\[0] + matrix\[3]\[0];\n    y = src\[0]*matrix\[0]\[1] + src\[1]*matrix\[1]\[1] +\n    src\[2]*matrix\[2]\[1] + matrix\[3]\[1];\n    z = src\[0]*matrix\[0]\[2] + src\[1]*matrix\[1]\[2] +\n    src\[2]*matrix\[2]\[2] + matrix\[3]\[2];\n    w = src\[0]*matrix\[0]\[3] + src\[1]*matrix\[1]\[3] +\n    src\[2]*matrix\[2]\[3] + matrix\[3]\[3];\n    \n    return float3(x/w, y/w, z/w);\n\}\n\n//This function is used to calculate the screenspace coordinates.\ninline bool computePixelCoordinates( \n    const float3 pWorld, \n    float3 &pRaster, \n    const float4x4 &worldToCamera, \n    const float &canvasWidth, \n    const float &canvasHeight, \n    const int &imageWidth, \n    const int &imageHeight\n) \n\{ \n    float3 pCamera; \n    pCamera = multVecMatrix(pWorld, worldToCamera); \n    float2 pScreen; \n    pScreen.x = pCamera.x / -pCamera.z; \n    pScreen.y = pCamera.y / -pCamera.z; \n    float2 pNDC; \n    pNDC.x = (pScreen.x + canvasWidth * 0.5f) / canvasWidth; \n    pNDC.y = (pScreen.y + canvasHeight * 0.5f) / canvasHeight; \n    pRaster.x = (pNDC.x * imageWidth); \n    pRaster.y = ((pNDC.y) * imageHeight); \n    pRaster.z = -pCamera.z; \n    if (pRaster.x < 0.0f || pRaster.x > imageWidth || \n       pRaster.y < 0.0f || pRaster.y > imageHeight || pRaster.z < 0.0f) \{\n       return false;  \n    \}\n    return true;\n\} \n\n\nkernel PointRender3D : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessRandom, eEdgeClamped> ppos;    //The point position map\n  Image<eRead, eAccessRandom, eEdgeClamped> src;     //The texture map\n  Image<eRead, eAccessRandom, eEdgeClamped> normals;     //The texture map  \n  Image<eRead, eAccessRandom, eEdgeClamped> occlusion;     //The texture map \n  Image<eWrite, eAccessRandom> dst;                 //the output image\n\n  param: //Parameters available to the user\n    float4x4 cam_Matrix;    //The world matrix of the camera\n    float cam_Focal;        //The focal length of the camera\n    float cam_Hapeture;     //The horizontal apeture of the camera\n    int2 WHformat,Vformat;          //The format of the output image\n    float zoom;             //A \"post\" zoom function\n    int _filtering;        //Filter method\n    float _alphaMultiplier; //Additive multiplier\n    bool _pointRender,_wireRender,_facetRender;\n    float _maxPlexDistance; //Additive multiplier\n    int _maxPlexConnections;\n    int _maxPlexType; // 0==Grid, -1==Nearest\n    bool _plexLinedefXY,_plexLinedefX,_plexLinedefY,_plexLinedefXtoY,_plexLinedefAUX; // Define what connections NOT to include\n    bool _plexConnectX,_plexConnectY; //Connect from the edge of x to 0, or edge of y to 0, usually for spheres\n    float _plex_gamma; //The threshold making shorter paths bright and longer paths dark\n    bool _dof_enable; // Enable DOF\n    int _dof_samples; // How many samples per DOF ring\n    int _dof_rings; // How many rings \n    float focalDepth,_depthOfField,_depthMult,_maxDofSize; //DOF Settings\n    float dof_aspect; //Pixel aspect ratio\n    float dof_threshold;\n    float dof_gain;\n    float dof_bias; //bokeh edge bias\n    float dof_fringe; //bokeh chromatic aberration/fringing\n    bool _flatshading,_backfacing,_frontfacing; //Vertex rendering settings\n    int _vertexMode;  //The rendering output mode, (think AOV)\n    bool _depthBuffer; //Non-additive, only render front most pixel\n    float2 _texoffset;\n    int _pointSize;\n    float _gaussigma;\n    bool _depthOcclusion;\n    float depthMultiplier;\n    float _maxLineSteps; //cap the line length to avoid process lock\n    float _lineOffset; //Alow you to shrink or extend the lines\n    float _lineInMultiplier,_lineOutMultiplier; //Control the brightness of the wires at the tips.\n\n  local: //Local variables\n    int max_line_connections;\n    float3 vRaster;\n    float3 pRaster;\n    float3 tRaster;    \n    float3 vWorld;\n    float canvasWidth;\n    float canvasHeight; \n    float matrixData\[4]\[4];\n    float4x4 cameraToWorld;\n    float4x4 worldToCamera;\n\n  void define() \{\n    defineParam(cam_Matrix, \"cam_Matrix\", float4x4( 1.0f,0.0f,0.0f,0.0f,\n                                                    0.0f,1.0f,0.0f,0.0f,\n                                                    0.0f,0.0f,1.0f,0.0f,\n                                                    0.0f,0.0f,0.0f,1.0f));\n    defineParam(cam_Focal,      \"focallength\", 11.5f);\n    defineParam(cam_Hapeture,      \"hapeture\", 24.576f);\n    defineParam(WHformat,      \"format\", int2(2048,2048));\n    defineParam(Vformat,      \"vertexformat\", int2(10,10));\n    defineParam(zoom, \"Zoom\", 1.0f);\n    defineParam(_filtering, \"Filtering Method\", 1); \n    defineParam(_alphaMultiplier, \"_alphaMultiplier\", 1.0f);     \n    defineParam(_pointRender, \"_pointRender\", true);  \n    defineParam(_wireRender, \"_wireRender\", true);\n    defineParam(_facetRender, \"_facetRender\", true);\n    defineParam(_maxPlexDistance, \"_maxLDistance\", 1.0f);    \n    defineParam(_maxPlexConnections, \"_maxLConnections\", 1);    \n    defineParam(_maxPlexType, \"_maxPlexType\", 0); \n    defineParam(_plexLinedefXY, \"_plexLinedefXY\", false);      \n    defineParam(_plexLinedefXtoY, \"_plexLinedefXtoY\", false); //NYI\n    defineParam(_plexLinedefAUX, \"_plexLinedefAUX\", false); \n    defineParam(_plexLinedefX, \"_plexLinedefX\", false);  \n    defineParam(_plexLinedefY, \"_plexLinedefY\", false);  \n    defineParam(_plexConnectX, \"_plexConnectX\", false);      \n    defineParam(_plexConnectY, \"_plexConnectY\", false);   \n    defineParam(_plex_gamma, \"_L_gamma\", 1.0f);\n    //DOF SETTINGS   \n    defineParam(_dof_enable, \"Enable Depth of Field\", false);   \n    defineParam(_dof_samples, \"samples\", 3);    \n    defineParam(_dof_rings, \"rings\", 5);   \n    defineParam(focalDepth, \"focalDepth\", 1.0f);  \n    defineParam(_depthOfField, \"_depthOfField\", 4.0f);  \n    defineParam(_depthMult, \"_depthMult\", 0.1f);  \n    defineParam(_maxDofSize, \"_maxDofSize\", 8.0f);  \n    defineParam(dof_aspect, \"dof_aspect\", 1.0f);  \n    defineParam(dof_threshold, \"dof_threshold\", 1.0f);  \n    defineParam(dof_gain, \"dof_gain\", 0.0f);  \n    defineParam(dof_bias, \"dof_bias\", -2.0f);  \n    defineParam(dof_fringe, \"dof_fringe\", 0.0f); \n    //SHADING SETTINGS \n    defineParam(_flatshading, \"_flatshading\", true);  \n    defineParam(_vertexMode, \"_vertexMode\", 0);  \n    defineParam(_backfacing, \"_backfacing\", true);    \n    defineParam(_frontfacing, \"_frontfacing\", true);        \n    defineParam(_depthBuffer, \"_depthBuffer\", true);  \n    defineParam(_texoffset, \"_texoffset\", float2(0.5f,0.5f)); \n    defineParam(_pointSize, \"_pointSize\", 1); \n    defineParam(_gaussigma, \"_gaussigma\", 1.0f); \n    defineParam(_depthOcclusion, \"_depthOcclusion\", true); \n    defineParam(depthMultiplier, \"depthMultiplier\", 1.0f); \n    defineParam(_maxLineSteps, \"_maxLineSteps\", 4000.0f); \n    defineParam(_lineOffset, \"_lineOffset\", 1.0f); \n    defineParam(_lineInMultiplier, \"_lineInMultiplier\", 1.0f);   \n    defineParam(_lineOutMultiplier, \"_lineOutMultiplier\", 1.0f);     \n\n  \}\n\n  //The init() function is run before any calls to process().\n  void init() \{\n    max_line_connections = 80;\n    canvasWidth = ((cam_Hapeture)/cam_Focal);\n    canvasHeight = ((cam_Hapeture)/cam_Focal)*float(float(WHformat.y)/float(WHformat.x)); \n    float matrixData\[] = \{cam_Matrix\[0]\[0], cam_Matrix\[1]\[0], cam_Matrix\[2]\[0], cam_Matrix\[3]\[0], \n                          cam_Matrix\[0]\[1], cam_Matrix\[1]\[1], cam_Matrix\[2]\[1], cam_Matrix\[3]\[1], \n                          cam_Matrix\[0]\[2], cam_Matrix\[1]\[2], cam_Matrix\[2]\[2], cam_Matrix\[3]\[2], \n                          cam_Matrix\[0]\[3], cam_Matrix\[1]\[3], cam_Matrix\[2]\[3], cam_Matrix\[3]\[3]\};\n    cameraToWorld.setArray(matrixData); //This is a workaround. Due to the buggy matrix implementation, we pass the matrix on from another structure.\n    worldToCamera = cameraToWorld.invert();\n  \}\n\n  //Convert a 3d point position into a 2d raster position.\n  float3 Reconsile3D(float3 _PointPos)\{\n      vWorld = float3(_PointPos.x,_PointPos.y,_PointPos.z)*(zoom);\n      int ret = computePixelCoordinates(vWorld, tRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1]);\n      return tRaster;\n  \}\n\n//------------------------------\n//-------DRAW FUNCTIONS---------\n//------------------------------\n  //Write pixels to output.\n  void writepixel(float posx,float posy, float4 color,int index,float weight=1.0f)\n  \{ \n      if (_depthOcclusion)\{\n        float4 depthSample = occlusion(posx,posy);\n        if (depthSample.x<=vRaster.z && depthSample.w>0.0f)\{\n\n          float depth = (vRaster.z-depthSample.x);\n          color = color*(1.0f-depthSample.w);\n          color = color / (((depth*depth)*depthMultiplier)+1.0f);\n          //return;\n        \}\n      \}\n      float4 finalOutput; //This is used to store the final output\n      float4 dstSample; //This is used to store a sample of the destination\n      if ( dst.bounds.inside( posx, posy ) ) \{ //Test if the pixel written to is inside the output image. \n        if (_depthBuffer) \{\n          dstSample = (float4)dst(posx,posy); //Sample the destination image\n          if ((dstSample.w>color.w)||dstSample.w==0.0f) \{\n            dst(posx,posy) = color;\n          \}\n        \}\n        else \{\n          dstSample = (float4)dst(posx,posy); //Sample the destination image\n          finalOutput = dstSample + (color*_alphaMultiplier*weight);\n          finalOutput.w = dstSample.w + ((color.w*_alphaMultiplier*weight));\n\n          finalOutput.w = (dstSample.w + ((color.w*_alphaMultiplier*weight)))-(dstSample.w * ((color.w*_alphaMultiplier*weight)));\n\n          dst(posx,posy) = finalOutput;\n        \}\n      \} \n  \}\n\n  //Calculate a Bilinear Plot\n  void bilinear_Plot(float2 temppos,float4 color,int index)\n  \{\n    float2 p;\n    p.x=Frac(temppos.x);\n    p.y=Frac(temppos.y);\n    float weights\[] = \{(1.0f-p.x)*(1.0f-p.y), p.x*(1.0f-p.y), (1.0f-p.x)*p.y, p.x*p.y\};\n    int2 _position = int2(floor(temppos.x)-0,floor(temppos.y)-0); \n    writepixel(_position.x,_position.y,color,index,weights\[0]);\n    writepixel(_position.x+1,_position.y,color,index,weights\[1]);\n    writepixel(_position.x,_position.y+1,color,index,weights\[2]);\n    writepixel(_position.x+1,_position.y+1,color,index,weights\[3]);\n  \}\n\n  //NYI, unused!\n  void gaussian(float2 temppos,float4 color,int index)\{\n    float in_x = temppos.x;\n    float in_y = temppos.y;\n    int kernelSize = (_pointSize+1)*2;\n    int subsize = (kernelSize /2)-1;\n    float gKernel\[64]\[64];\n    float sigma = _gaussigma;\n    float intSigma = float(_pointSize);\n    float r, s = intSigma * sigma * sigma;\n\n    float sum = 0.0f;\n\n    // generate 5x5 kernel\n    for (int x = -subsize; x <= subsize; x++)\n    \{\n        for(int y = -subsize; y <= subsize; y++)\n        \{\n            r = float(sqrt(x*x + y*y));\n            gKernel\[x + subsize]\[y + subsize] = (exp(-(r*r)/s))/(3.141592654f * s);\n            sum += gKernel\[x + subsize]\[y + subsize];\n        \}\n    \}\n\n    // normalize the Kernel\n    for (int x = -subsize; x <= subsize; x++)\n    \{\n        for(int y = -subsize; y <= subsize; y++)\n        \{\n            gKernel\[x + subsize]\[y + subsize] /= sum;\n            writepixel(in_x+x,in_y+y,color,index,gKernel\[x + subsize]\[y + subsize]);\n        \}\n    \}\n  \}\n\n//-------------------------------------\n// DrawLine\n// ----------\n// Draw a line between two points, \n// x,y being 2d screenspace pos and z being depth.\n//-------------------------------------\n  void DrawLine(float3 origin, float3 endpoint,float4 _colorA,float4 _colorB) \{\n    float4 _color;\n    float3 delta = origin-endpoint;\n    float3 curPoint = origin;\n    float mag = sqrt(delta.x*delta.x+delta.y*delta.y);\n    mag = min(mag,_maxLineSteps); //Lets not go crazy, we cap it at 10.000 to avoid insane unwated processing time \n    for( float a = 0; a < mag*_lineOffset; a = a + 1.0f )\{\n      curPoint -= (delta/mag);\n      _color = (_colorA*(1.0f-(a/mag*1.0f)))+(_colorB*(a/mag*1.00f));\n      if (_dof_enable)\{\n        Bokeh(curPoint,_color);\n      \}\n      else \{\n        bilinear_Plot(float2(curPoint.x,curPoint.y),_color,1);\n      \}\n      \n    \}\n  \}\n\n//-------------------------------------\n// Point_Render\n//-------------------------------------\nvoid point_render(int2 pos, float3 screen_pos)\{\n  float4 color = src(pos.x,pos.y);\n\n  if (_filtering == 1)\{\n      if (_dof_enable)\{\n        Bokeh(screen_pos,color);\n      \}\n      else \{\n        bilinear_Plot(float2(screen_pos.x,screen_pos.y),color,1);\n      \}\n  \}\n  /*\n  //THIS PART NEEDS TO BE RE-WRITTEN.\n  else if (_filtering == 2)\{ \n      if (_dof_enable)\{\n        Bokeh(screen_pos,color);\n      \}\n      else \{\n        gaussian(float2(screen_pos.x,screen_pos.y),color,1);\n      \}\n  \}\n  */\n  else \{\n      int2 _position = int2(floor(screen_pos.x),floor(screen_pos.y)); \n      if (_depthBuffer) \{color.w = screen_pos.z;\}\n      writepixel(_position.x,_position.y, color,1,1.0f); //OutputSample\n  \}\n\n\}\n\n//-------------------------------------\n// Facet_Render\n//-------------------------------------\n//This function is used to calculate what triangels to draw\nvoid facet_render(int2 pos, float3 _vWorld)\{\n\n    float3 screen_pos = Reconsile3D(_vWorld);\n\n    bool insideX = ppos.bounds.inside(pos.x+1,pos.y );\n    bool insideY = ppos.bounds.inside(pos.x+1,pos.y-1 );\n    bool insideYtop = ppos.bounds.inside(pos.x,pos.y+1);\n    float2 fpos = float2(pos.x,pos.y);\n    float3 V1_Pos,V2_Pos,V1_wPos,V2_wPos,V0_N,V1_N,V2_N;\n    float2 V0_ST,V1_ST,V2_ST;\n    float4 V1_Sample,V2_Sample;\n    float4 _tn;\n    float3 normal0,normal1,normal2;\n    float2 UV_Format = float2(Vformat.x,Vformat.y);\n\n\n    int2 P0 = int2(pos.x-1,pos.y-1);\n    int2 P1 = int2(pos.x+1,pos.y+1);\n    if (_plexConnectX && pos.x == int(Vformat.x))\{\n      insideX == true;\n      P1 = int2(0.0f,pos.y+1);\n    \}\n    if (_plexConnectY && pos.y == int(Vformat.y))\{\n      insideYtop == true;\n      P1 = int2(pos.x+1,0);\n    \} \n\n    if (_plexConnectY && pos.y == 0)\{\n      insideY == true;\n      P0 = int2(pos.x-1,int(UV_Format.y));\n    \} \n\n    if (!_flatshading) \{\n      _tn = normals(pos.x,pos.y);\n      V0_N =float3(_tn.x,_tn.y,_tn.z);\n    \}\n    V0_ST = float2(pos.x,pos.y)/UV_Format;\n\n  if (insideX) \{\n    V2_Sample = ppos(P1.x,pos.y);\n    V2_ST = float2(P1.x,pos.y)/UV_Format;\n    V2_wPos = float3(V2_Sample.x,V2_Sample.y,V2_Sample.z);\n    V2_Pos = Reconsile3D(V2_wPos);\n    if (!_flatshading) \{\n      _tn = normals(P1.x,pos.y);\n      V2_N =float3(_tn.x,_tn.y,_tn.z);\n    \}\n        \n\n    if (V2_Sample.w != 0.0f) \{ \n\n      if (insideY) \{\n        V1_Sample = ppos(P1.x,P0.y);\n        V1_ST = float2(P1.x,P0.y)/UV_Format;\n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (!_flatshading) \{\n          _tn = normals(P1.x,P0.y);\n          V1_N =float3(_tn.x,_tn.y,_tn.z);\n        \}\n        if (V1_Sample.w != 0.0f) \{ \n          DrawTriangle(screen_pos,V2_Pos,V1_Pos,_vWorld,V2_wPos,V1_wPos,V0_N,V2_N,V1_N,V0_ST,V2_ST,V1_ST);\n        \}\n      \}\n      if (insideYtop) \{\n        V1_Sample = ppos(pos.x,P1.y);\n        V1_ST = float2(pos.x,P1.y)/UV_Format;        \n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (!_flatshading) \{\n          _tn = normals(pos.x,P1.y);\n          V1_N =float3(_tn.x,_tn.y,_tn.z);\n        \}        \n        if (V1_Sample.w != 0.0f) \{ \n          DrawTriangle(screen_pos,V1_Pos,V2_Pos,_vWorld,V1_wPos,V2_wPos,V0_N,V1_N,V2_N,V0_ST,V1_ST,V2_ST);\n        \}\n      \}\n    \}\n  \}\n\}\n\n\n\n//This function will calculate if pixel C is inside the triangle\nfloat edgeFunction(float3 a, float3 b, float3 c) \n\{ \n    return ((c.x - a.x) * (b.y - a.y) - (c.y - a.y) * (b.x - a.x)); \n\} \n\nfloat3 CalculateSurfaceNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat3 CalculateVertexNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat Distance(float3 _a,float3 _b)\n\{\n          float xd = _a.x - _b.x;\n          float yd = _a.y - _b.y;\n          float zd = _a.z - _b.z;\n          return sqrt(xd*xd + yd*yd + zd*zd);\n\}\n\nvoid DrawTriangle(float3 V0, float3 V1, float3 V2,float3 WP0, float3 WP1, float3 WP2,float3 N0, float3 N1, float3 N2, float2 st0,float2 st1,float2 st2) \{\n\n  // Precompute reciprocal of vertex z-coordinate \n  V0.z = 1.0f / V0.z, V1.z = 1.0f / V1.z, V2.z = 1.0f / V2.z; \n\n  float2 st0n = st0 * V0.z;\n  float2 st1n = st1 * V1.z; \n  float2 st2n = st2 * V2.z; //Normal version of ST\n\n  bool inside; \n  float X0 = Fmin(V0.x,V1.x,V2.x)-1.0f;\n  float X1 = Fmax(V0.x,V1.x,V2.x)+1.0f;\n  float Y0 = Fmin(V0.y,V1.y,V2.y)-1.0f;\n  float Y1 = Fmax(V0.y,V1.y,V2.y)+1.0f;\n  float area = edgeFunction(V2, V1, V0);\n\n\n  float2 sampos = float2(st0.x*float(Vformat.x),st0.y*float(Vformat.y));\n  float4 text0 = src(sampos.x,sampos.y);\n  sampos = float2(st1.x*float(Vformat.x),st1.y*float(Vformat.y));\n  float4 text1 = src(sampos.x,sampos.y);\n  sampos = float2(st2.x*float(Vformat.x),st2.y*float(Vformat.y));  //Why do we have to do this? =(\n  float4 text2 = src(sampos.x,sampos.y);\n  sampos = float2(min(min(st0.x,st1.x),st2.x)*float(Vformat.x),min(min(st0.y,st1.y),st2.y)*float(Vformat.y));\n  float4 text3 = src(sampos.x,sampos.y);\n\n\n  for( int x = X0; x < X1 ; x++) \{\n    for( int y = Y0; y < Y1 ; y++) \{\n      float3 pixelSample(x + _texoffset.x, y + _texoffset.y,0.0f); \n\n      //This is the part where we test if the current pixel is inside the triangle\n      //We check both for front facing and back faing options\n      float w0 = edgeFunction(V1, V0, pixelSample); //Front Facing\n      float w1 = edgeFunction(V2, V1, pixelSample); \n      float w2 = edgeFunction(V0, V2, pixelSample); \n      float w3 = edgeFunction(V0, V1, pixelSample); //Back Facing\n      float w4 = edgeFunction(V1, V2, pixelSample); \n      float w5 = edgeFunction(V2, V0, pixelSample);\n\n      //writepixel(x,y, float4(w1),1,1.0f);\n      if ((w0 >= 0 && w1 >= 0 && w2 >= 0 && _frontfacing) || (w3 >= 0 && w4 >= 0 && w5 >= 0 && _backfacing)) \{ //The curent pixel is inside the triangle\n\n       // calculate vectors from point f to vertices p1, p2 and p3:\n       float3 f1 = V0-pixelSample;\n       float3 f2 = V1-pixelSample;\n       float3 f3 = V2-pixelSample;\n       // calculate the areas and factors (order of parameters doesn't matter):\n       float a = length(cross(V0-V1,V0-V2 )); // main triangle area a\n       area = length(V0-V1)+length(V0-V2)+length(V1-V2);\n\n        w0 /= area; \n        w1 /= area; \n        w2 /= area; \n\n        w3 /= area; \n        w4 /= area; \n        w5 /= area; \n\n       float a1 = length(cross(f2, f3)) / a; // p1's triangle area / a\n       float a2 = length(cross(f3, f1)) / a; // p2's triangle area / a \n       float a3 = length(cross(f1, f2)) / a; // p3's triangle area / a\n       float a_magnitude = a1+a2+a3;\n       a1 = a1/a_magnitude;\n       a2 = a2/a_magnitude;\n       a3 = a3/a_magnitude;\n       float z = 1.0f / (V0.z * a1 + V1.z * a2 + V2.z * a3); \n\n\n        // find the uv corresponding to point f (uv1/uv2/uv3 are associated to p1/p2/p3):\n        float2 uv = st0 * a1 + st1 * a2 + st2 * a3;\n        float2 st = st0 * w0 + st1 * w1 + st2 * w2; \n        st *= z;      \n\n\n        //Calculate normals. Eighter we have flat shading, else we calculate a normal per pixel\n        float3 normalB;\n        if (_flatshading) \{\n          normalB = CalculateSurfaceNormals(WP0,WP1,WP2);\n\n        \}\n        else \{\n          float3 c0 = N2/float3(V0.z); \n          float3 c1 = N0/float3(V1.z); \n          float3 c2 = N1/float3(V2.z);  \n\n          normalB.x = w0 * c0.x + w1 * c1.x + w2 * c2.x; \n          normalB.y = w0 * c0.y + w1 * c1.y + w2 * c2.y; \n          normalB.z = w0 * c0.z + w1 * c1.z + w2 * c2.z; \n\n          normalB.x *= z, normalB.y *= z, normalB.z *= z; \n        \}\n        normalB = normalize(normalB);\n\n        //CALCULATE THE OBJECT TEXTURE COORDINATES\n        float zn = 1.0f / (V0.z * w0 + V1.z * w1 + V2.z * w2); \n        st = st0n * w0 + st1n * w1 + st2n * w2; \n        st *= zn;   \n        //--END \n\n        float3 Wpos = WP0*a1 + WP1*a2 + WP2*a3; //World Position.\n        float3 ViewNormal = normalize(float3(cameraToWorld\[3]\[0],cameraToWorld\[3]\[1],cameraToWorld\[3]\[2])-Wpos);\n\n        float nDotView =  dot(normalB,ViewNormal);\n        nDotView = 1.0f-fabs(nDotView); //make sure that the view normal ramps back around when doing backface\n        float4 tempout;\n\n        //Flatshading or regular?\n        if (!_flatshading) \{\n          tempout = text0 * a1 + text1 * a2 + text2 * a3; \n        \}\n        else\{\n          tempout = text3;\n        \}\n\n        //Additional Render Modes\n        if (_vertexMode == 1)\{\n          tempout = float4(a1,a2,a3,1.0f);\n        \}\n        else if (_vertexMode == 2)\{\n          tempout = float4(normalB.x,normalB.y,normalB.z,1.0f);\n        \}\n        else if (_vertexMode == 3)\{\n          tempout = float4(nDotView,nDotView,nDotView,1.0f);\n        \}\n        else if (_vertexMode == 4)\{\n          tempout = float4(uv.x,uv.y,0.0f,1.0f);\n        \}       \n        else if (_vertexMode == 5)\{\n          tempout = float4(st.x,st.y,0.0f,1.0f);\n        \}               \n        else if (_vertexMode == 6)\{\n          tempout = float4(ViewNormal.x,ViewNormal.y,ViewNormal.z,1.0f);\n        \}             \n        else if (_vertexMode == 7)\{\n          tempout = float4(Wpos.x,Wpos.y,Wpos.z,1.0f);\n        \}   \n\n        if (_depthBuffer)\{\n          writepixel(x,y, float4(tempout.x,tempout.y,tempout.z,z),1,1.0f);  \n        \}\n        else \{\n          if (_dof_enable)\{\n            Bokeh(float3(x,y,z),float4(tempout.x,tempout.y,tempout.z,z));\n          \}\n          else \{\n            bilinear_Plot(float2(x,y),float4(tempout.x,tempout.y,tempout.z,z),1);\n          \}\n        \}\n\n      \}  \n\n    \}\n  \}\n\}\n\n//-------------------------------------\n// Wire_Render\n//-------------------------------------\nvoid wire_render(int2 pos) \{\n  float4 temp = float4(0.0f,0.0f,0.0f,FLT_MAX);\n  float4 wire_ref_sample;\n  int2 tempXY = int2(0,0);\n  float4 plexlist\[11] = \{temp,temp,temp,temp,temp,temp,temp,temp,temp,temp,temp\}; \n  int2 plexlistXY\[11] = \{tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY\};\n  int plex_count = 0; //We use this to figure how many points that should connect.\n  float plex_dist;\n  float3 plex_position,plex_position_b;\n  float4 temp_pos, temp_pos_b; //Temporary Position Containers\n  if (_maxPlexType == -1) \{ //Used for random connection types\n    for( int x = 0; x < max_line_connections ; x++)\{ //THIS 80 NUMBER IS THE LIMIT TO AVOID TOO SLOW PROCESSING!\n      for( int y = 0; y < max_line_connections ; y++)\{\n        wire_ref_sample = ppos(x,y);\n        if (wire_ref_sample.w != 0.0f && pos.x!=x && pos.y != y) \{ \n          plex_position = float3(wire_ref_sample.x,wire_ref_sample.y,wire_ref_sample.z)*(zoom);\n          float xd = plex_position.x - vWorld.x;\n          float yd = plex_position.y - vWorld.y;\n          float zd = plex_position.z - vWorld.z;\n          float plex_dist = sqrt(xd*xd + yd*yd + zd*zd);\n          if (plex_dist<_maxPlexDistance)\{\n            plex_count = min(10,plex_count+1); //Add one to the count\n            for( int h = 0; h < plex_count+1 ; h++) \{ //Loop thought all the points. If the distance is shorter then insert it into the array and push the rest of the array down\n              if (plex_dist < plexlist\[h].w) \{                  \n                for( int i = plex_count+1; i > h ; i--) \{\n                  plexlist\[i] = plexlist\[i-1];\n                  plexlistXY\[i] = plexlistXY\[i-1];\n                \}\n                plexlist\[h] = float4(plex_position.x,plex_position.y,plex_position.z,plex_dist);\n                plexlistXY\[h] = int2(x,y);\n                break;        \n              \}\n            \}\n          \} \n        \}\n      \}\n    \}\n  \}\n  else\{ //Used for standard connection types\n    float4 temp_pos;\n    bool insideX = !(Vformat.x < pos.x+1);\n    bool insideY = !(Vformat.y < pos.y+1);\n\n\n    if (!_plexLinedefAUX)\{\n      temp_pos = normals(pos.x,pos.y);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,vWorld+plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    if ( insideX && !_plexLinedefX) \{\n      temp_pos = ppos(pos.x+1,pos.y );\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && !_plexLinedefX) \{\n      temp_pos = ppos(0,pos.y);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    if ( insideY && !_plexLinedefY) \{\n      temp_pos = ppos(pos.x,pos.y+1);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\}                          \n    \}\n    else if ( _plexConnectY  && !_plexLinedefY) \{\n      temp_pos = ppos(pos.x,0);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    //_plexConnect\n    if ( insideX && insideY && !_plexLinedefXY) \{              \n      temp_pos = ppos(pos.x+1,pos.y+1);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && _plexConnectY && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && insideY && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectY && insideX && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n  \}   \n\n  //now that all the connections have been sorted by distance then we connect the dots.\n  for( int x = 0; x < min(_maxPlexConnections,plex_count) ; x++)\{\n    plex_position = float3(plexlist\[x].x,plexlist\[x].y,plexlist\[x].z);\n    plex_dist = plexlist\[x].w;\n\n\n    float plex_distribution = 1.0f-((plexlist\[x].w-plexlist\[0].w)/((plexlist\[min(_maxPlexConnections,plex_count)].w-plexlist\[0].w)+0.00001f)); //Where does it lie between the best and the worst distance?\n    //plexlistXY\n\n    float4 plex_col = float4(pow(1.0f-(plex_dist/_maxPlexDistance),1.0f/_plex_gamma))*float4(plex_distribution); //This one is quite cool aswell, but does leave the center ones a bit too focused \n    float4 plex_colorA = src(pos.x,pos.y);\n    float4 plex_colorB = src( plexlistXY\[x].x,plexlistXY\[x].y);\n    plex_col *= 0.1f;\n\n    computePixelCoordinates(plex_position, pRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1]);\n    if (dst.bounds.inside(int(vRaster.x),int(vRaster.y)) || dst.bounds.inside(int(pRaster.x),int(pRaster.y)))\{\n        DrawLine(vRaster,pRaster,(plex_colorA*plex_col)*_lineInMultiplier,(plex_colorB*plex_col)*_lineOutMultiplier);\n    \}\n  \}\n\}\n\nvoid wire_connection(float3 p_source,float3 p_target, float4 (&p_plexlist)\[11], int2 (&p_plexlistXY)\[11],int &p_plexcount,int2 position) \{\n  float xd = p_target.x - p_source.x;\n  float yd = p_target.y - p_source.y;\n  float zd = p_target.z - p_source.z;\n  float plex_dist = sqrt(xd*xd + yd*yd + zd*zd);\n  if (plex_dist<_maxPlexDistance)\{\n    p_plexcount = min(11,p_plexcount+1); //Add one to the count\n    for( int h = 0; h < p_plexcount+1 ; h++) \{ //Loop thought all the points. If the distance is shorter then insert it into the array and push the rest of the array down\n      if (plex_dist < p_plexlist\[h].w) \{                  \n        for( int i = p_plexcount+1; i > h ; i--) \{\n          p_plexlist\[i] = p_plexlist\[i-1];\n          p_plexlistXY\[i] = p_plexlistXY\[i-1];\n        \}\n        p_plexlist\[h] = float4(p_target.x,p_target.y,p_target.z,plex_dist);\n        p_plexlistXY\[h] = int2(position.x,position.y);\n        break;        \n      \}\n    \}  \n  \}\n\}\n//-------END OF WIRE RENDER FUNCTIONS---------\n\n\n\n\n//-------------------------------\n//-------BOKEH FUNCTIONS---------\n//thanks to: http://devlog-martinsh.blogspot.dk/2011/11/glsl-depth-of-field-with-bokeh-v21.html\nfloat2 rand(float2 coord) //generating noise/pattern texture for dithering\n\{\n  float noiseX = ((Frac(1.0-coord.x*(WHformat\[0]/2.0))*0.25)+(Frac(coord.y*(WHformat\[1]/2.0))*0.75))*2.0-1.0;\n  float noiseY = ((Frac(1.0-coord.x*(WHformat\[0]/2.0))*0.75)+(Frac(coord.y*(WHformat\[1]/2.0))*0.25))*2.0-1.0;\n  noiseX = clamp(Frac(sin(dot(coord ,float2(12.9898f,78.233f))) * 43758.5453f),0.0f,1.0f)*2.0f-1.0f;\n  noiseY = clamp(Frac(sin(dot(coord ,float2(12.9898f,78.233f)*2.0f)) * 43758.5453f),0.0f,1.0f)*2.0-1.0f;\n  return float2(noiseX,noiseY);\n\}\n//-------------------------------------\n// Bokeh\n//-------------------------------------\nvoid Bokeh(float3 pos,float4 color)\{\n  float blur = 0.0;\n  blur = clamp((fabs(pos.z - focalDepth)/_depthOfField)*100.0f,-_maxDofSize,_maxDofSize);\n  \n  float w = (1.0/WHformat.x)*blur;//+noise.x;\n  float h = (1.0/(WHformat.x*dof_aspect))*blur;//+noise.y;\n  float3 v3_col = float3(color.x,color.y,color.z);\n  int ringsamples;\n  float s = 1.0;  \n\n  for (int i = 1; i <= _dof_rings; i += 1)\n  \{   \n    ringsamples = i * _dof_samples; \n    for (int j = 0 ; j < ringsamples ; j += 1)  \n    \{ \n      s += (1.0f*mix(1.0f,(float(i))/(float(_dof_rings)),dof_bias)*1.0f); //No need to do this in the loop\n    \}\n  \}\n\n  for (int i = 1; i <= _dof_rings; i += 1)\n  \{   \n    ringsamples = i * _dof_samples;\n     \n    for (int j = 0 ; j < ringsamples ; j += 1)   \n    \{\n      float step = PI*2.0 / float(ringsamples);\n      float pw = (cos(float(j)*step)*(float(i)/_dof_rings));\n      float ph = (sin(float(j)*step)*(float(i)/_dof_rings));\n      float p = 1.0;\n\n      float posx = pos.x+((pw*w)*blur);\n      float posy = pos.y+((ph*h)*blur);\n\n\n      float3 lumcoeff = float3(0.299,0.587,0.114);\n      float lum = dot(v3_col, lumcoeff);\n      float thresh = max((lum-dof_threshold)*dof_gain, 0.0f);\n      v3_col+mix(float3(0.0),v3_col,thresh*blur);\n\n      float3 col = (v3_col*mix(1.0,(float(i))/(float(_dof_rings)),dof_bias)*p)/s; \n      bilinear_Plot(float2(posx,posy),float4(col.x,col.y,col.z,color.w/(_dof_rings*_dof_rings)),1);\n    \}\n  \}\n\}\n//-------END OF BOKEH FUNCTIONS---------\n\n\n\n//-------------------------------------\n// Process\n//-------------------------------------\n  void process(int2 pos) \{\n    float4 _sample = ppos(pos.x,pos.y); //Get the XYZ Coordinates\n    float2 posf = float2(pos.x,pos.y);\n\n    if (_sample.w != 0.0f) \{  //No need to process if there is no data.\n\n      //Convert worldspace coordinates to screenspcace coordinates.\n      vWorld = float3(_sample.x,_sample.y,_sample.z)*(zoom);\n      int ret = computePixelCoordinates(vWorld, vRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1]);\n      if (ret) \{ //Only create points that are visible on screen\n        if (_pointRender)\{\n          point_render(pos,vRaster);\n        \}\n      \} //Pointrender over\n\n      if (_wireRender && _maxPlexConnections>=1) \{\n        if (max(pos.x,pos.y)<=max_line_connections || (_maxPlexType==0))\{ // Don't process more wires than allowed in nearest mode.\n          wire_render(pos);\n        \}\n      \} //WireRender over\n\n      if (_facetRender) \{\n        facet_render(pos,float3(_sample.x,_sample.y,_sample.z));\n      \}  //FacetRender over\n      \n    \}\n  \} //----> process\n\};\n"
  useGPUIfAvailable false
  rebuild ""
  PointRender3D_cam_Matrix {
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
    }
  PointRender3D_focallength {{parent.Camera1.focal}}
  PointRender3D_hapeture {{parent.Camera1.haperture}}
  PointRender3D_format {{Settings_Format.width} {Settings_Format.height}}
  PointRender3D_vertexformat {{parent.InputFormat.box.r-1} {parent.InputFormat.box.t-1}}
  PointRender3D__alphaMultiplier {{parent.AlphaMultiplier}}
  PointRender3D__pointRender {{parent.RenderMode==0}}
  PointRender3D__wireRender {{parent.RenderMode==1}}
  PointRender3D__facetRender {{parent.RenderMode==2}}
  PointRender3D__maxLDistance {{parent.wire_maxdistance}}
  PointRender3D__maxLConnections {{parent.wire_connections}}
  PointRender3D__maxPlexType {{-parent.wire_type}}
  PointRender3D__plexLinedefXY {{!parent.connect_xy}}
  PointRender3D__plexLinedefX {{!parent.connect_x}}
  PointRender3D__plexLinedefY {{!parent.connect_y}}
  PointRender3D__plexLinedefAUX {{!connect_aux}}
  PointRender3D__plexConnectX {{parent.CloseX}}
  PointRender3D__plexConnectY {{parent.CloseY}}
  PointRender3D__L_gamma {{parent.wire_Threshold}}
  "PointRender3D_Enable Depth of Field" {{parent.dof_enable}}
  PointRender3D_samples {{3*(parent.Dof_Quality*parent.Dof_Quality+1)}}
  PointRender3D_rings {{3*(parent.Dof_Quality*parent.Dof_Quality+1)}}
  PointRender3D_focalDepth {{parent.dof_focaldepth}}
  PointRender3D__depthOfField {{parent.dof_dof}}
  PointRender3D__depthMult {{parent.DofMultiplier}}
  PointRender3D__maxDofSize {{parent.dof_maxSize*400}}
  PointRender3D_dof_aspect {{parent.dof_Aspect}}
  PointRender3D_dof_bias {{parent.dof_bias}}
  PointRender3D__flatshading {{parent.facet_flatShading}}
  PointRender3D__backfacing {{parent.facet_backface}}
  PointRender3D__frontfacing {{parent.facet_front}}
  PointRender3D__vertexMode {{parent.renderMode}}
  PointRender3D__depthBuffer {{parent.facet_depth}}
  PointRender3D__texoffset {-0.5 0.5}
  PointRender3D__pointSize 0
  PointRender3D__depthOcclusion {{parent.UseOcclusionMap}}
  PointRender3D__maxLineSteps {{parent.maxSamples}}
  PointRender3D__lineOffset {{parent.lineoffset}}
  PointRender3D__lineInMultiplier {{parent.inGain}}
  PointRender3D__lineOutMultiplier {{parent.outGain}}
  format "1280 720 0 0 1280 720 1 HD_720"
  rebuild_finalise ""
  name BlinkScript1
  selected true
  xpos -27
  ypos 159
 }
 Reformat {
  format {{{Settings_Format.format}}}
  resize none
  center false
  name Reformat1
  xpos -27
  ypos 343
 }
 Group {
  name SoftLook
  xpos -27
  ypos 460
  disable {{!parent.HighlightCompression}}
  addUserKnob {20 User}
  addUserKnob {26 ""}
  addUserKnob {7 Add R 0 4}
  Add {{parent.HighlightCeiling}}
  addUserKnob {7 Offset R 0 4}
  Offset {{parent.Compression}}
 }
  Input {
   inputs 0
   name Input1
   xpos -248
   ypos 500
  }
set N4743d470 [stack 0]
  Expression {
   expr0 r/(r+parent.Offset)*parent.Add
   expr1 g/(g+parent.Offset)*parent.Add
   expr2 b/(b+parent.Offset)*parent.Add
   expr3 a/(a+parent.Offset)*parent.Add
   name Expression1
   xpos -339
   ypos 576
  }
push $N4743d470
  ShuffleCopy {
   inputs 2
   red red
   green green
   blue blue
   alpha alpha2
   name ShuffleCopy1
   xpos -248
   ypos 576
  }
  Output {
   name Output1
   xpos -248
   ypos 651
  }
 end_group
 TimeBlur {
  divisions {{parent.Samples}}
  shutter {{parent.Shutter}}
  shutteroffset centred
  shuttercustomoffset 0
  name MotionBlur
  xpos -27
  ypos 581
  disable {{1-parent.mb_enable x89 0}}
 }
 ShuffleCopy {
  inputs 2
  in pos
  red red
  green green
  blue blue
  out pos
  name ShuffleCopy1
  xpos -27
  ypos 673
  disable true
 }
 Output {
  name Output1
  xpos -27
  ypos 710
 }
 Input {
  inputs 0
  name InputCamera
  xpos -1129
  ypos 116
  number 1
 }
 Camera2 {
  focal {{parent.FocalLength}}
  haperture {{parent.horizontalApeture}}
  name Camera1
  xpos -1119
  ypos 223
  addUserKnob {20 Ivy}
  addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.toolbox.v1.nodes.docs', fromlist=\['open_docs_name']).open_docs_name('IvyTab')" +STARTLINE}
  addUserKnob {26 divider4 l "" +STARTLINE}
  addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
  _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
  addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
  addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
  addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
  _expressions {{curve}}
  addUserKnob {26 divider0 l "" +STARTLINE}
  addUserKnob {20 dbinfo l "DB Info" n 1}
  dbinfo 0
  addUserKnob {1 twig_dnuuid l "Twig Id"}
  addUserKnob {1 stalk_dnuuid l "Stalk Id"}
  addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
  addUserKnob {1 leaf_dnuuid l "Leaf Id"}
  addUserKnob {26 divider1 l "" +STARTLINE}
  addUserKnob {1 twigtype l "Twig Type"}
  addUserKnob {1 leaf_label l Leaf}
  addUserKnob {1 ivy_version l Version}
  addUserKnob {43 ivy_notes l Notes}
  addUserKnob {26 divider2 l "" +STARTLINE}
  addUserKnob {1 build_label l "Build Label"}
  addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
 }
 Reformat {
  inputs 0
  format "2156 1806 0 0 2156 1806 2 JOYRIDE Working"
  resize none
  center false
  name Settings_Format
  xpos -1404
  ypos 241
 }
push $N47402de0
 PositionToPoints2 {
  display textured
  render_mode textured
  P_channel pos
  detail 0.25
  pointSize 0.6
  name PreviewNode
  xpos -22
  ypos 8
  disable {{!parent.Enable3DPreview}}
 }
push $N4769b840
 Reformat {
  type "to box"
  box_width 100
  box_height 100
  box_fixed true
  scale 0.1
  resize none
  filter impulse
  black_outside true
  name Reformat3
  xpos -633
  ypos -1109
  disable {{!wire_type==1}}
 }
push $N474dc980
 Crop {
  box {0 0 {width} {height}}
  reformat true
  crop false
  name InputFormat
  xpos -456
  ypos -402
 }
end_group
TimeOffset {
 time_offset -1182
 time ""
 name TimeOffset4
 selected true
 xpos 12347
 ypos 32690
}
Dot {
 name Dot366
 selected true
 xpos 12381
 ypos 32963
}
FileOut {
 name FileOut3
 tile_color 0xbfbf00ff
 label 2DparticleFX_2
 selected true
 xpos 12347
 ypos 33029
 icon smartgrade.png
 channels rgba
 _destination /jobs
 _stemstatus ""
 file ""
 proxy ""
 fileProxy ""
 views {main}
 first 1001
 last 1400
 pbb true
 smart_grade on
 dw_compression_level 0
 tex_metadata "default metadata and exr/*"
 disable_autolabel_format true
 _defaults "\{'smart_grade': 0, 'compression': 1, 'tile_color': 3216965887, 'pbb': True, 'dw_compression_level': 0, 'label': u'2DparticleFX_2', 'exr_metadata': 2\}"
 _format ""
 _generator "NukeRenderGenerator dnnuke.core.render.v1"
 _ivyVals "\{'variant': None, 'host': None, 'versionNum': '5', 'twigType': 'spider://query@TwigType.one?TwigType.code==2d', 'twigNameTags': \{'subtask': u'precomp', 'task': u'comp', 'label': u'2DparticleFX_2', 'out_dir': u'ELEMENT'\}, 'job': 'STONE', 'stalk': None, 'stalkAttrs': \{'framerange': '1017-1053'\}, 'twig': None, 'stem': 'spider://query@Stem.one?Stem.dnuuid==cfb45239-1375-4623-b0a4-12b2a5fba3d0&Stem.stemname==110_fof_0010&Stem.stemtype==shot'\}"
 _old_filetype exr
 _stalkname E_110_fof_0010_comp_precomp_2DparticleFX_2_v005
 _twigtype 2d
 _wrapper "FileOut dnnuke.nodes.file_out.wrapper"
 beforeRender ""
 beforeFrameRender ""
 afterFrameRender ""
 afterRender ""
 renderProgress ""
 _invert_grade /tools/STONE/ivyasset/110_fof_0010/ivy/grade/GRD_110_fof_0010_neutral_v001/GRD_110_fof_0010_neutral_v001.grade
}
BagAndTagKeep {
 name BagAndTagKeep7
 selected true
 xpos 12347
 ypos 33121
}
Read {
 inputs 0
 file_type exr
 file /jobs/JOYRIDE/hap0850/ELEMENT/E_hap0850_comp_precomp_2DparticleFX_2_v005/2156x1806/E_hap0850_comp_precomp_2DparticleFX_2_v005.####.exr
 localizationPolicy off
 format "2156 1806 0 0 2156 1806 2 JOYRIDE Working"
 proxy_format "640 480 0 0 640 480 1 PC_Video"
 first 1001
 last 1400
 origfirst 1001
 origlast 1400
 origset true
 smartGrade true
 name Read194
 selected true
 xpos 12343
 ypos 33167
 postage_stamp_frame 1200
 addUserKnob {20 Ivy}
 addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.toolbox.v1.nodes.docs', fromlist=\['open_docs_name']).open_docs_name('IvyTab')" +STARTLINE}
 addUserKnob {26 divider4 l "" +STARTLINE}
 addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
 _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
 addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
 addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
 _ivyFile /jobs/JOYRIDE/hap0850/ELEMENT/E_hap0850_comp_precomp_2DparticleFX_2_v005/2156x1806/E_hap0850_comp_precomp_2DparticleFX_2_v005.####.exr
 addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
 _expressions {{curve}}
 addUserKnob {26 divider0 l "" +STARTLINE}
 addUserKnob {20 dbinfo l "DB Info" n 1}
 dbinfo 0
 addUserKnob {1 twig_dnuuid l "Twig Id"}
 twig_dnuuid 776d86dd-5bde-4453-9885-d4e475541d96
 addUserKnob {1 stalk_dnuuid l "Stalk Id"}
 stalk_dnuuid 06d748d8-333e-4634-ac16-0e3ec60b2b7c
 addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
 twigtype_dnuuid e9f824fa-c932-4c3e-acbd-c612fb5ea846
 addUserKnob {1 leaf_dnuuid l "Leaf Id"}
 leaf_dnuuid c6abf93f-61a6-4a6e-aa5c-34247257d065
 addUserKnob {26 divider1 l "" +STARTLINE}
 addUserKnob {1 twigtype l "Twig Type"}
 twigtype elmr
 addUserKnob {1 leaf_label l Leaf}
 leaf_label main_proxy0
 addUserKnob {1 ivy_version l Version}
 ivy_version 5
 addUserKnob {43 ivy_notes l Notes}
 addUserKnob {26 divider2 l "" +STARTLINE}
 addUserKnob {1 build_label l "Build Label"}
 addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
}
BagAndTagKeep {
 name BagAndTagKeep8
 selected true
 xpos 12343
 ypos 33305
}
StickyNote {
 inputs 0
 name StickyNote21
 label "part D"
 note_font_size 50
 selected true
 xpos 8085
 ypos 31907
 addUserKnob {20 BagAndTag}
 addUserKnob {6 partOfRebuildScript l "This node is part of the rebuild script DO NOT DELETE" -STARTLINE +DISABLED}
 partOfRebuildScript true
}
push $cut_paste_input
Camera2 {
 translate {5 0.1 0.07756583}
 rotate {0 87.69209641 0}
 name Camera13
 selected true
 xpos 8554
 ypos 32499
 addUserKnob {20 Ivy}
 addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.toolbox.v1.nodes.docs', fromlist=\['open_docs_name']).open_docs_name('IvyTab')" +STARTLINE}
 addUserKnob {26 divider4 l "" +STARTLINE}
 addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
 _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
 addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
 addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
 addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
 _expressions {{curve}}
 addUserKnob {26 divider0 l "" +STARTLINE}
 addUserKnob {20 dbinfo l "DB Info" n 1}
 dbinfo 0
 addUserKnob {1 twig_dnuuid l "Twig Id"}
 addUserKnob {1 stalk_dnuuid l "Stalk Id"}
 addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
 addUserKnob {1 leaf_dnuuid l "Leaf Id"}
 addUserKnob {26 divider1 l "" +STARTLINE}
 addUserKnob {1 twigtype l "Twig Type"}
 addUserKnob {1 leaf_label l Leaf}
 addUserKnob {1 ivy_version l Version}
 addUserKnob {43 ivy_notes l Notes}
 addUserKnob {26 divider2 l "" +STARTLINE}
 addUserKnob {1 build_label l "Build Label"}
 addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
}
Group {
 inputs 0
 name Point_Grid1
 tile_color 0x434343ff
 note_font_color 0x7dadf9ff
 selected true
 xpos 8822
 ypos 32091
 addUserKnob {20 User}
 addUserKnob {26 text l "" +STARTLINE T "Point Grid v1.0\n\nThis node generates a grid.\nAs it is defined in a non-euclidian space, \nmost of the shaders and wire or facet rendering won't work. "}
 addUserKnob {26 ""}
 addUserKnob {41 size_x l "Number of Points" T CONTROLER.size_x}
 addUserKnob {41 size_y l "" -STARTLINE T CONTROLER.size_y}
 addUserKnob {41 size_z l "" -STARTLINE T CONTROLER.size_z}
 addUserKnob {18 Position}
 Position {0 0 0}
 addUserKnob {6 Position_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Position_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Position_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {18 Scale}
 Scale {2 4 2}
 addUserKnob {6 Scale_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Scale_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Scale_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
}
 NoOp {
  inputs 0
  name CONTROLER
  xpos 224
  ypos -62
  addUserKnob {20 User}
  addUserKnob {3 VoxelDensity}
  VoxelDensity {{ceil(pow(size_x*size_y*size_z,1/3))}}
  addUserKnob {3 size_x l "Voxel Grid Size"}
  size_x 140
  addUserKnob {3 size_y l "" -STARTLINE}
  size_y 100
  addUserKnob {3 size_z l "" -STARTLINE}
  size_z 130
 }
 Crop {
  inputs 0
  box {0 0 {ceil(sqrt(pow(parent.CONTROLER.VoxelDensity,3)))} {sqrt(pow(parent.CONTROLER.VoxelDensity,3))}}
  reformat true
  crop false
  name Crop3
  xpos 372
  ypos -108
 }
 BlinkScript {
  recompileCount 9
  ProgramGroup 1
  KernelDescription "2 \"InvertKernel\" iterate pixelWise 21048e0522d3524e03cb582229852f2e33dbe569cd86686b92f460148f8700cf 2 \"src\" Read Point \"dst\" Write Point 1 \"Cube Size\" Int 3 IAAAACAAAAAgAAAAAAAAAA== 1 \"cube_size\" 3 1 0"
  kernelSource "kernel InvertKernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;  \n  Image<eWrite> dst;\n\n  param:\n    int3 cube_size;\n\n  local:\n    \n\n  void define() \{\n    defineParam(cube_size, \"Cube Size\", int3(32,32,32));\n  \}\n\n  void init() \{\n    \n  \}\n\n  void process(int2 pos) \{\n    int t_offset = (pos.x+(pos.y*src.bounds.width()));\n    float4 position;\n    float maxSize = max(max(cube_size.x,cube_size.y),cube_size.z);\n\n    position.x = fmod(t_offset,cube_size.x)/float(cube_size.x-1);\n    position.y = fmod(int(t_offset/cube_size.x),cube_size.y)/float(cube_size.y-1);\n    position.z = fmod(int(t_offset/(cube_size.x*cube_size.y)),cube_size.z)/float(cube_size.z-1);\n    position.w = 1-min(fmod(int(t_offset/(cube_size.x*cube_size.y*cube_size.z)),maxSize),1.0f);\n\n    dst() = float4(position.x*position.w,position.y*position.w,position.z*position.w,position.w);\n   \}\n\};\n\n"
  rebuild ""
  "InvertKernel_Cube Size" {{parent.CONTROLER.size_x} {parent.CONTROLER.size_y} {parent.CONTROLER.size_z}}
  rebuild_finalise ""
  name BlinkScript8
  selected true
  xpos 372
  ypos -79
 }
 Grade {
  add -0.5
  black_clamp false
  name Grade1
  xpos 372
  ypos -47
 }
 Grade {
  white {{parent.Scale.r} {parent.Scale.g} {parent.Scale.b} 0.9}
  add {{parent.Position.r} {parent.Position.g} {parent.Position.b} 0}
  black_clamp false
  name Grade2
  xpos 372
  ypos -26
 }
 Shuffle {
  red white
  green white
  blue white
  black red
  white green
  red2 blue
  green2 alpha
  out2 pos
  name Shuffle1
  xpos 372
  ypos -2
 }
 ModifyMetaData {
  metadata {
   {set pointrender/n_points "\[expr \[value parent.size_x]*\[value parent.size_y] *\[value parent.size_z]]"}
   {set pointrender/gen_type 3}
  }
  name SetMetaData
  xpos 372
  ypos 22
 }
 Grade {
  white {{1/((parent.size_x*parent.size_y*parent.size_z)/200000)}}
  black_clamp false
  name Grade9
  xpos 372
  ypos 46
 }
 Crop {
  box {0 0 {ceil(sqrt(pow(parent.CONTROLER.VoxelDensity,3)))} {sqrt(pow(parent.CONTROLER.VoxelDensity,3))}}
  crop false
  name Crop1
  xpos 372
  ypos 70
 }
 Output {
  name Output1
  xpos 372
  ypos 149
 }
end_group
Group {
 name Fractal1
 tile_color 0x434343ff
 note_font_color 0x7dadf9ff
 selected true
 xpos 8822
 ypos 32165
 addUserKnob {20 User t test}
 addUserKnob {26 _1 l "" +STARTLINE T "Point Fractal 1.0\n"}
 addUserKnob {26 devider_noise l "<b><font color=#7DADF9>Noise Settings</font><b>"}
 addUserKnob {6 Noise_Absolute l Absolute t "Negative values in the noise offset is made positive." +STARTLINE}
 addUserKnob {3 Noise_Octaves l Octaves}
 Noise_Octaves 8
 addUserKnob {7 Noise_Gain l Gain}
 Noise_Gain 0.3
 addUserKnob {7 Noise_Lacunarity l Lacunarity R 0 4}
 Noise_Lacunarity 1.18
 addUserKnob {18 Amplitude}
 Amplitude 0.39
 addUserKnob {6 Amplitude_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Amplitude_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Amplitude_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Amplitude_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {3 Itterations}
 Itterations 5
 addUserKnob {26 invis_devider_noise l "" +STARTLINE T " "}
 addUserKnob {26 Devider_Frequency l "<b><font color=#7DADF9>Freq Control</font><b>"}
 addUserKnob {19 Freq_Offset l "General Offset" t "This is like a 3D translation, letting you move the current noise pattern in the X, Y, Z and W (4th dimention)" R 0 10}
 Freq_Offset {0 0 0 0}
 addUserKnob {6 Freq_Offset_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_Offset_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_Offset_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_Offset_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_Offset_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 Freq_GeneralScale l "Genral Scale" t "This lets you control the scale of each individual noise axis."}
 Freq_GeneralScale {1 1 1 1}
 addUserKnob {6 Freq_GeneralScale_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_GeneralScale_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_GeneralScale_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_GeneralScale_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_GeneralScale_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {26 invis_devider_freq l "" +STARTLINE T " "}
 addUserKnob {19 Freq_EvolveLow l "Evolve Low" t "This lets you evolve (auto animate) the noise in a particular direction. The \"Low\" part means that this only affects the low frequencies.\n\nTo avoid a \"scrolling\" effect you can use the 4th dimention to break up the spatial cohearence." R 0 10}
 Freq_EvolveLow {3 0 0 0.5}
 addUserKnob {6 Freq_EvolveLow_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveLow_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveLow_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveLow_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveLow_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleLow_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 Freq_EvolveHigh l "Evolve High" t "This lets you evolve (auto animate) the noise in a particular direction. The \"High\" part means that this only affects the high frequencies.\n\nTo avoid a \"scrolling\" effect you can use the 4th dimention to break up the spatial cohearence."}
 Freq_EvolveHigh {0.9 0 -1 1}
 addUserKnob {6 Freq_EvolveHigh_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveHigh_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveHigh_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveHigh_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveHigh_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {26 invis_devider_freq2 l "" +STARTLINE T " "}
 addUserKnob {19 Freq_ScaleLow l "Scale Low" t "This lets you scale the noise in a particular axis. The \"Low\" part means that this only affects the low frequencies."}
 Freq_ScaleLow {2 0.5 2 2}
 addUserKnob {6 Freq_ScaleLow_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleLow_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleLow_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleLow_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleLow_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 Freq_ScaleHigh l "Scale High" t "This lets you scale the noise in a particular axis. The \"High\" part means that this only affects the high frequencies."}
 Freq_ScaleHigh {2 2 2 2}
 addUserKnob {6 Freq_ScaleHigh_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleHigh_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleHigh_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleHigh_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleHigh_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {26 invis_devider_freq3 l "" +STARTLINE T " "}
 addUserKnob {26 Curve l "<b><font color=#7DADF9>Curve Noise</font><b>"}
 addUserKnob {6 CurveNoise_Enable l Enable t "Adds a gamma curve to the noise intensity making noise near the \"Offset\" value more flat. This is a experimental feature." +STARTLINE}
 addUserKnob {6 CurveNoise_Invert l Invert t "Inverts the effect of the curved noise." -STARTLINE}
 addUserKnob {7 CurveGain l "Curve Gain" R -10 10}
 CurveGain 3
 addUserKnob {7 CurveOffset R -2 2}
 addUserKnob {26 gabgen l "" +STARTLINE T "\n"}
 addUserKnob {26 info_mask l "<b><font color=#7DADF9>Mask</font><b>"}
 addUserKnob {41 maskChannelMask l "" t "If a node is connected to the mask input, this will let you mask off the effect of the noise.\nIts recommended that you use the Point_Texture node to ensure a correct aspect and size." -STARTLINE T Merge1.maskChannelMask}
 addUserKnob {41 inject -STARTLINE T Merge1.inject}
 addUserKnob {41 invert_mask l invert -STARTLINE T Merge1.invert_mask}
 addUserKnob {41 fringe -STARTLINE T Merge1.fringe}
 addUserKnob {41 mix T Merge1.mix}
}
 Input {
  inputs 0
  name InputMask
  xpos -714
  ypos 207
  number 1
 }
 Reformat {
  type "to box"
  box_width {{parent.InputFormat.box.r}}
  box_height {{parent.InputFormat.box.t}}
  box_fixed true
  resize distort
  name Reformat2
  xpos -714
  ypos 306
 }
 Shuffle {
  name Shuffle3
  xpos -714
  ypos 330
 }
 Input {
  inputs 0
  name InputData
  xpos -582
  ypos 73
 }
 Dot {
  name Dot1
  xpos -548
  ypos 114
 }
set N57baef60 [stack 0]
 Shuffle {
  in pos
  name Shuffle1
  xpos -470
  ypos 110
 }
 BlinkScript {
  kernelSourceFile /Users/madshagbarth/Github/Nuke-Private/Blink/PointRender/Modify/Fractal_v06.cpp
  recompileCount 60
  ProgramGroup 1
  KernelDescription "2 \"Noise4D\" iterate pixelWise d54284af3e5573ad197bef9032773e8653de2cad590694fcc9fd5af993e97da3 2 \"src\" Read Point \"dst\" Write Point 17 \"absNoise\" Bool 1 AA== \"curveNoise\" Bool 1 AA== \"curveInvert\" Bool 1 AA== \"curveGain\" Float 1 AACAPw== \"curveOffset\" Float 1 AACAPw== \"Octaves\" Int 1 CgAAAA== \"Gain\" Float 1 AAAAPw== \"Lacunarity\" Float 1 AAAAQA== \"Gamma\" Float 1 AAAAPw== \"amplitude\" Float 3 AAAAPwAAAD8AAAA/AAAAAA== \"itterations\" Int 1 AQAAAA== \"Offset\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"Scale\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"suboffset\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"topoffset\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"subscale\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"topscale\" Float 4 AACAPwAAgD8AAIA/AACAPw== 17 \"absNoise\" 1 1 \"curveNoise\" 1 1 \"curveInvert\" 1 1 \"curveGain\" 1 1 \"curveOffset\" 1 1 \"octaves\" 1 1 \"gain\" 1 1 \"lacunarity\" 1 1 \"gamma\" 1 1 \"amplitude\" 3 1 \"itterations\" 1 1 \"offset\" 4 1 \"scale\" 4 1 \"suboffset\" 4 1 \"topoffset\" 4 1 \"subscale\" 4 1 \"topscale\" 4 1 0"
  kernelSource "//Based on https://github.com/Draradech/csworldgen/blob/master/simplexnoise.cpp\n//Ported by Mads Hagbarth Lund 2014\n\n/* Copyright (c) 2007-2012 Eliot Eshelman\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n\nint fastfloor( const float x ) \{ return x > 0 ? (int) x : (int) x - 1; \}\ninline float raw_noise_4d( const float x, const float y, const float z, const float w ) \n\{\nint simplex\[64]\[4] = \{\n    \{0,1,2,3\},\{0,1,3,2\},\{0,0,0,0\},\{0,2,3,1\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{1,2,3,0\},\n    \{0,2,1,3\},\{0,0,0,0\},\{0,3,1,2\},\{0,3,2,1\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{1,3,2,0\},\n    \{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\n    \{1,2,0,3\},\{0,0,0,0\},\{1,3,0,2\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{2,3,0,1\},\{2,3,1,0\},\n    \{1,0,2,3\},\{1,0,3,2\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{2,0,3,1\},\{0,0,0,0\},\{2,1,3,0\},\n    \{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\n    \{2,0,1,3\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{3,0,1,2\},\{3,0,2,1\},\{0,0,0,0\},\{3,1,2,0\},\n    \{2,1,0,3\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{3,1,0,2\},\{0,0,0,0\},\{3,2,0,1\},\{3,2,1,0\}\n\};\n    int perm\[512] = \{\n        151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,\n        8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,\n        35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,\n        134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,\n        55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208, 89,\n        18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,\n        250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,\n        189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,\n        172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,\n        228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,\n        107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,\n        138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180,\n\n        151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,\n        8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,\n        35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,\n        134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,\n        55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208, 89,\n        18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,\n        250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,\n        189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,\n        172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,\n        228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,\n        107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,\n        138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180\n    \};\n   int grad4\[32]\[4]= \{\n    \{0,1,1,1\},  \{0,1,1,-1\},  \{0,1,-1,1\},  \{0,1,-1,-1\},\n    \{0,-1,1,1\}, \{0,-1,1,-1\}, \{0,-1,-1,1\}, \{0,-1,-1,-1\},\n    \{1,0,1,1\},  \{1,0,1,-1\},  \{1,0,-1,1\},  \{1,0,-1,-1\},\n    \{-1,0,1,1\}, \{-1,0,1,-1\}, \{-1,0,-1,1\}, \{-1,0,-1,-1\},\n    \{1,1,0,1\},  \{1,1,0,-1\},  \{1,-1,0,1\},  \{1,-1,0,-1\},\n    \{-1,1,0,1\}, \{-1,1,0,-1\}, \{-1,-1,0,1\}, \{-1,-1,0,-1\},\n    \{1,1,1,0\},  \{1,1,-1,0\},  \{1,-1,1,0\},  \{1,-1,-1,0\},\n    \{-1,1,1,0\}, \{-1,1,-1,0\}, \{-1,-1,1,0\}, \{-1,-1,-1,0\}\n   \};\n    float F4 = (sqrt(5.0f)-1.0f)/4.0f;\n    float G4 = (5.0f-sqrt(5.0f))/20.0f;\n    float n0, n1, n2, n3, n4;\n    float s = (x + y + z + w) * F4;\n    int i = fastfloor(x + s);\n    int j = fastfloor(y + s);\n    int k = fastfloor(z + s);\n    int l = fastfloor(w + s);\n    float t = (i + j + k + l) * G4;\n    float X0 = i - t;\n    float Y0 = j - t;\n    float Z0 = k - t;\n    float W0 = l - t;\n\n    float x0 = x - X0;\n    float y0 = y - Y0;\n    float z0 = z - Z0;\n    float w0 = w - W0;\n    int c1 = (x0 > y0) ? 32 : 0;\n    int c2 = (x0 > z0) ? 16 : 0;\n    int c3 = (y0 > z0) ? 8 : 0;\n    int c4 = (x0 > w0) ? 4 : 0;\n    int c5 = (y0 > w0) ? 2 : 0;\n    int c6 = (z0 > w0) ? 1 : 0;\n    int c = c1 + c2 + c3 + c4 + c5 + c6;\n\n    int i1, j1, k1, l1;\n    int i2, j2, k2, l2;\n    int i3, j3, k3, l3;\n    i1 = simplex\[c]\[0]>=3 ? 1 : 0;\n    j1 = simplex\[c]\[1]>=3 ? 1 : 0;\n    k1 = simplex\[c]\[2]>=3 ? 1 : 0;\n    l1 = simplex\[c]\[3]>=3 ? 1 : 0;\n    i2 = simplex\[c]\[0]>=2 ? 1 : 0;\n    j2 = simplex\[c]\[1]>=2 ? 1 : 0;\n    k2 = simplex\[c]\[2]>=2 ? 1 : 0;\n    l2 = simplex\[c]\[3]>=2 ? 1 : 0;\n    i3 = simplex\[c]\[0]>=1 ? 1 : 0;\n    j3 = simplex\[c]\[1]>=1 ? 1 : 0;\n    k3 = simplex\[c]\[2]>=1 ? 1 : 0;\n    l3 = simplex\[c]\[3]>=1 ? 1 : 0;\n    float x1 = x0 - i1 + G4;\n    float y1 = y0 - j1 + G4;\n    float z1 = z0 - k1 + G4;\n    float w1 = w0 - l1 + G4;\n    float x2 = x0 - i2 + 2.0*G4;\n    float y2 = y0 - j2 + 2.0*G4;\n    float z2 = z0 - k2 + 2.0*G4;\n    float w2 = w0 - l2 + 2.0*G4;\n    float x3 = x0 - i3 + 3.0*G4;\n    float y3 = y0 - j3 + 3.0*G4;\n    float z3 = z0 - k3 + 3.0*G4;\n    float w3 = w0 - l3 + 3.0*G4;\n    float x4 = x0 - 1.0 + 4.0*G4;\n    float y4 = y0 - 1.0 + 4.0*G4;\n    float z4 = z0 - 1.0 + 4.0*G4;\n    float w4 = w0 - 1.0 + 4.0*G4;\n    int ii = i & 255;\n    int jj = j & 255;\n    int kk = k & 255;\n    int ll = l & 255;\n    int gi0 = perm\[ii+perm\[jj+perm\[kk+perm\[ll]]]] % 32;\n    int gi1 = perm\[ii+i1+perm\[jj+j1+perm\[kk+k1+perm\[ll+l1]]]] % 32;\n    int gi2 = perm\[ii+i2+perm\[jj+j2+perm\[kk+k2+perm\[ll+l2]]]] % 32;\n    int gi3 = perm\[ii+i3+perm\[jj+j3+perm\[kk+k3+perm\[ll+l3]]]] % 32;\n    int gi4 = perm\[ii+1+perm\[jj+1+perm\[kk+1+perm\[ll+1]]]] % 32;\n    float t0 = 0.6 - x0*x0 - y0*y0 - z0*z0 - w0*w0;\n    if(t0<0) n0 = 0.0;\n    else \{\n        t0 *= t0;\n        n0 = t0 * t0 * dot(float4(grad4\[gi0]\[0],grad4\[gi0]\[2],grad4\[gi0]\[3],grad4\[gi0]\[3]), float4(x0, y0, z0, w0));\n    \}\n    float t1 = 0.6 - x1*x1 - y1*y1 - z1*z1 - w1*w1;\n    if(t1<0) n1 = 0.0;\n    else \{\n        t1 *= t1;\n        n1 = t1 * t1 * dot(float4(grad4\[gi1]\[0],grad4\[gi1]\[2],grad4\[gi1]\[3],grad4\[gi1]\[3]), float4(x1, y1, z1, w1));\n    \}\n    float t2 = 0.6 - x2*x2 - y2*y2 - z2*z2 - w2*w2;\n    if(t2<0) n2 = 0.0;\n    else \{\n        t2 *= t2;\n        n2 = t2 * t2 * dot(float4(grad4\[gi2]\[0],grad4\[gi2]\[2],grad4\[gi2]\[3],grad4\[gi2]\[3]), float4(x2, y2, z2, w2));\n    \}\n    float t3 = 0.6 - x3*x3 - y3*y3 - z3*z3 - w3*w3;\n    if(t3<0) n3 = 0.0;\n    else \{\n        t3 *= t3;\n        n3 = t3 * t3 * dot(float4(grad4\[gi3]\[0],grad4\[gi3]\[2],grad4\[gi3]\[3],grad4\[gi3]\[3]), float4(x3, y3, z3, w3));\n    \}\n    float t4 = 0.6 - x4*x4 - y4*y4 - z4*z4 - w4*w4;\n    if(t4<0) n4 = 0.0;\n    else \{\n        t4 *= t4;\n        n4 = t4 * t4 * dot(float4(grad4\[gi4]\[0],grad4\[gi4]\[2],grad4\[gi4]\[3],grad4\[gi4]\[3]), float4(x4, y4, z4, w4));\n    \}\n    return 27.0 * (n0 + n1 + n2 + n3 + n4);\n\}\n\n\n\n\nkernel Noise4D : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n  Image<eWrite, eAccessPoint> dst;\nparam:\n    bool absNoise;\n    bool curveNoise;\n    bool curveInvert;\n    float curveGain;\n    float curveOffset;\n    int octaves;\n    float gain;\n    float lacunarity;\n    float gamma;\n    float3 amplitude;\n    int itterations;\n    float4 offset;\n    float4 scale;\n    float4 suboffset;\n    float4 topoffset;\n    float4 subscale;\n    float4 topscale;\n\n\n  void define() \{\n        defineParam (absNoise, \"absNoise\", false);    \n        defineParam (curveNoise, \"curveNoise\", false);    \n        defineParam (curveInvert, \"curveInvert\", false);   \n        defineParam (curveGain, \"curveGain\", 1.0f);\n        defineParam (curveOffset, \"curveOffset\", 1.0f);\n        defineParam (octaves, \"Octaves\", 10);\n        defineParam (gain, \"Gain\", 0.5f);\n        defineParam (lacunarity, \"Lacunarity\", 2.0f);\n        defineParam (gamma, \"Gamma\", 0.5f);\n        defineParam (amplitude, \"amplitude\", float3(0.5f));\n        defineParam (itterations, \"itterations\", 1);\n        defineParam(offset, \"Offset\", float4(0.0f, 0.0f, 0.0f,0.0f));\n        defineParam(scale, \"Scale\", float4(1.0f, 1.0f, 1.0f,1.0f));\n        defineParam(suboffset, \"suboffset\", float4(1.0f, 1.0f, 1.0f,1.0f));\n        defineParam(topoffset, \"topoffset\", float4(1.0f, 1.0f, 1.0f,1.0f));\n        defineParam(subscale, \"subscale\", float4(1.0f, 1.0f, 1.0f,1.0f));\n        defineParam(topscale, \"topscale\", float4(1.0f, 1.0f, 1.0f,1.0f));        \n  \}\n\nfloat octave_noise_4d( const float octaves, const float persistence, const float scale, const float x, const float y, const float z, const float w ) \n\{\n    float total = 0.0f;\n    float current;\n    float last = 1.0f;\n    float frequency = scale;\n    float amplitude = 1.0f;\n    float maxAmplitude = 0.0f;\n    float4 Tempoffset;\n    float4 Tempscale;\n\n\n    for( int i=0; i < octaves; i++ ) \{\n\n        /*\n        if (i == 0) \{\n            total += (float)raw_noise_4d( (x+suboffset.x) * frequency, (y+suboffset.y) * frequency, (z+suboffset.z) * frequency, (w+suboffset.w) * frequency ) * amplitude;\n        \}\n        else if (i == octaves-1) \{\n            total += (float)raw_noise_4d( (x+topoffset.x) * frequency, (y+topoffset.y) * frequency, (z+topoffset.z) * frequency, (w+topoffset.w) * frequency ) * amplitude;\n        \}\n        else \{\n            total += (float)raw_noise_4d( x * frequency, y * frequency, z * frequency, w * frequency ) * amplitude;\n        \}\n        */\n\n\n        Tempscale = (topscale * (i/(octaves-1.0f)))+(subscale * (1-(i/(octaves-1.0f))));       \n        Tempoffset = (topoffset * (i/(octaves-1.0f)))+(suboffset * (1-(i/(octaves-1.0f))));\n        current = (float)raw_noise_4d(   ((x*Tempscale.x)+Tempoffset.x) * frequency, \n                                        ((y*Tempscale.y)+Tempoffset.y) * frequency, \n                                        ((z*Tempscale.z)+Tempoffset.z) * frequency, \n                                        ((w*Tempscale.w)+Tempoffset.w) * frequency \n                                        ) * amplitude;\n        if (i == 0 && curveNoise)\{\n            if (curveInvert)\{\n                last = 0.5f-current;  \n            \}\n            else\{\n                last = current;  \n            \}\n               \n        \}\n        current = curveNoise?current*((last+curveOffset)*curveGain):current;\n        total += absNoise?fabs(current):current;\n        frequency *= 2.0f;\n        maxAmplitude += amplitude;\n        amplitude *= persistence;\n\n    \}\n    return float(total / maxAmplitude);\n\}\n\n\n\n\n  void process() \{\n    float4 srcSample = float4(src(0),src(1),src(2),src(3));\n    float sampleR,sampleG,sampleB;\n    for( int i=0; i < itterations; i++ ) \{\n        sampleR = (float)octave_noise_4d(float(octaves), gain, lacunarity, ( srcSample.x * scale.x ) + offset.x, ( srcSample.y * scale.y ) + offset.y,  ( srcSample.z * scale.z ) + offset.z, ( srcSample.w * scale.w ) + offset.w) * amplitude.x;\n        sampleG = (float)octave_noise_4d(float(octaves), gain, lacunarity, ( srcSample.x * scale.x ) + offset.x, ( srcSample.y * scale.y ) + offset.y,  ( srcSample.z * scale.z ) + offset.z, ( srcSample.w * scale.w ) + offset.w - 100.0f) * amplitude.y;\n        sampleB = (float)octave_noise_4d(float(octaves), gain, lacunarity, ( srcSample.x * scale.x ) + offset.x, ( srcSample.y * scale.y ) + offset.y,  ( srcSample.z * scale.z ) + offset.z, ( srcSample.w * scale.w ) + offset.w + 200.0f) * amplitude.z;\n        srcSample = float4(srcSample.x+sampleR,srcSample.y+sampleG,srcSample.z+sampleB,srcSample.w);\n    \}\n    dst() = float4(srcSample.x,srcSample.y,srcSample.z,1.0f);\n\}\n\};"
  rebuild ""
  Noise4D_curveNoise {{parent.CurveNoise_Enable}}
  Noise4D_curveInvert {{parent.CurveNoise_Invert}}
  Noise4D_curveGain {{parent.CurveGain}}
  Noise4D_curveOffset {{parent.CurveOffset}}
  Noise4D_Octaves {{parent.Noise_Octaves}}
  Noise4D_Gain {{parent.Noise_Gain}}
  Noise4D_Lacunarity {{parent.Noise_Lacunarity}}
  Noise4D_Gamma 0.79
  Noise4D_amplitude {{parent.Amplitude.r} {parent.Amplitude.g} {parent.Amplitude.b}}
  Noise4D_itterations {{parent.Itterations}}
  Noise4D_Offset {{parent.Freq_Offset} {parent.Freq_Offset} {parent.Freq_Offset} {parent.Freq_Offset}}
  Noise4D_Scale {{parent.Freq_GeneralScale} {parent.Freq_GeneralScale} {parent.Freq_GeneralScale} {parent.Freq_GeneralScale}}
  Noise4D_suboffset {{(frame*parent.Freq_EvolveLow.r)/50} {(frame*parent.Freq_EvolveLow.g)/50} {(frame*parent.Freq_EvolveLow.b)/50} {(frame*parent.Freq_EvolveLow.a)/50}}
  Noise4D_topoffset {{(frame*parent.Freq_EvolveHigh.r)/10} {(frame*parent.Freq_EvolveHigh.g)/10} {(frame*parent.Freq_EvolveHigh.b)/10} {(frame*parent.Freq_EvolveHigh.a)/10}}
  Noise4D_subscale {{parent.Freq_ScaleLow} {parent.Freq_ScaleLow} {parent.Freq_ScaleLow} {parent.Freq_ScaleLow}}
  Noise4D_topscale {{parent.Freq_ScaleHigh} {parent.Freq_ScaleHigh} {parent.Freq_ScaleHigh} {parent.Freq_ScaleHigh}}
  rebuild_finalise ""
  name Noise4D1
  selected true
  xpos -470
  ypos 177
 }
 Expression {
  expr0 abs(r)
  expr1 abs(g)
  expr2 abs(b)
  name Expression2
  xpos -470
  ypos 259
  disable {{!parent.Noise_Absolute}}
 }
 Shuffle {
  out pos
  name Shuffle2
  xpos -470
  ypos 330
 }
push $N57baef60
 Merge2 {
  inputs 2+1
  operation copy
  bbox B
  Achannels {pos.red pos.green pos.blue -pos.alpha}
  Bchannels {pos.red pos.green pos.blue -pos.alpha}
  output {pos.red pos.green pos.blue -pos.alpha}
  maskChannelMask -rgba.alpha
  name Merge1
  xpos -582
  ypos 326
 }
 Output {
  name Output1
  xpos -582
  ypos 497
 }
push $N57baef60
 Crop {
  box {0 0 {width} {height}}
  reformat true
  crop false
  name InputFormat
  xpos -713
  ypos 111
 }
end_group
set N57d4c950 [stack 0]
Dot {
 name Dot302
 selected true
 xpos 8729
 ypos 32170
}
push $N57d4c950
Dot {
 name Dot303
 selected true
 xpos 8856
 ypos 32347
}
Group {
 inputs 2
 name Point_OffsetShader1
 tile_color 0x434343ff
 note_font_color 0x55ffffff
 selected true
 xpos 8695
 ypos 32343
 addUserKnob {20 User}
 addUserKnob {26 info l "" +STARTLINE T "Point Offset Shader v1.0\n\nCalcualtes the distance between 2 point sets.\nThis can for example be used to see the difference between the original generator\nand the modified one."}
 addUserKnob {26 devider_general l "<b><font color=#70EE70>General</font><b>"}
 addUserKnob {7 Gain}
 Gain 3
 addUserKnob {7 Offset R -0.5 0.5}
 Offset -0.1
 addUserKnob {6 Absolute +STARTLINE}
 Absolute true
 addUserKnob {6 Reverse +STARTLINE}
}
 BackdropNode {
  inputs 0
  name BackdropNode1
  tile_color 0x388e8e00
  label Offset
  note_font_size 42
  xpos -591
  ypos 304
  bdwidth 224
  bdheight 161
 }
 Input {
  inputs 0
  name Input2
  xpos -438
  ypos 40
  number 1
 }
 Shuffle {
  in pos
  name Shuffle1
  xpos -438
  ypos 120
 }
 Dot {
  name Dot4
  xpos -404
  ypos 285
 }
 Dot {
  name Dot1
  xpos -404
  ypos 392
 }
 Input {
  inputs 0
  name Input1
  xpos -580
  ypos 50
 }
 Shuffle {
  in pos
  name Shuffle5
  xpos -580
  ypos 120
 }
 Dot {
  name Dot3
  xpos -546
  ypos 256
 }
 MergeExpression {
  inputs 2
  temp_name0 xd
  temp_expr0 A.red-B.red
  temp_name1 yd
  temp_expr1 A.green-B.green
  temp_name2 zd
  temp_expr2 A.blue-B.blue
  temp_name3 Distance
  temp_expr3 "sqrt(xd*xd + yd*yd + zd*zd)"
  expr0 Distance
  expr1 Distance
  expr2 Distance
  name Distance
  xpos -584
  ypos 388
 }
 Grade {
  add {{parent.Offset}}
  black_clamp false
  name Grade3
  xpos -584
  ypos 412
 }
 Grade {
  white {{parent.Gain}}
  black_clamp {{!parent.Absolute}}
  name Grade1
  xpos -584
  ypos 436
 }
 Expression {
  expr0 abs(r)
  expr1 abs(g)
  expr2 abs(b)
  name Expression1
  xpos -584
  ypos 459
  disable {{!parent.Absolute}}
 }
 Expression {
  expr0 max(0,1-r)
  expr1 max(0,1-r)
  expr2 max(0,1-r)
  name Expression2
  selected true
  xpos -584
  ypos 483
  disable {{!parent.Reverse}}
 }
 Group {
  name SoftLook_NF1
  xpos -584
  ypos 650
  disable true
  addUserKnob {20 User}
  addUserKnob {26 Info l "" +STARTLINE T "SoftLook\nby Mads Hagbarth Lund - 2016"}
  addUserKnob {26 ""}
  addUserKnob {7 Add R 0 4}
  Add 1.14
  addUserKnob {7 Offset R 0 4}
  Offset 0.86
 }
  Input {
   inputs 0
   name Input1
   xpos -248
   ypos 500
  }
set N578b0210 [stack 0]
  Expression {
   expr0 r/(r+parent.Offset)*parent.Add
   expr1 g/(g+parent.Offset)*parent.Add
   expr2 b/(b+parent.Offset)*parent.Add
   expr3 a/(a+parent.Offset)*parent.Add
   name Expression1
   selected true
   xpos -339
   ypos 576
  }
push $N578b0210
  ShuffleCopy {
   inputs 2
   red red
   green green
   blue blue
   alpha alpha2
   name ShuffleCopy1
   xpos -248
   ypos 576
  }
  Output {
   name Output1
   xpos -248
   ypos 651
  }
 end_group
 Output {
  name Output1
  xpos -584
  ypos 686
 }
end_group
Grade {
 white 1.3
 multiply {0.6887242198 0.9288096428 1 1}
 gamma {0.2101119161 0.3576882482 1 1}
 name Grade21
 selected true
 xpos 8695
 ypos 32425
}
Group {
 inputs 2
 name Point_Render2
 tile_color 0x434343ff
 note_font_color 0x7dadf9ff
 selected true
 xpos 8695
 ypos 32519
 addUserKnob {20 User l "Point Render" t dd}
 addUserKnob {26 info_header l "" +STARTLINE T "Point Render v1.0"}
 addUserKnob {26 devider_general l "<b><font color=#7DADF9>General</font><b>"}
 addUserKnob {4 RenderMode l "Render Mode" t "Some generators support multiple render modes other than just point rendering. This should be considered a experimental feature, but can be used to great effect.\n\nIn the Render Settings tab you can find more controls relating to Wire and Facet rendering modes.\n\nNote that Facet Render can be slow when really close to a object. " M {"Point Render" "Wire Render" "Facet Render (experimental)" "" "" ""}}
 addUserKnob {7 FocalLength l "Focal Length" t "The point render does not take the focal length from the input camera, so if you want to match it to a camera you should link the focal length from the camera to this." R 0 200}
 FocalLength 20
 addUserKnob {7 horizontalApeture l "Horiz Apeture" R 0 100}
 horizontalApeture 24.576
 addUserKnob {7 AlphaMultiplier l Exposure t "This is a general exposure modifier that lets you adjust the overall brightness of the render." R 0 2}
 AlphaMultiplier 0.15
 addUserKnob {6 UseOcclusionMap l "Use Occlusion Map" t "Enable the Occlusion map input. This lets you use a depth map as a holdout.\n\nNote:\nThe Red channal should contain the depth (absolute distance, not 1/depth)\nThe Alpha channal must be 1 for the areas that you want to holdout." +STARTLINE}
 addUserKnob {26 devider_cc l "<b><font color=#7DADF9>Preview</font><b>"}
 addUserKnob {6 FastPreview l "Fast Preview" t "Reduce the number of points for a quick preview of the final render." +STARTLINE}
 addUserKnob {6 HighlightCompression l "Hilight Compression" t "Compresses the highlights to make it easier to see bright details." +STARTLINE}
 addUserKnob {7 HighlightCeiling l "Highlight Ceiling" t "Adjust the cealing for the highlight compression." R 1 10}
 HighlightCeiling 1.15
 addUserKnob {7 Compression t "The compression amount." -STARTLINE R 0 5}
 Compression 1
 addUserKnob {26 devider_format l "<b><font color=#7DADF9>Format</font><b>"}
 addUserKnob {41 format l "output format" T Settings_Format.format}
 addUserKnob {20 WireRender l "Render Settings"}
 addUserKnob {26 devider_wirerender l "<b><font color=#7DADF9>Wire Rendering</font><b>"}
 addUserKnob {4 wire_type l "Connection Mode" t "*Normal\nConnect lines between the local neigbours of the 2d position map\n\n*Nearest\nConnect lines to the nearest points (in 3D space). This mode is limited to 100x100 points for performence reasons!" M {Normal Nearest "" "" "" "" "" "" "" ""}}
 addUserKnob {26 text l "Normal Mode Wires" T " "}
 addUserKnob {6 connect_x l x t "Connect wires in the (uv) X axis." -STARTLINE}
 connect_x true
 addUserKnob {6 connect_xy l xy t "Connect wires in the (uv) XY axis." -STARTLINE}
 connect_xy true
 addUserKnob {6 connect_y l y t "Connect wires in the (uv) Y axis." -STARTLINE}
 connect_y true
 addUserKnob {6 connect_aux l aux t "If you input a vector map into the Aux input for this node, and enable this option, you will get a wire from each point along that vector." -STARTLINE}
 addUserKnob {7 wire_maxdistance l "Max Distance" t "The maximum distance that the wires connect." R 0 10}
 wire_maxdistance 6
 addUserKnob {7 wire_Threshold l "Distance Threshold" t "Control the max distance threshold" R 0 2}
 wire_Threshold 0.5
 addUserKnob {3 wire_connections l "Max Connections" t "The maximum number of connections (Not Yet Implemented)"}
 wire_connections 4
 addUserKnob {7 maxSamples l "Max Line Samples" t "The maximum length of a line. Once a line is longer than this, it will start break up. \nThis can also be used as a creative effect if you set it low, try setting it to 10 in wire mode to get dotted lines" R 0 10000}
 maxSamples 10000
 addUserKnob {7 lineoffset l "Line Offset" t "Expand or contract the lines."}
 lineoffset 1
 addUserKnob {7 inGain l "In Gain" t "Gain the brightness of the in-point of the lines"}
 inGain 1
 addUserKnob {7 outGain l "Out Gain" t "Gain the brightness of the out-point of the lines" -STARTLINE}
 outGain 1
 addUserKnob {26 devider_facet l "<b><font color=#7DADF9>Facet Rendering</font><b>"}
 addUserKnob {4 renderMode l "Render Mode" t "Pick the desidered render mode." M {Diffuse "Local ST" Normal "Facing Ratio" UV ST "View Normal" "World Position" "" ""}}
 addUserKnob {6 facet_flatShading l "Flat Shading" t "Flat shading" +STARTLINE}
 addUserKnob {6 facet_depth l "Depth Buffer" t "Enable depth sorting to avoid additive surfaces." -STARTLINE}
 addUserKnob {6 facet_front l "Front Face" t "Render front facing facets" +STARTLINE}
 facet_front true
 addUserKnob {6 facet_backface l "Back Face" t "Render backfacing faces" -STARTLINE}
 facet_backface true
 addUserKnob {26 _1 l "<b><font color=#7DADF9>Other</font><b>"}
 addUserKnob {6 CloseX l "Close X" t "On spheres or round objects this closes the loop" +STARTLINE}
 addUserKnob {6 CloseY l "Close Y" t "On spheres or round objects this closes the loop" -STARTLINE}
 addUserKnob {20 Fog_1 l Fog}
 addUserKnob {26 Devider_Fog l "<b><font color=#7DADF9>Fog</font><b>"}
 addUserKnob {6 Fog t "Fog reduces the brightness of poins far from the camera." +STARTLINE}
 addUserKnob {7 FogNear l "Fog Near" R 0 200}
 FogNear 3
 addUserKnob {7 FogFar l "Fog Far" R 0 200}
 FogFar 10
 addUserKnob {7 FogExponent l "Fog Exponent" R 0 8}
 FogExponent 8
 addUserKnob {20 DepthOfField l "Depth of Field"}
 addUserKnob {26 devider_dof l "<b><font color=#7DADF9>Depth Of Field</font><b>"}
 addUserKnob {6 dof_enable l Enable +STARTLINE}
 addUserKnob {7 dof_focaldepth l "Focal Depth" R 0 40}
 dof_focaldepth 5
 addUserKnob {7 dof_dof l "Depth of Field" R 0 10}
 dof_dof 2
 addUserKnob {7 dof_maxSize l "Max Size"}
 dof_maxSize 0.5
 addUserKnob {7 dof_Aspect l "Aspect Ratio"}
 dof_Aspect 1
 addUserKnob {7 dof_bias l Bias R -3 3}
 dof_bias -0.2
 addUserKnob {4 Dof_Quality l Quality M {Low Medium High Extreme}}
 addUserKnob {20 MotionBlur}
 addUserKnob {26 devider_MotionBlur l "<b><font color=#7DADF9>Motion Blur</font><b>"}
 addUserKnob {6 mb_enable l Enable +STARTLINE}
 mb_enable true
 addUserKnob {6 Fast l "Fast (Interpolated)" -STARTLINE}
 Fast true
 addUserKnob {3 Samples}
 Samples 4
 addUserKnob {7 Shutter R 0 2}
 Shutter 0.5
 addUserKnob {4 pulldown l "Shutter Offset" M {Centered Start End ""}}
 addUserKnob {20 preview_3d l "3D Preview"}
 addUserKnob {6 Enable3DPreview l "Enable 3D Preview" t "Display a preview of the points in the Nuke 3D view." +STARTLINE}
 addUserKnob {41 pointSize l "point size" T PreviewNode.pointSize}
 addUserKnob {41 detail l "point detail" T PreviewNode.detail}
}
 BackdropNode {
  inputs 0
  name BackdropNode1
  tile_color 0x388e8e00
  label "Output Format Manager"
  note_font_size 22
  xpos -1491
  ypos 149
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode10
  tile_color 0x388e8e00
  label "AUX Input"
  note_font_size 22
  xpos -385
  ypos 178
  bdwidth 207
  bdheight 178
 }
 BackdropNode {
  inputs 0
  name BackdropNode11
  tile_color 0x388e8e00
  label "Point Render"
  note_font_size 22
  xpos -96
  ypos 99
  bdwidth 198
  bdheight 135
 }
 BackdropNode {
  inputs 0
  name BackdropNode12
  tile_color 0x388e8e00
  label "Normal Generator\nFor Vertex Normals"
  note_font_size 22
  xpos -616
  ypos 243
  bdwidth 191
  bdheight 122
 }
 BackdropNode {
  inputs 0
  name BackdropNode13
  tile_color 0x388e8e00
  label "Ensure output format"
  note_font_size 22
  xpos -622
  ypos -41
  bdwidth 198
  bdheight 135
 }
 BackdropNode {
  inputs 0
  name BackdropNode14
  tile_color 0x388e8e00
  label "Motion Blur"
  note_font_size 22
  xpos -85
  ypos 526
  bdwidth 193
  bdheight 91
 }
 BackdropNode {
  inputs 0
  name BackdropNode15
  tile_color 0x388e8e00
  label "Soft Preview"
  note_font_size 22
  xpos -83
  ypos 414
  bdwidth 191
  bdheight 94
 }
 BackdropNode {
  inputs 0
  name BackdropNode16
  tile_color 0x388e8e00
  label "Final format"
  note_font_size 22
  xpos -84
  ypos 295
  bdwidth 192
  bdheight 95
 }
 BackdropNode {
  inputs 0
  name BackdropNode17
  tile_color 0x388e8e00
  label "No Clue =)"
  note_font_size 22
  xpos -385
  ypos -41
  bdwidth 160
  bdheight 87
 }
 BackdropNode {
  inputs 0
  name BackdropNode2
  tile_color 0x388e8e00
  label Motionblur
  note_font_size 22
  xpos -672
  ypos -781
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode3
  tile_color 0x388e8e00
  label "Fast Preview"
  note_font_size 22
  xpos -669
  ypos -971
  bdwidth 254
  bdheight 138
 }
 BackdropNode {
  inputs 0
  name BackdropNode4
  tile_color 0x388e8e00
  label "Nearest Wire Mode Clamp"
  note_font_size 22
  xpos -666
  ypos -1184
  bdwidth 253
  bdheight 111
 }
 BackdropNode {
  inputs 0
  name BackdropNode5
  tile_color 0x388e8e00
  label Occlution
  note_font_size 22
  xpos 208
  ypos 27
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode6
  tile_color 0x388e8e00
  label "Input Camera Container"
  note_font_size 22
  xpos -1215
  ypos 148
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode7
  tile_color 0x388e8e00
  label "3D Preview"
  note_font_size 22
  xpos -88
  ypos -45
  bdwidth 207
  bdheight 102
 }
 BackdropNode {
  inputs 0
  name BackdropNode8
  tile_color 0x388e8e00
  label "Input Format Manager"
  note_font_size 22
  xpos -526
  ypos -459
  bdwidth 208
  bdheight 97
 }
 BackdropNode {
  inputs 0
  name BackdropNode9
  tile_color 0x388e8e00
  label FOG
  note_font_size 22
  xpos -602
  ypos -253
  bdwidth 370
  bdheight 152
 }
 Input {
  inputs 0
  name InputPointData
  xpos -584
  ypos -1321
 }
 Dot {
  name Dot4
  xpos -550
  ypos -1234
 }
set N681f0860 [stack 0]
 Reformat {
  type "to box"
  box_width 100
  box_height 100
  box_fixed true
  scale 0.1
  resize fill
  filter impulse
  black_outside true
  name Reformat5
  xpos -584
  ypos -906
  disable {{!parent.FastPreview==1}}
 }
 Grade {
  white 10
  name Grade2
  xpos -584
  ypos -874
  disable {{!parent.FastPreview}}
 }
 Dot {
  name Dot2
  xpos -550
  ypos -712
 }
set N543b6ab0 [stack 0]
 Group {
  name FrameHold3
  tile_color 0xb0a45dff
  label "(frame \[value first_frames])"
  xpos -501
  ypos -719
  disable {{1-parent.mb_enable}}
  addUserKnob {20 User}
  addUserKnob {3 first_frames l "first frame"}
  first_frames {{frame+1}}
  addUserKnob {41 increment T FrameHold2.increment}
  addUserKnob {22 SetCurrentFrame l "Set This Frame" T "nuke.thisNode()\[\"first_frames\"].setValue(nuke.frame())" +STARTLINE}
 }
  Input {
   inputs 0
   name Input1
   xpos -7
   ypos -154
  }
  FrameHold {
   first_frame {{parent.knob.first_frames}}
   name FrameHold2
   xpos -7
   ypos -114
  }
  Output {
   name Output1
   xpos -7
   ypos -14
  }
 end_group
 Dot {
  name Dot6
  xpos -467
  ypos -659
 }
push $N543b6ab0
 Group {
  name FrameHold2
  tile_color 0xb0a45dff
  label "(frame \[value first_frames])"
  xpos -660
  ypos -719
  disable {{1-parent.mb_enable}}
  addUserKnob {20 User}
  addUserKnob {3 first_frames l "first frame"}
  first_frames {{frame}}
  addUserKnob {41 increment T FrameHold2.increment}
  addUserKnob {22 SetCurrentFrame l "Set This Frame" T "nuke.thisNode()\[\"first_frames\"].setValue(nuke.frame())" +STARTLINE}
 }
  Input {
   inputs 0
   name Input1
   xpos -7
   ypos -154
  }
  FrameHold {
   first_frame {{parent.knob.first_frames}}
   name FrameHold2
   xpos -7
   ypos -114
  }
  Output {
   name Output1
   xpos -7
   ypos -14
  }
 end_group
 Dot {
  name Dot5
  xpos -626
  ypos -659
 }
 Dissolve {
  inputs 2
  which {{frame-floor(frame)}}
  name Dissolve1
  xpos -582
  ypos -666
  disable {{1-parent.mb_enable}}
 }
push $N543b6ab0
 Switch {
  inputs 2
  which {{parent.Fast}}
  name Switch2
  xpos -582
  ypos -619
 }
 Dot {
  name DataFetch
  label "data fetch\t"
  note_font_color 0xff21ff
  xpos -550
  ypos -513
  addUserKnob {20 User}
  addUserKnob {3 n_particles l "Number of Particles"}
  n_particles {{"\[metadata pointrender/n_points]"}}
  addUserKnob {3 gentype l "Type Of Generator"}
  gentype {{"\[metadata pointrender/gen_type]"}}
  addUserKnob {26 info l "" -STARTLINE T "0 = unknown, 1 = Card, 2 = Sphere, 3 = Grid"}
 }
set N53eef370 [stack 0]
 Dot {
  name Dot3
  xpos -635
  ypos -513
 }
 Dot {
  name Dot1
  xpos -635
  ypos 676
 }
 Input {
  inputs 0
  name InputOcclution
  xpos 238
  ypos 75
  number 2
 }
 Constant {
  inputs 0
  channels rgb
  color 1
  name Empty
  xpos 371
  ypos 139
 }
 Switch {
  inputs 2
  which {{parent.UseOcclusionMap}}
  name Switch1
  xpos 238
  ypos 163
 }
 Input {
  inputs 0
  name Aux
  xpos -324
  ypos 214
  number 3
 }
 Reformat {
  type "to box"
  format "1280 720 0 0 1280 720 1 HD_720"
  box_width {{input.width>Settings_Format.format.width?input.width:Settings_Format.format.width}}
  box_height {{input.height>Settings_Format.format.height?input.height:Settings_Format.format.height}}
  box_fixed true
  resize none
  center false
  filter impulse
  black_outside true
  name Reformat2
  xpos -324
  ypos 238
 }
 Crop {
  box {0 0 {input.width} {input.height}}
  name Crop1
  xpos -324
  ypos 275
 }
push $N53eef370
 Shuffle {
  in pos
  name Shuffle1
  xpos -584
  ypos -192
 }
set N482e9270 [stack 0]
 Reformat {
  type "to box"
  format "1280 720 0 0 1280 720 1 HD_720"
  box_width {{input.width>Settings_Format.format.width?input.width:Settings_Format.format.width}}
  box_height {{input.height>Settings_Format.format.height?input.height:Settings_Format.format.height}}
  box_fixed true
  resize none
  center false
  filter impulse
  black_outside true
  name Reformat4
  xpos -584
  ypos 18
 }
 Crop {
  box {0 0 {input.width} {input.height}}
  name Crop2
  xpos -584
  ypos 48
 }
 Dot {
  name Dot8
  xpos -550
  ypos 166
 }
set N4806f920 [stack 0]
 Group {
  name Point_Normal2
  tile_color 0x434343ff
  note_font_color 0x55ffffff
  xpos -584
  ypos 311
  disable {{!(renderMode==2&&RenderMode==2)}}
  addUserKnob {20 User}
  addUserKnob {26 info l "" +STARTLINE T "Point Normal v1.0"}
  addUserKnob {26 devider_general l "<b><font color=#7DADF9>General</font><b>"}
  addUserKnob {26 info_1 l "" +STARTLINE T "well, not much to do here =)"}
 }
  Input {
   inputs 0
   name Input1
   xpos 389
   ypos 207
  }
  Shuffle {
   in pos
   name Shuffle1
   xpos 389
   ypos 294
  }
  BlinkScript {
   kernelSourceFile /Users/madshagbarth/Github/Nuke-Private/Blink/PointRender/Modify/BasicLight.cpp
   recompileCount 69
   ProgramGroup 1
   KernelDescription "2 \"PointRender3D\" iterate pixelWise d5452fe7b684561fcfa5182d0c789025a037cc4fe4474c24e065e3fa53fcd8ce 2 \"ppos\" Read Random \"dst\" Write Point 9 \"cam_Matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== \"focallength\" Float 1 AAA4QQ== \"hapeture\" Float 1 ppvEQQ== \"format\" Int 2 AAgAAAAIAAA= \"Zoom\" Float 1 AACAPw== \"half Lambert\" Bool 1 AQ== \"light Mode\" Int 1 AAAAAA== \"light_position\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"light_color\" Float 3 AACAPwAAgD8AAIA/AAAAAA== 9 \"cam_Matrix\" 16 1 \"cam_Focal\" 1 1 \"cam_Hapeture\" 1 1 \"WHformat\" 2 1 \"zoom\" 1 1 \"halfLambert\" 1 1 \"lightMode\" 1 1 \"lightPos\" 3 1 \"lightcolor\" 3 1 10 \"vRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"pRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"tRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"vWorld\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"canvasWidth\" Float 1 1 AAAAAA== \"canvasHeight\" Float 1 1 AAAAAA== \"matrixData\" Float 1 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cameraToWorld\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"worldToCamera\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"namount\" Float 1 1 AAAAAA=="
   kernelSource "inline float Frac(float a_X)\n\{\n    return a_X-floor(a_X);\n\}\n\ninline float Fmax(float a_X,float b_X,float c_X)\n\{\n    return max(c_X,max(a_X,b_X));\n\}\ninline float Fmin(float a_X,float b_X,float c_X)\n\{\n    return min(c_X,min(a_X,b_X));\n\}\n\ninline float saturate(float _in)\n\{\n    return max(0.0f,min(1.0f,_in));\n\}\n\ninline float3 reflect(float3 incidence,float3 normal)\n\{\n  return incidence - 2.f * dot(incidence, normal) * normal;\n\}\n\n//This function is used to multiply a float3 by a matrix4x4\ninline float3 multVecMatrix( float3 src, float4x4 matrix)\n\{\n    float   x,y,z,w;\n    \n    x = src\[0]*matrix\[0]\[0] + src\[1]*matrix\[1]\[0] +\n    src\[2]*matrix\[2]\[0] + matrix\[3]\[0];\n    y = src\[0]*matrix\[0]\[1] + src\[1]*matrix\[1]\[1] +\n    src\[2]*matrix\[2]\[1] + matrix\[3]\[1];\n    z = src\[0]*matrix\[0]\[2] + src\[1]*matrix\[1]\[2] +\n    src\[2]*matrix\[2]\[2] + matrix\[3]\[2];\n    w = src\[0]*matrix\[0]\[3] + src\[1]*matrix\[1]\[3] +\n    src\[2]*matrix\[2]\[3] + matrix\[3]\[3];\n    \n    return float3(x/w, y/w, z/w);\n\}\n\n//This function is used to calculate the screenspace coordinates.\ninline bool computePixelCoordinates( \n    const float3 pWorld, \n    float3 &pRaster, \n    const float4x4 &worldToCamera, \n    const float &canvasWidth, \n    const float &canvasHeight, \n    const int &imageWidth, \n    const int &imageHeight\n) \n\{ \n    float3 pCamera; \n    pCamera = multVecMatrix(pWorld, worldToCamera); \n    float2 pScreen; \n    pScreen.x = pCamera.x / -pCamera.z; \n    pScreen.y = pCamera.y / -pCamera.z; \n    if (fabs(pScreen.x) > canvasWidth || fabs(pScreen.y) > canvasHeight) \n         return false; \n    float2 pNDC; \n    pNDC.x = (pScreen.x + canvasWidth * 0.5f) / canvasWidth; \n    pNDC.y = (pScreen.y + canvasHeight * 0.5f) / canvasHeight; \n    pRaster.x = (pNDC.x * imageWidth); \n    pRaster.y = ((pNDC.y) * imageHeight); \n    pRaster.z = -pCamera.z; \n    if (pRaster.x < 0.0f || pRaster.x > imageWidth || \n       pRaster.y < 0.0f || pRaster.y > imageHeight) \{\n       return false;  \n    \}\n    return true;\n\} \n\n\n\nkernel PointRender3D : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessRandom, eEdgeClamped> ppos;    //The point position map\n  Image<eWrite> dst;                 //the output image\n\n  param: //Parameters available to the user\n    float4x4 cam_Matrix;    //The world matrix of the camera\n    float cam_Focal;        //The focal length of the camera\n    float cam_Hapeture;     //The horizontal apeture of the camera\n    int2 WHformat;          //The format of the output image\n    float zoom;             //A \"post\" zoom function\n    bool halfLambert;\n    int lightMode;\n    float3 lightPos;\n    float3 lightcolor;\n\n\n  local: //Local variables\n    float3 vRaster;\n    float3 pRaster;\n    float3 tRaster;    \n    float3 vWorld;\n    float canvasWidth;\n    float canvasHeight; \n    float matrixData\[4]\[4];\n    float4x4 cameraToWorld;\n    float4x4 worldToCamera;\n    float namount; //dither amount\n\n\n  void define() \{\n    defineParam(cam_Matrix, \"cam_Matrix\", float4x4( 1.0f,0.0f,0.0f,0.0f,\n                                                    0.0f,1.0f,0.0f,0.0f,\n                                                    0.0f,0.0f,1.0f,0.0f,\n                                                    0.0f,0.0f,0.0f,1.0f));\n    defineParam(cam_Focal,      \"focallength\", 11.5f);\n    defineParam(cam_Hapeture,      \"hapeture\", 24.576f);\n    defineParam(WHformat,      \"format\", int2(2048,2048));\n    defineParam(zoom, \"Zoom\", 1.0f);\n    defineParam(halfLambert, \"half Lambert\", true);\n    defineParam(lightMode, \"light Mode\", 0);\n    defineParam(lightPos,      \"light_position\", float3(0,0,0));  \n    defineParam(lightcolor,      \"light_color\", float3(1.0,1.0,1.0)); \n  \}\n\n\n  //The init() function is run before any calls to process().\n  void init() \{\n    canvasWidth = ((cam_Hapeture)/cam_Focal);\n    canvasHeight = ((cam_Hapeture)/cam_Focal)*float(float(WHformat.y)/float(WHformat.x)); \n    float matrixData\[] = \{cam_Matrix\[0]\[0], cam_Matrix\[1]\[0], cam_Matrix\[2]\[0], cam_Matrix\[3]\[0], \n                          cam_Matrix\[0]\[1], cam_Matrix\[1]\[1], cam_Matrix\[2]\[1], cam_Matrix\[3]\[1], \n                          cam_Matrix\[0]\[2], cam_Matrix\[1]\[2], cam_Matrix\[2]\[2], cam_Matrix\[3]\[2], \n                          cam_Matrix\[0]\[3], cam_Matrix\[1]\[3], cam_Matrix\[2]\[3], cam_Matrix\[3]\[3]\};\n    cameraToWorld.setArray(matrixData); //This is a workaround. Due to the buggy matrix implementation, we pass the matrix on from another structure.\n    worldToCamera = cameraToWorld.invert();\n    namount = 0.0001; //dither amount\n  \}\n\n\n\nfloat3 Reconsile3D(float3 _PointPos)\{\n    vWorld = float3(_PointPos.x,_PointPos.y,_PointPos.z)*(zoom);\n    int ret = computePixelCoordinates(vWorld, tRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1]);\n    return tRaster;\n\}\n\n\n\n//-------------------------------------\n// Facet_Render\n//-------------------------------------\n//This function is used to calculate what triangels to draw\nfloat3 facet_render(int2 pos, float3 _vWorld)\{\n\n    float3 screen_pos = Reconsile3D(_vWorld);\n    bool insideX = ppos.bounds.inside(pos.x+1,pos.y );\n    bool insideY = ppos.bounds.inside(pos.x,pos.y-1 );\n    bool insideYtop = ppos.bounds.inside(pos.x,pos.y+1);\n    float2 fpos = float2(pos.x,pos.y);\n    float3 V1_Pos,V2_Pos,V1_wPos,V2_wPos;\n    float4 V0_Sample,V1_Sample,V2_Sample;\n    float3 normal0,normal1,normal2;\n\n    //for area calculation\n    float area;\n    float3 V0,V1,V2;\n    float3 output = float3(0.0f);\n  if (insideX) \{\n    V2_Sample = ppos(pos.x+1,pos.y);\n    V2_wPos = float3(V2_Sample.x,V2_Sample.y,V2_Sample.z);\n    V2_Pos = Reconsile3D(V2_wPos);\n    if (V2_Sample.w != 0.0f) \{ \n\n      if (insideY) \{\n        V1_Sample = ppos(pos.x+1,pos.y-1);\n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (V1_Sample.w != 0.0f) \{ \n            float3 Normal = CalculateVertexNormals(_vWorld,V2_wPos,V1_wPos);\n\n            //Calculate Area for density:\n            V0 = screen_pos;\n            V1 = V1_Pos;\n            V2 = V2_Pos;\n            V0.z = 1.0f / V0.z, V1.z = 1.0f / V1.z, V2.z = 1.0f / V2.z; \n            area = length(V0-V1)+length(V0-V2)+length(V1-V2);\n\n          //write output\n          output +=  float3(Normal.x,Normal.y,Normal.z);\n        \}\n      \}\n      if (insideYtop) \{\n        V1_Sample = ppos(pos.x,pos.y+1);\n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (V1_Sample.w != 0.0f) \{ \n          float3 Normal = CalculateVertexNormals(_vWorld,V1_wPos,V2_wPos);\n\n            //Calculate Area for density:\n            V0 = screen_pos;\n            V1 = V1_Pos;\n            V2 = V2_Pos;\n            V0.z = 1.0f / V0.z, V1.z = 1.0f / V1.z, V2.z = 1.0f / V2.z; \n            area = length(V0-V1)+length(V0-V2)+length(V1-V2);\n\n          output += float3(Normal.x,Normal.y,Normal.z);\n\n        \}\n      \}\n    \}\n  \}\n  return output;\n\}\n\n\n\nfloat3 CalculateSurfaceNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat3 CalculateVertexNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 hitNormal = cross((V1 - V0),(V2 - V0)); \n        return hitNormal;\n\}\n\n\n\n//-------------------------------------\n// Process\n//-------------------------------------\n  void process(int2 pos) \{\n    float3 output = float3(0.0f);\n    float4 _sample = ppos(pos.x,pos.y); //Get the XYZ Coordinates\n    float3 point_pos = float3(_sample.x,_sample.y,_sample.z);\n    if (_sample.w != 0.0f) \{  //No need to process if there is no data.\n      dst() = float4(0.0f);\n      output+=facet_render(pos,float3(_sample.x,_sample.y,_sample.z))*2.0f;\n      _sample = ppos(pos.x-1,pos.y); //Get the XYZ Coordinates\n      output+=facet_render(int2(pos.x-1,pos.y),float3(_sample.x,_sample.y,_sample.z));\n\n      _sample = ppos(pos.x-1,pos.y+1); //Get the XYZ Coordinates\n      output+=facet_render(int2(pos.x-1,pos.y+1),float3(_sample.x,_sample.y,_sample.z));\n\n      _sample = ppos(pos.x,pos.y-1); //Get the XYZ Coordinates\n      output+=facet_render(int2(pos.x,pos.y-1),float3(_sample.x,_sample.y,_sample.z));\n\n      output = normalize(output);\n      float3 normal = -output;\n\n      \n\n\n      dst() = float4(normal.x,normal.y,normal.z,1.0f);\n    \}\n  \} //----> process\n\};\n"
   rebuild ""
   "PointRender3D_half Lambert" false
   "PointRender3D_light Mode" {{parent.LightFalloff}}
   PointRender3D_light_position {{parent.Axis1.translate} {parent.Axis1.translate} {parent.Axis1.translate}}
   PointRender3D_light_color {{parent.LightColor} {parent.LightColor} {parent.LightColor}}
   rebuild_finalise ""
   name BlinkScript1
   xpos 389
   ypos 344
  }
  Grade {
   multiply 0.5
   add 0.5
   black_clamp false
   name Grade1
   xpos 389
   ypos 376
   disable true
  }
  Output {
   name Output1
   xpos 389
   ypos 459
  }
  Axis2 {
   inputs 0
   translate {0.5 0.5 0.5}
   name Axis1
   xpos 661
   ypos 318
   addUserKnob {20 Ivy}
   addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.toolbox.v1.nodes.docs', fromlist=\['open_docs_name']).open_docs_name('IvyTab')" +STARTLINE}
   addUserKnob {26 divider4 l "" +STARTLINE}
   addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
   _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
   addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
   addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
   addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
   _expressions {{curve}}
   addUserKnob {26 divider0 l "" +STARTLINE}
   addUserKnob {20 dbinfo l "DB Info" n 1}
   dbinfo 0
   addUserKnob {1 twig_dnuuid l "Twig Id"}
   addUserKnob {1 stalk_dnuuid l "Stalk Id"}
   addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
   addUserKnob {1 leaf_dnuuid l "Leaf Id"}
   addUserKnob {26 divider1 l "" +STARTLINE}
   addUserKnob {1 twigtype l "Twig Type"}
   addUserKnob {1 leaf_label l Leaf}
   addUserKnob {1 ivy_version l Version}
   addUserKnob {43 ivy_notes l Notes}
   addUserKnob {26 divider2 l "" +STARTLINE}
   addUserKnob {1 build_label l "Build Label"}
   addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
  }
 end_group
 Switch {
  inputs 2
  which {{parent.connect_aux}}
  name Switch3
  xpos -324
  ypos 311
 }
push $N482e9270
 Expression {
  temp_name0 xd
  temp_expr0 red-Camera1.world_matrix.3
  temp_name1 yd
  temp_expr1 green-Camera1.world_matrix.7
  temp_name2 zd
  temp_expr2 blue-Camera1.world_matrix.11
  temp_name3 Distance
  temp_expr3 "sqrt(xd*xd + yd*yd + zd*zd)"
  expr0 Distance
  expr1 Distance
  expr2 Distance
  expr3 Distance
  name Expression1
  xpos -456
  ypos -192
 }
 Grade {
  channels rgba
  blackpoint {{parent.FogFar}}
  whitepoint {{parent.FogNear}}
  gamma {{1/(parent.FogExponent+0.000000001)}}
  white_clamp true
  name Grade1
  xpos -456
  ypos -168
 }
push $N53eef370
 Dot {
  name Dot7
  xpos -307
  ypos -513
 }
 Merge2 {
  inputs 2
  operation multiply
  name Merge1
  xpos -341
  ypos -168
  disable {{!parent.Fog}}
 }
 Shuffle {
  name Shuffle3
  xpos -341
  ypos 8
 }
set N48293040 [stack 0]
push $N4806f920
 BlinkScript {
  inputs 4
  kernelSourceFile /Users/madshagbarth/Github/Nuke-Private/Blink/PointRender/Render/3D_PointRender_v15.cpp
  recompileCount 792
  ProgramGroup 1
  KernelDescription "2 \"PointRender3D\" iterate pixelWise e0ecbbf4cba39730471d23bc9f9ec846fcae1bbb869971a11b15641cf6fd5620 5 \"ppos\" Read Random \"src\" Read Random \"normals\" Read Random \"occlusion\" Read Random \"dst\" Write Random 48 \"cam_Matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== \"focallength\" Float 1 AAA4QQ== \"hapeture\" Float 1 ppvEQQ== \"format\" Int 2 AAgAAAAIAAA= \"vertexformat\" Int 2 CgAAAAoAAAA= \"Zoom\" Float 1 AACAPw== \"Filtering Method\" Int 1 AQAAAA== \"_alphaMultiplier\" Float 1 AACAPw== \"_pointRender\" Bool 1 AQ== \"_wireRender\" Bool 1 AQ== \"_facetRender\" Bool 1 AQ== \"_maxLDistance\" Float 1 AACAPw== \"_maxLConnections\" Int 1 AQAAAA== \"_maxPlexType\" Int 1 AAAAAA== \"_plexLinedefXY\" Bool 1 AA== \"_plexLinedefX\" Bool 1 AA== \"_plexLinedefY\" Bool 1 AA== \"_plexLinedefXtoY\" Bool 1 AA== \"_plexLinedefAUX\" Bool 1 AA== \"_plexConnectX\" Bool 1 AA== \"_plexConnectY\" Bool 1 AA== \"_L_gamma\" Float 1 AACAPw== \"Enable Depth of Field\" Bool 1 AA== \"samples\" Int 1 AwAAAA== \"rings\" Int 1 BQAAAA== \"focalDepth\" Float 1 AACAPw== \"_depthOfField\" Float 1 AACAQA== \"_depthMult\" Float 1 zczMPQ== \"_maxDofSize\" Float 1 AAAAQQ== \"dof_aspect\" Float 1 AACAPw== \"dof_threshold\" Float 1 AACAPw== \"dof_gain\" Float 1 AAAAAA== \"dof_bias\" Float 1 AAAAwA== \"dof_fringe\" Float 1 AAAAAA== \"_flatshading\" Bool 1 AQ== \"_backfacing\" Bool 1 AQ== \"_frontfacing\" Bool 1 AQ== \"_vertexMode\" Int 1 AAAAAA== \"_depthBuffer\" Bool 1 AQ== \"_texoffset\" Float 2 AAAAPwAAAD8= \"_pointSize\" Int 1 AQAAAA== \"_gaussigma\" Float 1 AACAPw== \"_depthOcclusion\" Bool 1 AQ== \"depthMultiplier\" Float 1 AACAPw== \"_maxLineSteps\" Float 1 AAB6RQ== \"_lineOffset\" Float 1 AACAPw== \"_lineInMultiplier\" Float 1 AACAPw== \"_lineOutMultiplier\" Float 1 AACAPw== 48 \"cam_Matrix\" 16 1 \"cam_Focal\" 1 1 \"cam_Hapeture\" 1 1 \"WHformat\" 2 1 \"Vformat\" 2 1 \"zoom\" 1 1 \"_filtering\" 1 1 \"_alphaMultiplier\" 1 1 \"_pointRender\" 1 1 \"_wireRender\" 1 1 \"_facetRender\" 1 1 \"_maxPlexDistance\" 1 1 \"_maxPlexConnections\" 1 1 \"_maxPlexType\" 1 1 \"_plexLinedefXY\" 1 1 \"_plexLinedefX\" 1 1 \"_plexLinedefY\" 1 1 \"_plexLinedefXtoY\" 1 1 \"_plexLinedefAUX\" 1 1 \"_plexConnectX\" 1 1 \"_plexConnectY\" 1 1 \"_plex_gamma\" 1 1 \"_dof_enable\" 1 1 \"_dof_samples\" 1 1 \"_dof_rings\" 1 1 \"focalDepth\" 1 1 \"_depthOfField\" 1 1 \"_depthMult\" 1 1 \"_maxDofSize\" 1 1 \"dof_aspect\" 1 1 \"dof_threshold\" 1 1 \"dof_gain\" 1 1 \"dof_bias\" 1 1 \"dof_fringe\" 1 1 \"_flatshading\" 1 1 \"_backfacing\" 1 1 \"_frontfacing\" 1 1 \"_vertexMode\" 1 1 \"_depthBuffer\" 1 1 \"_texoffset\" 2 1 \"_pointSize\" 1 1 \"_gaussigma\" 1 1 \"_depthOcclusion\" 1 1 \"depthMultiplier\" 1 1 \"_maxLineSteps\" 1 1 \"_lineOffset\" 1 1 \"_lineInMultiplier\" 1 1 \"_lineOutMultiplier\" 1 1 10 \"max_line_connections\" Int 1 1 AAAAAA== \"vRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"pRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"tRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"vWorld\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"canvasWidth\" Float 1 1 AAAAAA== \"canvasHeight\" Float 1 1 AAAAAA== \"matrixData\" Float 1 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cameraToWorld\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"worldToCamera\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "//Some basic generic functions.\ninline float Frac(float a_X)\n\{\n    return a_X-floor(a_X);\n\}\n\ninline float3 Cross(float3 A,float3 B)\n\{\n    return float3(A.y*B.z - A.z*B.y,A.z*B.x - A.x*B.z,A.x*B.y - A.y*B.x);\n\}\n\ninline float Fmax(float a_X,float b_X,float c_X)\n\{\n    return max(c_X,max(a_X,b_X));\n\}\ninline float Fmin(float a_X,float b_X,float c_X)\n\{\n    return min(c_X,min(a_X,b_X));\n\}     \n\ninline float3 mix(float3 _X,float3 _Y,float _A)\{\n  return _X*(1.0f-_A)+_Y*_A;\n\}\ninline float mix(float _X,float _Y,float _A)\{\n  return _X*(1.0f-_A)+_Y*_A;\n\}                                                                                              \n\n//This function is used to multiply a float3 by a matrix4x4\ninline float3 multVecMatrix( float3 src, float4x4 matrix)\n\{\n    float   x,y,z,w;\n\n    x = src\[0]*matrix\[0]\[0] + src\[1]*matrix\[1]\[0] +\n    src\[2]*matrix\[2]\[0] + matrix\[3]\[0];\n    y = src\[0]*matrix\[0]\[1] + src\[1]*matrix\[1]\[1] +\n    src\[2]*matrix\[2]\[1] + matrix\[3]\[1];\n    z = src\[0]*matrix\[0]\[2] + src\[1]*matrix\[1]\[2] +\n    src\[2]*matrix\[2]\[2] + matrix\[3]\[2];\n    w = src\[0]*matrix\[0]\[3] + src\[1]*matrix\[1]\[3] +\n    src\[2]*matrix\[2]\[3] + matrix\[3]\[3];\n    \n    return float3(x/w, y/w, z/w);\n\}\n\n//This function is used to calculate the screenspace coordinates.\ninline bool computePixelCoordinates( \n    const float3 pWorld, \n    float3 &pRaster, \n    const float4x4 &worldToCamera, \n    const float &canvasWidth, \n    const float &canvasHeight, \n    const int &imageWidth, \n    const int &imageHeight\n) \n\{ \n    float3 pCamera; \n    pCamera = multVecMatrix(pWorld, worldToCamera); \n    float2 pScreen; \n    pScreen.x = pCamera.x / -pCamera.z; \n    pScreen.y = pCamera.y / -pCamera.z; \n    float2 pNDC; \n    pNDC.x = (pScreen.x + canvasWidth * 0.5f) / canvasWidth; \n    pNDC.y = (pScreen.y + canvasHeight * 0.5f) / canvasHeight; \n    pRaster.x = (pNDC.x * imageWidth); \n    pRaster.y = ((pNDC.y) * imageHeight); \n    pRaster.z = -pCamera.z; \n    if (pRaster.x < 0.0f || pRaster.x > imageWidth || \n       pRaster.y < 0.0f || pRaster.y > imageHeight || pRaster.z < 0.0f) \{\n       return false;  \n    \}\n    return true;\n\} \n\n\nkernel PointRender3D : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessRandom, eEdgeClamped> ppos;    //The point position map\n  Image<eRead, eAccessRandom, eEdgeClamped> src;     //The texture map\n  Image<eRead, eAccessRandom, eEdgeClamped> normals;     //The texture map  \n  Image<eRead, eAccessRandom, eEdgeClamped> occlusion;     //The texture map \n  Image<eWrite, eAccessRandom> dst;                 //the output image\n\n  param: //Parameters available to the user\n    float4x4 cam_Matrix;    //The world matrix of the camera\n    float cam_Focal;        //The focal length of the camera\n    float cam_Hapeture;     //The horizontal apeture of the camera\n    int2 WHformat,Vformat;          //The format of the output image\n    float zoom;             //A \"post\" zoom function\n    int _filtering;        //Filter method\n    float _alphaMultiplier; //Additive multiplier\n    bool _pointRender,_wireRender,_facetRender;\n    float _maxPlexDistance; //Additive multiplier\n    int _maxPlexConnections;\n    int _maxPlexType; // 0==Grid, -1==Nearest\n    bool _plexLinedefXY,_plexLinedefX,_plexLinedefY,_plexLinedefXtoY,_plexLinedefAUX; // Define what connections NOT to include\n    bool _plexConnectX,_plexConnectY; //Connect from the edge of x to 0, or edge of y to 0, usually for spheres\n    float _plex_gamma; //The threshold making shorter paths bright and longer paths dark\n    bool _dof_enable; // Enable DOF\n    int _dof_samples; // How many samples per DOF ring\n    int _dof_rings; // How many rings \n    float focalDepth,_depthOfField,_depthMult,_maxDofSize; //DOF Settings\n    float dof_aspect; //Pixel aspect ratio\n    float dof_threshold;\n    float dof_gain;\n    float dof_bias; //bokeh edge bias\n    float dof_fringe; //bokeh chromatic aberration/fringing\n    bool _flatshading,_backfacing,_frontfacing; //Vertex rendering settings\n    int _vertexMode;  //The rendering output mode, (think AOV)\n    bool _depthBuffer; //Non-additive, only render front most pixel\n    float2 _texoffset;\n    int _pointSize;\n    float _gaussigma;\n    bool _depthOcclusion;\n    float depthMultiplier;\n    float _maxLineSteps; //cap the line length to avoid process lock\n    float _lineOffset; //Alow you to shrink or extend the lines\n    float _lineInMultiplier,_lineOutMultiplier; //Control the brightness of the wires at the tips.\n\n  local: //Local variables\n    int max_line_connections;\n    float3 vRaster;\n    float3 pRaster;\n    float3 tRaster;    \n    float3 vWorld;\n    float canvasWidth;\n    float canvasHeight; \n    float matrixData\[4]\[4];\n    float4x4 cameraToWorld;\n    float4x4 worldToCamera;\n\n  void define() \{\n    defineParam(cam_Matrix, \"cam_Matrix\", float4x4( 1.0f,0.0f,0.0f,0.0f,\n                                                    0.0f,1.0f,0.0f,0.0f,\n                                                    0.0f,0.0f,1.0f,0.0f,\n                                                    0.0f,0.0f,0.0f,1.0f));\n    defineParam(cam_Focal,      \"focallength\", 11.5f);\n    defineParam(cam_Hapeture,      \"hapeture\", 24.576f);\n    defineParam(WHformat,      \"format\", int2(2048,2048));\n    defineParam(Vformat,      \"vertexformat\", int2(10,10));\n    defineParam(zoom, \"Zoom\", 1.0f);\n    defineParam(_filtering, \"Filtering Method\", 1); \n    defineParam(_alphaMultiplier, \"_alphaMultiplier\", 1.0f);     \n    defineParam(_pointRender, \"_pointRender\", true);  \n    defineParam(_wireRender, \"_wireRender\", true);\n    defineParam(_facetRender, \"_facetRender\", true);\n    defineParam(_maxPlexDistance, \"_maxLDistance\", 1.0f);    \n    defineParam(_maxPlexConnections, \"_maxLConnections\", 1);    \n    defineParam(_maxPlexType, \"_maxPlexType\", 0); \n    defineParam(_plexLinedefXY, \"_plexLinedefXY\", false);      \n    defineParam(_plexLinedefXtoY, \"_plexLinedefXtoY\", false); //NYI\n    defineParam(_plexLinedefAUX, \"_plexLinedefAUX\", false); \n    defineParam(_plexLinedefX, \"_plexLinedefX\", false);  \n    defineParam(_plexLinedefY, \"_plexLinedefY\", false);  \n    defineParam(_plexConnectX, \"_plexConnectX\", false);      \n    defineParam(_plexConnectY, \"_plexConnectY\", false);   \n    defineParam(_plex_gamma, \"_L_gamma\", 1.0f);\n    //DOF SETTINGS   \n    defineParam(_dof_enable, \"Enable Depth of Field\", false);   \n    defineParam(_dof_samples, \"samples\", 3);    \n    defineParam(_dof_rings, \"rings\", 5);   \n    defineParam(focalDepth, \"focalDepth\", 1.0f);  \n    defineParam(_depthOfField, \"_depthOfField\", 4.0f);  \n    defineParam(_depthMult, \"_depthMult\", 0.1f);  \n    defineParam(_maxDofSize, \"_maxDofSize\", 8.0f);  \n    defineParam(dof_aspect, \"dof_aspect\", 1.0f);  \n    defineParam(dof_threshold, \"dof_threshold\", 1.0f);  \n    defineParam(dof_gain, \"dof_gain\", 0.0f);  \n    defineParam(dof_bias, \"dof_bias\", -2.0f);  \n    defineParam(dof_fringe, \"dof_fringe\", 0.0f); \n    //SHADING SETTINGS \n    defineParam(_flatshading, \"_flatshading\", true);  \n    defineParam(_vertexMode, \"_vertexMode\", 0);  \n    defineParam(_backfacing, \"_backfacing\", true);    \n    defineParam(_frontfacing, \"_frontfacing\", true);        \n    defineParam(_depthBuffer, \"_depthBuffer\", true);  \n    defineParam(_texoffset, \"_texoffset\", float2(0.5f,0.5f)); \n    defineParam(_pointSize, \"_pointSize\", 1); \n    defineParam(_gaussigma, \"_gaussigma\", 1.0f); \n    defineParam(_depthOcclusion, \"_depthOcclusion\", true); \n    defineParam(depthMultiplier, \"depthMultiplier\", 1.0f); \n    defineParam(_maxLineSteps, \"_maxLineSteps\", 4000.0f); \n    defineParam(_lineOffset, \"_lineOffset\", 1.0f); \n    defineParam(_lineInMultiplier, \"_lineInMultiplier\", 1.0f);   \n    defineParam(_lineOutMultiplier, \"_lineOutMultiplier\", 1.0f);     \n\n  \}\n\n  //The init() function is run before any calls to process().\n  void init() \{\n    max_line_connections = 80;\n    canvasWidth = ((cam_Hapeture)/cam_Focal);\n    canvasHeight = ((cam_Hapeture)/cam_Focal)*float(float(WHformat.y)/float(WHformat.x)); \n    float matrixData\[] = \{cam_Matrix\[0]\[0], cam_Matrix\[1]\[0], cam_Matrix\[2]\[0], cam_Matrix\[3]\[0], \n                          cam_Matrix\[0]\[1], cam_Matrix\[1]\[1], cam_Matrix\[2]\[1], cam_Matrix\[3]\[1], \n                          cam_Matrix\[0]\[2], cam_Matrix\[1]\[2], cam_Matrix\[2]\[2], cam_Matrix\[3]\[2], \n                          cam_Matrix\[0]\[3], cam_Matrix\[1]\[3], cam_Matrix\[2]\[3], cam_Matrix\[3]\[3]\};\n    cameraToWorld.setArray(matrixData); //This is a workaround. Due to the buggy matrix implementation, we pass the matrix on from another structure.\n    worldToCamera = cameraToWorld.invert();\n  \}\n\n  //Convert a 3d point position into a 2d raster position.\n  float3 Reconsile3D(float3 _PointPos)\{\n      vWorld = float3(_PointPos.x,_PointPos.y,_PointPos.z)*(zoom);\n      int ret = computePixelCoordinates(vWorld, tRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1]);\n      return tRaster;\n  \}\n\n//------------------------------\n//-------DRAW FUNCTIONS---------\n//------------------------------\n  //Write pixels to output.\n  void writepixel(float posx,float posy, float4 color,int index,float weight=1.0f)\n  \{ \n      if (_depthOcclusion)\{\n        float4 depthSample = occlusion(posx,posy);\n        if (depthSample.x<=vRaster.z && depthSample.w>0.0f)\{\n\n          float depth = (vRaster.z-depthSample.x);\n          color = color*(1.0f-depthSample.w);\n          color = color / (((depth*depth)*depthMultiplier)+1.0f);\n          //return;\n        \}\n      \}\n      float4 finalOutput; //This is used to store the final output\n      float4 dstSample; //This is used to store a sample of the destination\n      if ( dst.bounds.inside( posx, posy ) ) \{ //Test if the pixel written to is inside the output image. \n        if (_depthBuffer) \{\n          dstSample = (float4)dst(posx,posy); //Sample the destination image\n          if ((dstSample.w>color.w)||dstSample.w==0.0f) \{\n            dst(posx,posy) = color;\n          \}\n        \}\n        else \{\n          dstSample = (float4)dst(posx,posy); //Sample the destination image\n          finalOutput = dstSample + (color*_alphaMultiplier*weight);\n          finalOutput.w = dstSample.w + ((color.w*_alphaMultiplier*weight));\n\n          finalOutput.w = (dstSample.w + ((color.w*_alphaMultiplier*weight)))-(dstSample.w * ((color.w*_alphaMultiplier*weight)));\n\n          dst(posx,posy) = finalOutput;\n        \}\n      \} \n  \}\n\n  //Calculate a Bilinear Plot\n  void bilinear_Plot(float2 temppos,float4 color,int index)\n  \{\n    float2 p;\n    p.x=Frac(temppos.x);\n    p.y=Frac(temppos.y);\n    float weights\[] = \{(1.0f-p.x)*(1.0f-p.y), p.x*(1.0f-p.y), (1.0f-p.x)*p.y, p.x*p.y\};\n    int2 _position = int2(floor(temppos.x)-0,floor(temppos.y)-0); \n    writepixel(_position.x,_position.y,color,index,weights\[0]);\n    writepixel(_position.x+1,_position.y,color,index,weights\[1]);\n    writepixel(_position.x,_position.y+1,color,index,weights\[2]);\n    writepixel(_position.x+1,_position.y+1,color,index,weights\[3]);\n  \}\n\n  //NYI, unused!\n  void gaussian(float2 temppos,float4 color,int index)\{\n    float in_x = temppos.x;\n    float in_y = temppos.y;\n    int kernelSize = (_pointSize+1)*2;\n    int subsize = (kernelSize /2)-1;\n    float gKernel\[64]\[64];\n    float sigma = _gaussigma;\n    float intSigma = float(_pointSize);\n    float r, s = intSigma * sigma * sigma;\n\n    float sum = 0.0f;\n\n    // generate 5x5 kernel\n    for (int x = -subsize; x <= subsize; x++)\n    \{\n        for(int y = -subsize; y <= subsize; y++)\n        \{\n            r = float(sqrt(x*x + y*y));\n            gKernel\[x + subsize]\[y + subsize] = (exp(-(r*r)/s))/(3.141592654f * s);\n            sum += gKernel\[x + subsize]\[y + subsize];\n        \}\n    \}\n\n    // normalize the Kernel\n    for (int x = -subsize; x <= subsize; x++)\n    \{\n        for(int y = -subsize; y <= subsize; y++)\n        \{\n            gKernel\[x + subsize]\[y + subsize] /= sum;\n            writepixel(in_x+x,in_y+y,color,index,gKernel\[x + subsize]\[y + subsize]);\n        \}\n    \}\n  \}\n\n//-------------------------------------\n// DrawLine\n// ----------\n// Draw a line between two points, \n// x,y being 2d screenspace pos and z being depth.\n//-------------------------------------\n  void DrawLine(float3 origin, float3 endpoint,float4 _colorA,float4 _colorB) \{\n    float4 _color;\n    float3 delta = origin-endpoint;\n    float3 curPoint = origin;\n    float mag = sqrt(delta.x*delta.x+delta.y*delta.y);\n    mag = min(mag,_maxLineSteps); //Lets not go crazy, we cap it at 10.000 to avoid insane unwated processing time \n    for( float a = 0; a < mag*_lineOffset; a = a + 1.0f )\{\n      curPoint -= (delta/mag);\n      _color = (_colorA*(1.0f-(a/mag*1.0f)))+(_colorB*(a/mag*1.00f));\n      if (_dof_enable)\{\n        Bokeh(curPoint,_color);\n      \}\n      else \{\n        bilinear_Plot(float2(curPoint.x,curPoint.y),_color,1);\n      \}\n      \n    \}\n  \}\n\n//-------------------------------------\n// Point_Render\n//-------------------------------------\nvoid point_render(int2 pos, float3 screen_pos)\{\n  float4 color = src(pos.x,pos.y);\n\n  if (_filtering == 1)\{\n      if (_dof_enable)\{\n        Bokeh(screen_pos,color);\n      \}\n      else \{\n        bilinear_Plot(float2(screen_pos.x,screen_pos.y),color,1);\n      \}\n  \}\n  /*\n  //THIS PART NEEDS TO BE RE-WRITTEN.\n  else if (_filtering == 2)\{ \n      if (_dof_enable)\{\n        Bokeh(screen_pos,color);\n      \}\n      else \{\n        gaussian(float2(screen_pos.x,screen_pos.y),color,1);\n      \}\n  \}\n  */\n  else \{\n      int2 _position = int2(floor(screen_pos.x),floor(screen_pos.y)); \n      if (_depthBuffer) \{color.w = screen_pos.z;\}\n      writepixel(_position.x,_position.y, color,1,1.0f); //OutputSample\n  \}\n\n\}\n\n//-------------------------------------\n// Facet_Render\n//-------------------------------------\n//This function is used to calculate what triangels to draw\nvoid facet_render(int2 pos, float3 _vWorld)\{\n\n    float3 screen_pos = Reconsile3D(_vWorld);\n\n    bool insideX = ppos.bounds.inside(pos.x+1,pos.y );\n    bool insideY = ppos.bounds.inside(pos.x+1,pos.y-1 );\n    bool insideYtop = ppos.bounds.inside(pos.x,pos.y+1);\n    float2 fpos = float2(pos.x,pos.y);\n    float3 V1_Pos,V2_Pos,V1_wPos,V2_wPos,V0_N,V1_N,V2_N;\n    float2 V0_ST,V1_ST,V2_ST;\n    float4 V1_Sample,V2_Sample;\n    float4 _tn;\n    float3 normal0,normal1,normal2;\n    float2 UV_Format = float2(Vformat.x,Vformat.y);\n\n\n    int2 P0 = int2(pos.x-1,pos.y-1);\n    int2 P1 = int2(pos.x+1,pos.y+1);\n    if (_plexConnectX && pos.x == int(Vformat.x))\{\n      insideX == true;\n      P1 = int2(0.0f,pos.y+1);\n    \}\n    if (_plexConnectY && pos.y == int(Vformat.y))\{\n      insideYtop == true;\n      P1 = int2(pos.x+1,0);\n    \} \n\n    if (_plexConnectY && pos.y == 0)\{\n      insideY == true;\n      P0 = int2(pos.x-1,int(UV_Format.y));\n    \} \n\n    if (!_flatshading) \{\n      _tn = normals(pos.x,pos.y);\n      V0_N =float3(_tn.x,_tn.y,_tn.z);\n    \}\n    V0_ST = float2(pos.x,pos.y)/UV_Format;\n\n  if (insideX) \{\n    V2_Sample = ppos(P1.x,pos.y);\n    V2_ST = float2(P1.x,pos.y)/UV_Format;\n    V2_wPos = float3(V2_Sample.x,V2_Sample.y,V2_Sample.z);\n    V2_Pos = Reconsile3D(V2_wPos);\n    if (!_flatshading) \{\n      _tn = normals(P1.x,pos.y);\n      V2_N =float3(_tn.x,_tn.y,_tn.z);\n    \}\n        \n\n    if (V2_Sample.w != 0.0f) \{ \n\n      if (insideY) \{\n        V1_Sample = ppos(P1.x,P0.y);\n        V1_ST = float2(P1.x,P0.y)/UV_Format;\n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (!_flatshading) \{\n          _tn = normals(P1.x,P0.y);\n          V1_N =float3(_tn.x,_tn.y,_tn.z);\n        \}\n        if (V1_Sample.w != 0.0f) \{ \n          DrawTriangle(screen_pos,V2_Pos,V1_Pos,_vWorld,V2_wPos,V1_wPos,V0_N,V2_N,V1_N,V0_ST,V2_ST,V1_ST);\n        \}\n      \}\n      if (insideYtop) \{\n        V1_Sample = ppos(pos.x,P1.y);\n        V1_ST = float2(pos.x,P1.y)/UV_Format;        \n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (!_flatshading) \{\n          _tn = normals(pos.x,P1.y);\n          V1_N =float3(_tn.x,_tn.y,_tn.z);\n        \}        \n        if (V1_Sample.w != 0.0f) \{ \n          DrawTriangle(screen_pos,V1_Pos,V2_Pos,_vWorld,V1_wPos,V2_wPos,V0_N,V1_N,V2_N,V0_ST,V1_ST,V2_ST);\n        \}\n      \}\n    \}\n  \}\n\}\n\n\n\n//This function will calculate if pixel C is inside the triangle\nfloat edgeFunction(float3 a, float3 b, float3 c) \n\{ \n    return ((c.x - a.x) * (b.y - a.y) - (c.y - a.y) * (b.x - a.x)); \n\} \n\nfloat3 CalculateSurfaceNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat3 CalculateVertexNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat Distance(float3 _a,float3 _b)\n\{\n          float xd = _a.x - _b.x;\n          float yd = _a.y - _b.y;\n          float zd = _a.z - _b.z;\n          return sqrt(xd*xd + yd*yd + zd*zd);\n\}\n\nvoid DrawTriangle(float3 V0, float3 V1, float3 V2,float3 WP0, float3 WP1, float3 WP2,float3 N0, float3 N1, float3 N2, float2 st0,float2 st1,float2 st2) \{\n\n  // Precompute reciprocal of vertex z-coordinate \n  V0.z = 1.0f / V0.z, V1.z = 1.0f / V1.z, V2.z = 1.0f / V2.z; \n\n  float2 st0n = st0 * V0.z;\n  float2 st1n = st1 * V1.z; \n  float2 st2n = st2 * V2.z; //Normal version of ST\n\n  bool inside; \n  float X0 = Fmin(V0.x,V1.x,V2.x)-1.0f;\n  float X1 = Fmax(V0.x,V1.x,V2.x)+1.0f;\n  float Y0 = Fmin(V0.y,V1.y,V2.y)-1.0f;\n  float Y1 = Fmax(V0.y,V1.y,V2.y)+1.0f;\n  float area = edgeFunction(V2, V1, V0);\n\n\n  float2 sampos = float2(st0.x*float(Vformat.x),st0.y*float(Vformat.y));\n  float4 text0 = src(sampos.x,sampos.y);\n  sampos = float2(st1.x*float(Vformat.x),st1.y*float(Vformat.y));\n  float4 text1 = src(sampos.x,sampos.y);\n  sampos = float2(st2.x*float(Vformat.x),st2.y*float(Vformat.y));  //Why do we have to do this? =(\n  float4 text2 = src(sampos.x,sampos.y);\n  sampos = float2(min(min(st0.x,st1.x),st2.x)*float(Vformat.x),min(min(st0.y,st1.y),st2.y)*float(Vformat.y));\n  float4 text3 = src(sampos.x,sampos.y);\n\n\n  for( int x = X0; x < X1 ; x++) \{\n    for( int y = Y0; y < Y1 ; y++) \{\n      float3 pixelSample(x + _texoffset.x, y + _texoffset.y,0.0f); \n\n      //This is the part where we test if the current pixel is inside the triangle\n      //We check both for front facing and back faing options\n      float w0 = edgeFunction(V1, V0, pixelSample); //Front Facing\n      float w1 = edgeFunction(V2, V1, pixelSample); \n      float w2 = edgeFunction(V0, V2, pixelSample); \n      float w3 = edgeFunction(V0, V1, pixelSample); //Back Facing\n      float w4 = edgeFunction(V1, V2, pixelSample); \n      float w5 = edgeFunction(V2, V0, pixelSample);\n\n      //writepixel(x,y, float4(w1),1,1.0f);\n      if ((w0 >= 0 && w1 >= 0 && w2 >= 0 && _frontfacing) || (w3 >= 0 && w4 >= 0 && w5 >= 0 && _backfacing)) \{ //The curent pixel is inside the triangle\n\n       // calculate vectors from point f to vertices p1, p2 and p3:\n       float3 f1 = V0-pixelSample;\n       float3 f2 = V1-pixelSample;\n       float3 f3 = V2-pixelSample;\n       // calculate the areas and factors (order of parameters doesn't matter):\n       float a = length(cross(V0-V1,V0-V2 )); // main triangle area a\n       area = length(V0-V1)+length(V0-V2)+length(V1-V2);\n\n        w0 /= area; \n        w1 /= area; \n        w2 /= area; \n\n        w3 /= area; \n        w4 /= area; \n        w5 /= area; \n\n       float a1 = length(cross(f2, f3)) / a; // p1's triangle area / a\n       float a2 = length(cross(f3, f1)) / a; // p2's triangle area / a \n       float a3 = length(cross(f1, f2)) / a; // p3's triangle area / a\n       float a_magnitude = a1+a2+a3;\n       a1 = a1/a_magnitude;\n       a2 = a2/a_magnitude;\n       a3 = a3/a_magnitude;\n       float z = 1.0f / (V0.z * a1 + V1.z * a2 + V2.z * a3); \n\n\n        // find the uv corresponding to point f (uv1/uv2/uv3 are associated to p1/p2/p3):\n        float2 uv = st0 * a1 + st1 * a2 + st2 * a3;\n        float2 st = st0 * w0 + st1 * w1 + st2 * w2; \n        st *= z;      \n\n\n        //Calculate normals. Eighter we have flat shading, else we calculate a normal per pixel\n        float3 normalB;\n        if (_flatshading) \{\n          normalB = CalculateSurfaceNormals(WP0,WP1,WP2);\n\n        \}\n        else \{\n          float3 c0 = N2/float3(V0.z); \n          float3 c1 = N0/float3(V1.z); \n          float3 c2 = N1/float3(V2.z);  \n\n          normalB.x = w0 * c0.x + w1 * c1.x + w2 * c2.x; \n          normalB.y = w0 * c0.y + w1 * c1.y + w2 * c2.y; \n          normalB.z = w0 * c0.z + w1 * c1.z + w2 * c2.z; \n\n          normalB.x *= z, normalB.y *= z, normalB.z *= z; \n        \}\n        normalB = normalize(normalB);\n\n        //CALCULATE THE OBJECT TEXTURE COORDINATES\n        float zn = 1.0f / (V0.z * w0 + V1.z * w1 + V2.z * w2); \n        st = st0n * w0 + st1n * w1 + st2n * w2; \n        st *= zn;   \n        //--END \n\n        float3 Wpos = WP0*a1 + WP1*a2 + WP2*a3; //World Position.\n        float3 ViewNormal = normalize(float3(cameraToWorld\[3]\[0],cameraToWorld\[3]\[1],cameraToWorld\[3]\[2])-Wpos);\n\n        float nDotView =  dot(normalB,ViewNormal);\n        nDotView = 1.0f-fabs(nDotView); //make sure that the view normal ramps back around when doing backface\n        float4 tempout;\n\n        //Flatshading or regular?\n        if (!_flatshading) \{\n          tempout = text0 * a1 + text1 * a2 + text2 * a3; \n        \}\n        else\{\n          tempout = text3;\n        \}\n\n        //Additional Render Modes\n        if (_vertexMode == 1)\{\n          tempout = float4(a1,a2,a3,1.0f);\n        \}\n        else if (_vertexMode == 2)\{\n          tempout = float4(normalB.x,normalB.y,normalB.z,1.0f);\n        \}\n        else if (_vertexMode == 3)\{\n          tempout = float4(nDotView,nDotView,nDotView,1.0f);\n        \}\n        else if (_vertexMode == 4)\{\n          tempout = float4(uv.x,uv.y,0.0f,1.0f);\n        \}       \n        else if (_vertexMode == 5)\{\n          tempout = float4(st.x,st.y,0.0f,1.0f);\n        \}               \n        else if (_vertexMode == 6)\{\n          tempout = float4(ViewNormal.x,ViewNormal.y,ViewNormal.z,1.0f);\n        \}             \n        else if (_vertexMode == 7)\{\n          tempout = float4(Wpos.x,Wpos.y,Wpos.z,1.0f);\n        \}   \n\n        if (_depthBuffer)\{\n          writepixel(x,y, float4(tempout.x,tempout.y,tempout.z,z),1,1.0f);  \n        \}\n        else \{\n          if (_dof_enable)\{\n            Bokeh(float3(x,y,z),float4(tempout.x,tempout.y,tempout.z,z));\n          \}\n          else \{\n            bilinear_Plot(float2(x,y),float4(tempout.x,tempout.y,tempout.z,z),1);\n          \}\n        \}\n\n      \}  \n\n    \}\n  \}\n\}\n\n//-------------------------------------\n// Wire_Render\n//-------------------------------------\nvoid wire_render(int2 pos) \{\n  float4 temp = float4(0.0f,0.0f,0.0f,FLT_MAX);\n  float4 wire_ref_sample;\n  int2 tempXY = int2(0,0);\n  float4 plexlist\[11] = \{temp,temp,temp,temp,temp,temp,temp,temp,temp,temp,temp\}; \n  int2 plexlistXY\[11] = \{tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY\};\n  int plex_count = 0; //We use this to figure how many points that should connect.\n  float plex_dist;\n  float3 plex_position,plex_position_b;\n  float4 temp_pos, temp_pos_b; //Temporary Position Containers\n  if (_maxPlexType == -1) \{ //Used for random connection types\n    for( int x = 0; x < max_line_connections ; x++)\{ //THIS 80 NUMBER IS THE LIMIT TO AVOID TOO SLOW PROCESSING!\n      for( int y = 0; y < max_line_connections ; y++)\{\n        wire_ref_sample = ppos(x,y);\n        if (wire_ref_sample.w != 0.0f && pos.x!=x && pos.y != y) \{ \n          plex_position = float3(wire_ref_sample.x,wire_ref_sample.y,wire_ref_sample.z)*(zoom);\n          float xd = plex_position.x - vWorld.x;\n          float yd = plex_position.y - vWorld.y;\n          float zd = plex_position.z - vWorld.z;\n          float plex_dist = sqrt(xd*xd + yd*yd + zd*zd);\n          if (plex_dist<_maxPlexDistance)\{\n            plex_count = min(10,plex_count+1); //Add one to the count\n            for( int h = 0; h < plex_count+1 ; h++) \{ //Loop thought all the points. If the distance is shorter then insert it into the array and push the rest of the array down\n              if (plex_dist < plexlist\[h].w) \{                  \n                for( int i = plex_count+1; i > h ; i--) \{\n                  plexlist\[i] = plexlist\[i-1];\n                  plexlistXY\[i] = plexlistXY\[i-1];\n                \}\n                plexlist\[h] = float4(plex_position.x,plex_position.y,plex_position.z,plex_dist);\n                plexlistXY\[h] = int2(x,y);\n                break;        \n              \}\n            \}\n          \} \n        \}\n      \}\n    \}\n  \}\n  else\{ //Used for standard connection types\n    float4 temp_pos;\n    bool insideX = !(Vformat.x < pos.x+1);\n    bool insideY = !(Vformat.y < pos.y+1);\n\n\n    if (!_plexLinedefAUX)\{\n      temp_pos = normals(pos.x,pos.y);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,vWorld+plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    if ( insideX && !_plexLinedefX) \{\n      temp_pos = ppos(pos.x+1,pos.y );\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && !_plexLinedefX) \{\n      temp_pos = ppos(0,pos.y);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    if ( insideY && !_plexLinedefY) \{\n      temp_pos = ppos(pos.x,pos.y+1);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\}                          \n    \}\n    else if ( _plexConnectY  && !_plexLinedefY) \{\n      temp_pos = ppos(pos.x,0);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    //_plexConnect\n    if ( insideX && insideY && !_plexLinedefXY) \{              \n      temp_pos = ppos(pos.x+1,pos.y+1);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && _plexConnectY && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && insideY && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectY && insideX && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n  \}   \n\n  //now that all the connections have been sorted by distance then we connect the dots.\n  for( int x = 0; x < min(_maxPlexConnections,plex_count) ; x++)\{\n    plex_position = float3(plexlist\[x].x,plexlist\[x].y,plexlist\[x].z);\n    plex_dist = plexlist\[x].w;\n\n\n    float plex_distribution = 1.0f-((plexlist\[x].w-plexlist\[0].w)/((plexlist\[min(_maxPlexConnections,plex_count)].w-plexlist\[0].w)+0.00001f)); //Where does it lie between the best and the worst distance?\n    //plexlistXY\n\n    float4 plex_col = float4(pow(1.0f-(plex_dist/_maxPlexDistance),1.0f/_plex_gamma))*float4(plex_distribution); //This one is quite cool aswell, but does leave the center ones a bit too focused \n    float4 plex_colorA = src(pos.x,pos.y);\n    float4 plex_colorB = src( plexlistXY\[x].x,plexlistXY\[x].y);\n    plex_col *= 0.1f;\n\n    computePixelCoordinates(plex_position, pRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1]);\n    if (dst.bounds.inside(int(vRaster.x),int(vRaster.y)) || dst.bounds.inside(int(pRaster.x),int(pRaster.y)))\{\n        DrawLine(vRaster,pRaster,(plex_colorA*plex_col)*_lineInMultiplier,(plex_colorB*plex_col)*_lineOutMultiplier);\n    \}\n  \}\n\}\n\nvoid wire_connection(float3 p_source,float3 p_target, float4 (&p_plexlist)\[11], int2 (&p_plexlistXY)\[11],int &p_plexcount,int2 position) \{\n  float xd = p_target.x - p_source.x;\n  float yd = p_target.y - p_source.y;\n  float zd = p_target.z - p_source.z;\n  float plex_dist = sqrt(xd*xd + yd*yd + zd*zd);\n  if (plex_dist<_maxPlexDistance)\{\n    p_plexcount = min(11,p_plexcount+1); //Add one to the count\n    for( int h = 0; h < p_plexcount+1 ; h++) \{ //Loop thought all the points. If the distance is shorter then insert it into the array and push the rest of the array down\n      if (plex_dist < p_plexlist\[h].w) \{                  \n        for( int i = p_plexcount+1; i > h ; i--) \{\n          p_plexlist\[i] = p_plexlist\[i-1];\n          p_plexlistXY\[i] = p_plexlistXY\[i-1];\n        \}\n        p_plexlist\[h] = float4(p_target.x,p_target.y,p_target.z,plex_dist);\n        p_plexlistXY\[h] = int2(position.x,position.y);\n        break;        \n      \}\n    \}  \n  \}\n\}\n//-------END OF WIRE RENDER FUNCTIONS---------\n\n\n\n\n//-------------------------------\n//-------BOKEH FUNCTIONS---------\n//thanks to: http://devlog-martinsh.blogspot.dk/2011/11/glsl-depth-of-field-with-bokeh-v21.html\nfloat2 rand(float2 coord) //generating noise/pattern texture for dithering\n\{\n  float noiseX = ((Frac(1.0-coord.x*(WHformat\[0]/2.0))*0.25)+(Frac(coord.y*(WHformat\[1]/2.0))*0.75))*2.0-1.0;\n  float noiseY = ((Frac(1.0-coord.x*(WHformat\[0]/2.0))*0.75)+(Frac(coord.y*(WHformat\[1]/2.0))*0.25))*2.0-1.0;\n  noiseX = clamp(Frac(sin(dot(coord ,float2(12.9898f,78.233f))) * 43758.5453f),0.0f,1.0f)*2.0f-1.0f;\n  noiseY = clamp(Frac(sin(dot(coord ,float2(12.9898f,78.233f)*2.0f)) * 43758.5453f),0.0f,1.0f)*2.0-1.0f;\n  return float2(noiseX,noiseY);\n\}\n//-------------------------------------\n// Bokeh\n//-------------------------------------\nvoid Bokeh(float3 pos,float4 color)\{\n  float blur = 0.0;\n  blur = clamp((fabs(pos.z - focalDepth)/_depthOfField)*100.0f,-_maxDofSize,_maxDofSize);\n  \n  float w = (1.0/WHformat.x)*blur;//+noise.x;\n  float h = (1.0/(WHformat.x*dof_aspect))*blur;//+noise.y;\n  float3 v3_col = float3(color.x,color.y,color.z);\n  int ringsamples;\n  float s = 1.0;  \n\n  for (int i = 1; i <= _dof_rings; i += 1)\n  \{   \n    ringsamples = i * _dof_samples; \n    for (int j = 0 ; j < ringsamples ; j += 1)  \n    \{ \n      s += (1.0f*mix(1.0f,(float(i))/(float(_dof_rings)),dof_bias)*1.0f); //No need to do this in the loop\n    \}\n  \}\n\n  for (int i = 1; i <= _dof_rings; i += 1)\n  \{   \n    ringsamples = i * _dof_samples;\n     \n    for (int j = 0 ; j < ringsamples ; j += 1)   \n    \{\n      float step = PI*2.0 / float(ringsamples);\n      float pw = (cos(float(j)*step)*(float(i)/_dof_rings));\n      float ph = (sin(float(j)*step)*(float(i)/_dof_rings));\n      float p = 1.0;\n\n      float posx = pos.x+((pw*w)*blur);\n      float posy = pos.y+((ph*h)*blur);\n\n\n      float3 lumcoeff = float3(0.299,0.587,0.114);\n      float lum = dot(v3_col, lumcoeff);\n      float thresh = max((lum-dof_threshold)*dof_gain, 0.0f);\n      v3_col+mix(float3(0.0),v3_col,thresh*blur);\n\n      float3 col = (v3_col*mix(1.0,(float(i))/(float(_dof_rings)),dof_bias)*p)/s; \n      bilinear_Plot(float2(posx,posy),float4(col.x,col.y,col.z,color.w/(_dof_rings*_dof_rings)),1);\n    \}\n  \}\n\}\n//-------END OF BOKEH FUNCTIONS---------\n\n\n\n//-------------------------------------\n// Process\n//-------------------------------------\n  void process(int2 pos) \{\n    float4 _sample = ppos(pos.x,pos.y); //Get the XYZ Coordinates\n    float2 posf = float2(pos.x,pos.y);\n\n    if (_sample.w != 0.0f) \{  //No need to process if there is no data.\n\n      //Convert worldspace coordinates to screenspcace coordinates.\n      vWorld = float3(_sample.x,_sample.y,_sample.z)*(zoom);\n      int ret = computePixelCoordinates(vWorld, vRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1]);\n      if (ret) \{ //Only create points that are visible on screen\n        if (_pointRender)\{\n          point_render(pos,vRaster);\n        \}\n      \} //Pointrender over\n\n      if (_wireRender && _maxPlexConnections>=1) \{\n        if (max(pos.x,pos.y)<=max_line_connections || (_maxPlexType==0))\{ // Don't process more wires than allowed in nearest mode.\n          wire_render(pos);\n        \}\n      \} //WireRender over\n\n      if (_facetRender) \{\n        facet_render(pos,float3(_sample.x,_sample.y,_sample.z));\n      \}  //FacetRender over\n      \n    \}\n  \} //----> process\n\};\n"
  useGPUIfAvailable false
  rebuild ""
  PointRender3D_cam_Matrix {
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
    }
  PointRender3D_focallength {{parent.Camera1.focal}}
  PointRender3D_hapeture {{parent.Camera1.haperture}}
  PointRender3D_format {{Settings_Format.width} {Settings_Format.height}}
  PointRender3D_vertexformat {{parent.InputFormat.box.r-1} {parent.InputFormat.box.t-1}}
  PointRender3D__alphaMultiplier {{parent.AlphaMultiplier}}
  PointRender3D__pointRender {{parent.RenderMode==0}}
  PointRender3D__wireRender {{parent.RenderMode==1}}
  PointRender3D__facetRender {{parent.RenderMode==2}}
  PointRender3D__maxLDistance {{parent.wire_maxdistance}}
  PointRender3D__maxLConnections {{parent.wire_connections}}
  PointRender3D__maxPlexType {{-parent.wire_type}}
  PointRender3D__plexLinedefXY {{!parent.connect_xy}}
  PointRender3D__plexLinedefX {{!parent.connect_x}}
  PointRender3D__plexLinedefY {{!parent.connect_y}}
  PointRender3D__plexLinedefAUX {{!connect_aux}}
  PointRender3D__plexConnectX {{parent.CloseX}}
  PointRender3D__plexConnectY {{parent.CloseY}}
  PointRender3D__L_gamma {{parent.wire_Threshold}}
  "PointRender3D_Enable Depth of Field" {{parent.dof_enable}}
  PointRender3D_samples {{3*(parent.Dof_Quality*parent.Dof_Quality+1)}}
  PointRender3D_rings {{3*(parent.Dof_Quality*parent.Dof_Quality+1)}}
  PointRender3D_focalDepth {{parent.dof_focaldepth}}
  PointRender3D__depthOfField {{parent.dof_dof}}
  PointRender3D__depthMult {{parent.DofMultiplier}}
  PointRender3D__maxDofSize {{parent.dof_maxSize*400}}
  PointRender3D_dof_aspect {{parent.dof_Aspect}}
  PointRender3D_dof_bias {{parent.dof_bias}}
  PointRender3D__flatshading {{parent.facet_flatShading}}
  PointRender3D__backfacing {{parent.facet_backface}}
  PointRender3D__frontfacing {{parent.facet_front}}
  PointRender3D__vertexMode {{parent.renderMode}}
  PointRender3D__depthBuffer {{parent.facet_depth}}
  PointRender3D__texoffset {-0.5 0.5}
  PointRender3D__pointSize 0
  PointRender3D__depthOcclusion {{parent.UseOcclusionMap}}
  PointRender3D__maxLineSteps {{parent.maxSamples}}
  PointRender3D__lineOffset {{parent.lineoffset}}
  PointRender3D__lineInMultiplier {{parent.inGain}}
  PointRender3D__lineOutMultiplier {{parent.outGain}}
  format "1280 720 0 0 1280 720 1 HD_720"
  rebuild_finalise ""
  name BlinkScript1
  selected true
  xpos -27
  ypos 159
 }
 Reformat {
  format {{{Settings_Format.format}}}
  resize none
  center false
  name Reformat1
  xpos -27
  ypos 343
 }
 Group {
  name SoftLook
  xpos -27
  ypos 460
  disable {{!parent.HighlightCompression}}
  addUserKnob {20 User}
  addUserKnob {26 ""}
  addUserKnob {7 Add R 0 4}
  Add {{parent.HighlightCeiling}}
  addUserKnob {7 Offset R 0 4}
  Offset {{parent.Compression}}
 }
  Input {
   inputs 0
   name Input1
   xpos -248
   ypos 500
  }
set N5b5b6740 [stack 0]
  Expression {
   expr0 r/(r+parent.Offset)*parent.Add
   expr1 g/(g+parent.Offset)*parent.Add
   expr2 b/(b+parent.Offset)*parent.Add
   expr3 a/(a+parent.Offset)*parent.Add
   name Expression1
   xpos -339
   ypos 576
  }
push $N5b5b6740
  ShuffleCopy {
   inputs 2
   red red
   green green
   blue blue
   alpha alpha2
   name ShuffleCopy1
   xpos -248
   ypos 576
  }
  Output {
   name Output1
   xpos -248
   ypos 651
  }
 end_group
 TimeBlur {
  divisions {{parent.Samples}}
  shutter {{parent.Shutter}}
  shutteroffset centred
  shuttercustomoffset 0
  name MotionBlur
  xpos -27
  ypos 581
  disable {{1-parent.mb_enable x89 0}}
 }
 ShuffleCopy {
  inputs 2
  in pos
  red red
  green green
  blue blue
  out pos
  name ShuffleCopy1
  xpos -27
  ypos 673
  disable true
 }
 Output {
  name Output1
  xpos -27
  ypos 710
 }
 Input {
  inputs 0
  name InputCamera
  xpos -1129
  ypos 116
  number 1
 }
 Camera2 {
  focal {{parent.FocalLength}}
  haperture {{parent.horizontalApeture}}
  name Camera1
  xpos -1119
  ypos 223
  addUserKnob {20 Ivy}
  addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.toolbox.v1.nodes.docs', fromlist=\['open_docs_name']).open_docs_name('IvyTab')" +STARTLINE}
  addUserKnob {26 divider4 l "" +STARTLINE}
  addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
  _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
  addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
  addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
  addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
  _expressions {{curve}}
  addUserKnob {26 divider0 l "" +STARTLINE}
  addUserKnob {20 dbinfo l "DB Info" n 1}
  dbinfo 0
  addUserKnob {1 twig_dnuuid l "Twig Id"}
  addUserKnob {1 stalk_dnuuid l "Stalk Id"}
  addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
  addUserKnob {1 leaf_dnuuid l "Leaf Id"}
  addUserKnob {26 divider1 l "" +STARTLINE}
  addUserKnob {1 twigtype l "Twig Type"}
  addUserKnob {1 leaf_label l Leaf}
  addUserKnob {1 ivy_version l Version}
  addUserKnob {43 ivy_notes l Notes}
  addUserKnob {26 divider2 l "" +STARTLINE}
  addUserKnob {1 build_label l "Build Label"}
  addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
 }
 Reformat {
  inputs 0
  format "2156 1806 0 0 2156 1806 2 JOYRIDE Working"
  resize none
  center false
  name Settings_Format
  xpos -1404
  ypos 241
 }
push $N48293040
 PositionToPoints2 {
  display textured
  render_mode textured
  P_channel pos
  detail 0.25
  pointSize 0.6
  name PreviewNode
  xpos -22
  ypos 8
  disable {{!parent.Enable3DPreview}}
 }
push $N681f0860
 Reformat {
  type "to box"
  box_width 100
  box_height 100
  box_fixed true
  scale 0.1
  resize none
  filter impulse
  black_outside true
  name Reformat3
  xpos -633
  ypos -1109
  disable {{!wire_type==1}}
 }
push $N53eef370
 Crop {
  box {0 0 {width} {height}}
  reformat true
  crop false
  name InputFormat
  xpos -456
  ypos -402
 }
end_group
TimeOffset {
 time_offset -1182
 time ""
 name TimeOffset5
 selected true
 xpos 8695
 ypos 32626
}
Dot {
 name Dot304
 selected true
 xpos 8729
 ypos 32930
}
FileOut {
 name FileOut4
 tile_color 0xbfbf00ff
 label 2DparticleFX_2
 selected true
 xpos 8695
 ypos 33005
 icon smartgrade.png
 channels rgba
 _destination /jobs
 _stemstatus ""
 file ""
 proxy ""
 fileProxy ""
 views {main}
 first 1001
 last 1400
 pbb true
 smart_grade on
 dw_compression_level 0
 tex_metadata "default metadata and exr/*"
 disable_autolabel_format true
 _defaults "\{'smart_grade': 0, 'compression': 1, 'tile_color': 3216965887, 'pbb': True, 'dw_compression_level': 0, 'label': u'2DparticleFX_2', 'exr_metadata': 2\}"
 _format ""
 _generator "NukeRenderGenerator dnnuke.core.render.v1"
 _ivyVals "\{'variant': None, 'host': None, 'versionNum': '7', 'twigType': 'spider://query@TwigType.one?TwigType.code==2d', 'twigNameTags': \{'subtask': u'precomp', 'task': u'comp', 'label': u'2DparticleFX_2', 'out_dir': u'ELEMENT'\}, 'job': 'STONE', 'stalk': None, 'stalkAttrs': \{'framerange': '1017-1053'\}, 'twig': None, 'stem': 'spider://query@Stem.one?Stem.dnuuid==cfb45239-1375-4623-b0a4-12b2a5fba3d0&Stem.stemname==110_fof_0010&Stem.stemtype==shot'\}"
 _old_filetype exr
 _stalkname E_110_fof_0010_comp_precomp_2DparticleFX_2_v007
 _twigtype 2d
 _wrapper "FileOut dnnuke.nodes.file_out.wrapper"
 beforeRender ""
 beforeFrameRender ""
 afterFrameRender ""
 afterRender ""
 renderProgress ""
 _invert_grade /tools/STONE/ivyasset/110_fof_0010/ivy/grade/GRD_110_fof_0010_neutral_v001/GRD_110_fof_0010_neutral_v001.grade
}
BagAndTagKeep {
 name BagAndTagKeep9
 selected true
 xpos 8695
 ypos 33114
}
Read {
 inputs 0
 file_type exr
 file /jobs/JOYRIDE/hap0850/ELEMENT/E_hap0850_comp_precomp_2DparticleFX_2_v007/2156x1806/E_hap0850_comp_precomp_2DparticleFX_2_v007.####.exr
 localizationPolicy off
 format "2156 1806 0 0 2156 1806 2 JOYRIDE Working"
 proxy_format "640 480 0 0 640 480 1 PC_Video"
 first 1001
 last 1400
 origfirst 1001
 origlast 1400
 origset true
 smartGrade true
 name Read268
 selected true
 xpos 8691
 ypos 33233
 postage_stamp_frame 1200
 addUserKnob {20 Ivy}
 addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.toolbox.v1.nodes.docs', fromlist=\['open_docs_name']).open_docs_name('IvyTab')" +STARTLINE}
 addUserKnob {26 divider4 l "" +STARTLINE}
 addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
 _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
 addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
 addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
 _ivyFile /jobs/JOYRIDE/hap0850/ELEMENT/E_hap0850_comp_precomp_2DparticleFX_2_v007/2156x1806/E_hap0850_comp_precomp_2DparticleFX_2_v007.####.exr
 addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
 _expressions {{curve}}
 addUserKnob {26 divider0 l "" +STARTLINE}
 addUserKnob {20 dbinfo l "DB Info" n 1}
 dbinfo 0
 addUserKnob {1 twig_dnuuid l "Twig Id"}
 twig_dnuuid 776d86dd-5bde-4453-9885-d4e475541d96
 addUserKnob {1 stalk_dnuuid l "Stalk Id"}
 stalk_dnuuid a1971776-3b9e-4e6c-a357-8168962603df
 addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
 twigtype_dnuuid e9f824fa-c932-4c3e-acbd-c612fb5ea846
 addUserKnob {1 leaf_dnuuid l "Leaf Id"}
 leaf_dnuuid b49dc7ed-3066-4993-8567-ab00ce582eb2
 addUserKnob {26 divider1 l "" +STARTLINE}
 addUserKnob {1 twigtype l "Twig Type"}
 twigtype elmr
 addUserKnob {1 leaf_label l Leaf}
 leaf_label main_proxy0
 addUserKnob {1 ivy_version l Version}
 ivy_version 7
 addUserKnob {43 ivy_notes l Notes}
 addUserKnob {26 divider2 l "" +STARTLINE}
 addUserKnob {1 build_label l "Build Label"}
 addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
}
BagAndTagKeep {
 name BagAndTagKeep10
 selected true
 xpos 8691
 ypos 33368
}
push $cut_paste_input
Camera2 {
 translate {5 0.1 0.07756583}
 rotate {0 87.69209641 0}
 name Camera14
 selected true
 xpos 9885
 ypos 32607
 addUserKnob {20 Ivy}
 addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.toolbox.v1.nodes.docs', fromlist=\['open_docs_name']).open_docs_name('IvyTab')" +STARTLINE}
 addUserKnob {26 divider4 l "" +STARTLINE}
 addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
 _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
 addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
 addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
 addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
 _expressions {{curve}}
 addUserKnob {26 divider0 l "" +STARTLINE}
 addUserKnob {20 dbinfo l "DB Info" n 1}
 dbinfo 0
 addUserKnob {1 twig_dnuuid l "Twig Id"}
 addUserKnob {1 stalk_dnuuid l "Stalk Id"}
 addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
 addUserKnob {1 leaf_dnuuid l "Leaf Id"}
 addUserKnob {26 divider1 l "" +STARTLINE}
 addUserKnob {1 twigtype l "Twig Type"}
 addUserKnob {1 leaf_label l Leaf}
 addUserKnob {1 ivy_version l Version}
 addUserKnob {43 ivy_notes l Notes}
 addUserKnob {26 divider2 l "" +STARTLINE}
 addUserKnob {1 build_label l "Build Label"}
 addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
}
Group {
 inputs 0
 name Point_Grid2
 tile_color 0x434343ff
 note_font_color 0x7dadf9ff
 selected true
 xpos 10210
 ypos 32097
 addUserKnob {20 User}
 addUserKnob {26 text l "" +STARTLINE T "Point Grid v1.0\n\nThis node generates a grid.\nAs it is defined in a non-euclidian space, \nmost of the shaders and wire or facet rendering won't work. "}
 addUserKnob {26 ""}
 addUserKnob {41 size_x l "Number of Points" T CONTROLER.size_x}
 addUserKnob {41 size_y l "" -STARTLINE T CONTROLER.size_y}
 addUserKnob {41 size_z l "" -STARTLINE T CONTROLER.size_z}
 addUserKnob {18 Position}
 Position {0 0 0}
 addUserKnob {6 Position_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Position_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Position_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {18 Scale}
 Scale {2 4 2}
 addUserKnob {6 Scale_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Scale_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Scale_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
}
 NoOp {
  inputs 0
  name CONTROLER
  xpos 224
  ypos -62
  addUserKnob {20 User}
  addUserKnob {3 VoxelDensity}
  VoxelDensity {{ceil(pow(size_x*size_y*size_z,1/3))}}
  addUserKnob {3 size_x l "Voxel Grid Size"}
  size_x 140
  addUserKnob {3 size_y l "" -STARTLINE}
  size_y 100
  addUserKnob {3 size_z l "" -STARTLINE}
  size_z 130
 }
 Crop {
  inputs 0
  box {0 0 {ceil(sqrt(pow(parent.CONTROLER.VoxelDensity,3)))} {sqrt(pow(parent.CONTROLER.VoxelDensity,3))}}
  reformat true
  crop false
  name Crop3
  xpos 372
  ypos -108
 }
 BlinkScript {
  recompileCount 9
  ProgramGroup 1
  KernelDescription "2 \"InvertKernel\" iterate pixelWise 21048e0522d3524e03cb582229852f2e33dbe569cd86686b92f460148f8700cf 2 \"src\" Read Point \"dst\" Write Point 1 \"Cube Size\" Int 3 IAAAACAAAAAgAAAAAAAAAA== 1 \"cube_size\" 3 1 0"
  kernelSource "kernel InvertKernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;  \n  Image<eWrite> dst;\n\n  param:\n    int3 cube_size;\n\n  local:\n    \n\n  void define() \{\n    defineParam(cube_size, \"Cube Size\", int3(32,32,32));\n  \}\n\n  void init() \{\n    \n  \}\n\n  void process(int2 pos) \{\n    int t_offset = (pos.x+(pos.y*src.bounds.width()));\n    float4 position;\n    float maxSize = max(max(cube_size.x,cube_size.y),cube_size.z);\n\n    position.x = fmod(t_offset,cube_size.x)/float(cube_size.x-1);\n    position.y = fmod(int(t_offset/cube_size.x),cube_size.y)/float(cube_size.y-1);\n    position.z = fmod(int(t_offset/(cube_size.x*cube_size.y)),cube_size.z)/float(cube_size.z-1);\n    position.w = 1-min(fmod(int(t_offset/(cube_size.x*cube_size.y*cube_size.z)),maxSize),1.0f);\n\n    dst() = float4(position.x*position.w,position.y*position.w,position.z*position.w,position.w);\n   \}\n\};\n\n"
  rebuild ""
  "InvertKernel_Cube Size" {{parent.CONTROLER.size_x} {parent.CONTROLER.size_y} {parent.CONTROLER.size_z}}
  rebuild_finalise ""
  name BlinkScript8
  selected true
  xpos 372
  ypos -79
 }
 Grade {
  add -0.5
  black_clamp false
  name Grade1
  xpos 372
  ypos -47
 }
 Grade {
  white {{parent.Scale.r} {parent.Scale.g} {parent.Scale.b} 0.9}
  add {{parent.Position.r} {parent.Position.g} {parent.Position.b} 0}
  black_clamp false
  name Grade2
  xpos 372
  ypos -26
 }
 Shuffle {
  red white
  green white
  blue white
  black red
  white green
  red2 blue
  green2 alpha
  out2 pos
  name Shuffle1
  xpos 372
  ypos -2
 }
 ModifyMetaData {
  metadata {
   {set pointrender/n_points "\[expr \[value parent.size_x]*\[value parent.size_y] *\[value parent.size_z]]"}
   {set pointrender/gen_type 3}
  }
  name SetMetaData
  xpos 372
  ypos 22
 }
 Grade {
  white {{1/((parent.size_x*parent.size_y*parent.size_z)/200000)}}
  black_clamp false
  name Grade9
  xpos 372
  ypos 46
 }
 Crop {
  box {0 0 {ceil(sqrt(pow(parent.CONTROLER.VoxelDensity,3)))} {sqrt(pow(parent.CONTROLER.VoxelDensity,3))}}
  crop false
  name Crop1
  xpos 372
  ypos 70
 }
 Output {
  name Output1
  xpos 372
  ypos 149
 }
end_group
Group {
 name Fractal2
 tile_color 0x434343ff
 label v003
 note_font_color 0x7dadf9ff
 selected true
 xpos 10210
 ypos 32168
 addUserKnob {20 User t test}
 addUserKnob {26 _1 l "" +STARTLINE T "Point Fractal 1.0\n"}
 addUserKnob {26 devider_noise l "<b><font color=#7DADF9>Noise Settings</font><b>"}
 addUserKnob {6 Noise_Absolute l Absolute t "Negative values in the noise offset is made positive." +STARTLINE}
 addUserKnob {3 Noise_Octaves l Octaves}
 Noise_Octaves 8
 addUserKnob {7 Noise_Gain l Gain}
 Noise_Gain 0.3
 addUserKnob {7 Noise_Lacunarity l Lacunarity R 0 4}
 Noise_Lacunarity 1.18
 addUserKnob {18 Amplitude}
 Amplitude 0.49
 addUserKnob {6 Amplitude_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Amplitude_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Amplitude_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Amplitude_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {3 Itterations}
 Itterations 5
 addUserKnob {26 invis_devider_noise l "" +STARTLINE T " "}
 addUserKnob {26 Devider_Frequency l "<b><font color=#7DADF9>Freq Control</font><b>"}
 addUserKnob {19 Freq_Offset l "General Offset" t "This is like a 3D translation, letting you move the current noise pattern in the X, Y, Z and W (4th dimention)" R 0 10}
 Freq_Offset {0 0 0 0}
 addUserKnob {6 Freq_Offset_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_Offset_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_Offset_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_Offset_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_Offset_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 Freq_GeneralScale l "Genral Scale" t "This lets you control the scale of each individual noise axis."}
 Freq_GeneralScale {1 1 1 1}
 addUserKnob {6 Freq_GeneralScale_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_GeneralScale_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_GeneralScale_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_GeneralScale_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_GeneralScale_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {26 invis_devider_freq l "" +STARTLINE T " "}
 addUserKnob {19 Freq_EvolveLow l "Evolve Low" t "This lets you evolve (auto animate) the noise in a particular direction. The \"Low\" part means that this only affects the low frequencies.\n\nTo avoid a \"scrolling\" effect you can use the 4th dimention to break up the spatial cohearence." R 0 10}
 Freq_EvolveLow {3 0 0 0.5}
 addUserKnob {6 Freq_EvolveLow_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveLow_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveLow_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveLow_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveLow_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleLow_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 Freq_EvolveHigh l "Evolve High" t "This lets you evolve (auto animate) the noise in a particular direction. The \"High\" part means that this only affects the high frequencies.\n\nTo avoid a \"scrolling\" effect you can use the 4th dimention to break up the spatial cohearence."}
 Freq_EvolveHigh {0.9 0 -0.5 1}
 addUserKnob {6 Freq_EvolveHigh_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveHigh_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveHigh_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveHigh_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveHigh_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {26 invis_devider_freq2 l "" +STARTLINE T " "}
 addUserKnob {19 Freq_ScaleLow l "Scale Low" t "This lets you scale the noise in a particular axis. The \"Low\" part means that this only affects the low frequencies."}
 Freq_ScaleLow {3 0.3 2 2}
 addUserKnob {6 Freq_ScaleLow_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleLow_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleLow_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleLow_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleLow_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 Freq_ScaleHigh l "Scale High" t "This lets you scale the noise in a particular axis. The \"High\" part means that this only affects the high frequencies."}
 Freq_ScaleHigh {2 2 2 2}
 addUserKnob {6 Freq_ScaleHigh_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleHigh_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleHigh_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleHigh_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleHigh_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {26 invis_devider_freq3 l "" +STARTLINE T " "}
 addUserKnob {26 Curve l "<b><font color=#7DADF9>Curve Noise</font><b>"}
 addUserKnob {6 CurveNoise_Enable l Enable t "Adds a gamma curve to the noise intensity making noise near the \"Offset\" value more flat. This is a experimental feature." +STARTLINE}
 addUserKnob {6 CurveNoise_Invert l Invert t "Inverts the effect of the curved noise." -STARTLINE}
 addUserKnob {7 CurveGain l "Curve Gain" R -10 10}
 CurveGain 3
 addUserKnob {7 CurveOffset R -2 2}
 addUserKnob {26 gabgen l "" +STARTLINE T "\n"}
 addUserKnob {26 info_mask l "<b><font color=#7DADF9>Mask</font><b>"}
 addUserKnob {41 maskChannelMask l "" t "If a node is connected to the mask input, this will let you mask off the effect of the noise.\nIts recommended that you use the Point_Texture node to ensure a correct aspect and size." -STARTLINE T Merge1.maskChannelMask}
 addUserKnob {41 inject -STARTLINE T Merge1.inject}
 addUserKnob {41 invert_mask l invert -STARTLINE T Merge1.invert_mask}
 addUserKnob {41 fringe -STARTLINE T Merge1.fringe}
 addUserKnob {41 mix T Merge1.mix}
}
 Input {
  inputs 0
  name InputMask
  xpos -714
  ypos 207
  number 1
 }
 Reformat {
  type "to box"
  box_width {{parent.InputFormat.box.r}}
  box_height {{parent.InputFormat.box.t}}
  box_fixed true
  resize distort
  name Reformat2
  xpos -714
  ypos 306
 }
 Shuffle {
  name Shuffle3
  xpos -714
  ypos 330
 }
 Input {
  inputs 0
  name InputData
  xpos -582
  ypos 73
 }
 Dot {
  name Dot1
  xpos -548
  ypos 114
 }
set N548b0e60 [stack 0]
 Shuffle {
  in pos
  name Shuffle1
  xpos -470
  ypos 110
 }
 BlinkScript {
  kernelSourceFile /Users/madshagbarth/Github/Nuke-Private/Blink/PointRender/Modify/Fractal_v06.cpp
  recompileCount 60
  ProgramGroup 1
  KernelDescription "2 \"Noise4D\" iterate pixelWise d54284af3e5573ad197bef9032773e8653de2cad590694fcc9fd5af993e97da3 2 \"src\" Read Point \"dst\" Write Point 17 \"absNoise\" Bool 1 AA== \"curveNoise\" Bool 1 AA== \"curveInvert\" Bool 1 AA== \"curveGain\" Float 1 AACAPw== \"curveOffset\" Float 1 AACAPw== \"Octaves\" Int 1 CgAAAA== \"Gain\" Float 1 AAAAPw== \"Lacunarity\" Float 1 AAAAQA== \"Gamma\" Float 1 AAAAPw== \"amplitude\" Float 3 AAAAPwAAAD8AAAA/AAAAAA== \"itterations\" Int 1 AQAAAA== \"Offset\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"Scale\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"suboffset\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"topoffset\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"subscale\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"topscale\" Float 4 AACAPwAAgD8AAIA/AACAPw== 17 \"absNoise\" 1 1 \"curveNoise\" 1 1 \"curveInvert\" 1 1 \"curveGain\" 1 1 \"curveOffset\" 1 1 \"octaves\" 1 1 \"gain\" 1 1 \"lacunarity\" 1 1 \"gamma\" 1 1 \"amplitude\" 3 1 \"itterations\" 1 1 \"offset\" 4 1 \"scale\" 4 1 \"suboffset\" 4 1 \"topoffset\" 4 1 \"subscale\" 4 1 \"topscale\" 4 1 0"
  kernelSource "//Based on https://github.com/Draradech/csworldgen/blob/master/simplexnoise.cpp\n//Ported by Mads Hagbarth Lund 2014\n\n/* Copyright (c) 2007-2012 Eliot Eshelman\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n\nint fastfloor( const float x ) \{ return x > 0 ? (int) x : (int) x - 1; \}\ninline float raw_noise_4d( const float x, const float y, const float z, const float w ) \n\{\nint simplex\[64]\[4] = \{\n    \{0,1,2,3\},\{0,1,3,2\},\{0,0,0,0\},\{0,2,3,1\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{1,2,3,0\},\n    \{0,2,1,3\},\{0,0,0,0\},\{0,3,1,2\},\{0,3,2,1\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{1,3,2,0\},\n    \{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\n    \{1,2,0,3\},\{0,0,0,0\},\{1,3,0,2\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{2,3,0,1\},\{2,3,1,0\},\n    \{1,0,2,3\},\{1,0,3,2\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{2,0,3,1\},\{0,0,0,0\},\{2,1,3,0\},\n    \{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\n    \{2,0,1,3\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{3,0,1,2\},\{3,0,2,1\},\{0,0,0,0\},\{3,1,2,0\},\n    \{2,1,0,3\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{3,1,0,2\},\{0,0,0,0\},\{3,2,0,1\},\{3,2,1,0\}\n\};\n    int perm\[512] = \{\n        151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,\n        8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,\n        35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,\n        134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,\n        55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208, 89,\n        18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,\n        250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,\n        189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,\n        172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,\n        228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,\n        107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,\n        138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180,\n\n        151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,\n        8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,\n        35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,\n        134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,\n        55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208, 89,\n        18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,\n        250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,\n        189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,\n        172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,\n        228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,\n        107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,\n        138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180\n    \};\n   int grad4\[32]\[4]= \{\n    \{0,1,1,1\},  \{0,1,1,-1\},  \{0,1,-1,1\},  \{0,1,-1,-1\},\n    \{0,-1,1,1\}, \{0,-1,1,-1\}, \{0,-1,-1,1\}, \{0,-1,-1,-1\},\n    \{1,0,1,1\},  \{1,0,1,-1\},  \{1,0,-1,1\},  \{1,0,-1,-1\},\n    \{-1,0,1,1\}, \{-1,0,1,-1\}, \{-1,0,-1,1\}, \{-1,0,-1,-1\},\n    \{1,1,0,1\},  \{1,1,0,-1\},  \{1,-1,0,1\},  \{1,-1,0,-1\},\n    \{-1,1,0,1\}, \{-1,1,0,-1\}, \{-1,-1,0,1\}, \{-1,-1,0,-1\},\n    \{1,1,1,0\},  \{1,1,-1,0\},  \{1,-1,1,0\},  \{1,-1,-1,0\},\n    \{-1,1,1,0\}, \{-1,1,-1,0\}, \{-1,-1,1,0\}, \{-1,-1,-1,0\}\n   \};\n    float F4 = (sqrt(5.0f)-1.0f)/4.0f;\n    float G4 = (5.0f-sqrt(5.0f))/20.0f;\n    float n0, n1, n2, n3, n4;\n    float s = (x + y + z + w) * F4;\n    int i = fastfloor(x + s);\n    int j = fastfloor(y + s);\n    int k = fastfloor(z + s);\n    int l = fastfloor(w + s);\n    float t = (i + j + k + l) * G4;\n    float X0 = i - t;\n    float Y0 = j - t;\n    float Z0 = k - t;\n    float W0 = l - t;\n\n    float x0 = x - X0;\n    float y0 = y - Y0;\n    float z0 = z - Z0;\n    float w0 = w - W0;\n    int c1 = (x0 > y0) ? 32 : 0;\n    int c2 = (x0 > z0) ? 16 : 0;\n    int c3 = (y0 > z0) ? 8 : 0;\n    int c4 = (x0 > w0) ? 4 : 0;\n    int c5 = (y0 > w0) ? 2 : 0;\n    int c6 = (z0 > w0) ? 1 : 0;\n    int c = c1 + c2 + c3 + c4 + c5 + c6;\n\n    int i1, j1, k1, l1;\n    int i2, j2, k2, l2;\n    int i3, j3, k3, l3;\n    i1 = simplex\[c]\[0]>=3 ? 1 : 0;\n    j1 = simplex\[c]\[1]>=3 ? 1 : 0;\n    k1 = simplex\[c]\[2]>=3 ? 1 : 0;\n    l1 = simplex\[c]\[3]>=3 ? 1 : 0;\n    i2 = simplex\[c]\[0]>=2 ? 1 : 0;\n    j2 = simplex\[c]\[1]>=2 ? 1 : 0;\n    k2 = simplex\[c]\[2]>=2 ? 1 : 0;\n    l2 = simplex\[c]\[3]>=2 ? 1 : 0;\n    i3 = simplex\[c]\[0]>=1 ? 1 : 0;\n    j3 = simplex\[c]\[1]>=1 ? 1 : 0;\n    k3 = simplex\[c]\[2]>=1 ? 1 : 0;\n    l3 = simplex\[c]\[3]>=1 ? 1 : 0;\n    float x1 = x0 - i1 + G4;\n    float y1 = y0 - j1 + G4;\n    float z1 = z0 - k1 + G4;\n    float w1 = w0 - l1 + G4;\n    float x2 = x0 - i2 + 2.0*G4;\n    float y2 = y0 - j2 + 2.0*G4;\n    float z2 = z0 - k2 + 2.0*G4;\n    float w2 = w0 - l2 + 2.0*G4;\n    float x3 = x0 - i3 + 3.0*G4;\n    float y3 = y0 - j3 + 3.0*G4;\n    float z3 = z0 - k3 + 3.0*G4;\n    float w3 = w0 - l3 + 3.0*G4;\n    float x4 = x0 - 1.0 + 4.0*G4;\n    float y4 = y0 - 1.0 + 4.0*G4;\n    float z4 = z0 - 1.0 + 4.0*G4;\n    float w4 = w0 - 1.0 + 4.0*G4;\n    int ii = i & 255;\n    int jj = j & 255;\n    int kk = k & 255;\n    int ll = l & 255;\n    int gi0 = perm\[ii+perm\[jj+perm\[kk+perm\[ll]]]] % 32;\n    int gi1 = perm\[ii+i1+perm\[jj+j1+perm\[kk+k1+perm\[ll+l1]]]] % 32;\n    int gi2 = perm\[ii+i2+perm\[jj+j2+perm\[kk+k2+perm\[ll+l2]]]] % 32;\n    int gi3 = perm\[ii+i3+perm\[jj+j3+perm\[kk+k3+perm\[ll+l3]]]] % 32;\n    int gi4 = perm\[ii+1+perm\[jj+1+perm\[kk+1+perm\[ll+1]]]] % 32;\n    float t0 = 0.6 - x0*x0 - y0*y0 - z0*z0 - w0*w0;\n    if(t0<0) n0 = 0.0;\n    else \{\n        t0 *= t0;\n        n0 = t0 * t0 * dot(float4(grad4\[gi0]\[0],grad4\[gi0]\[2],grad4\[gi0]\[3],grad4\[gi0]\[3]), float4(x0, y0, z0, w0));\n    \}\n    float t1 = 0.6 - x1*x1 - y1*y1 - z1*z1 - w1*w1;\n    if(t1<0) n1 = 0.0;\n    else \{\n        t1 *= t1;\n        n1 = t1 * t1 * dot(float4(grad4\[gi1]\[0],grad4\[gi1]\[2],grad4\[gi1]\[3],grad4\[gi1]\[3]), float4(x1, y1, z1, w1));\n    \}\n    float t2 = 0.6 - x2*x2 - y2*y2 - z2*z2 - w2*w2;\n    if(t2<0) n2 = 0.0;\n    else \{\n        t2 *= t2;\n        n2 = t2 * t2 * dot(float4(grad4\[gi2]\[0],grad4\[gi2]\[2],grad4\[gi2]\[3],grad4\[gi2]\[3]), float4(x2, y2, z2, w2));\n    \}\n    float t3 = 0.6 - x3*x3 - y3*y3 - z3*z3 - w3*w3;\n    if(t3<0) n3 = 0.0;\n    else \{\n        t3 *= t3;\n        n3 = t3 * t3 * dot(float4(grad4\[gi3]\[0],grad4\[gi3]\[2],grad4\[gi3]\[3],grad4\[gi3]\[3]), float4(x3, y3, z3, w3));\n    \}\n    float t4 = 0.6 - x4*x4 - y4*y4 - z4*z4 - w4*w4;\n    if(t4<0) n4 = 0.0;\n    else \{\n        t4 *= t4;\n        n4 = t4 * t4 * dot(float4(grad4\[gi4]\[0],grad4\[gi4]\[2],grad4\[gi4]\[3],grad4\[gi4]\[3]), float4(x4, y4, z4, w4));\n    \}\n    return 27.0 * (n0 + n1 + n2 + n3 + n4);\n\}\n\n\n\n\nkernel Noise4D : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n  Image<eWrite, eAccessPoint> dst;\nparam:\n    bool absNoise;\n    bool curveNoise;\n    bool curveInvert;\n    float curveGain;\n    float curveOffset;\n    int octaves;\n    float gain;\n    float lacunarity;\n    float gamma;\n    float3 amplitude;\n    int itterations;\n    float4 offset;\n    float4 scale;\n    float4 suboffset;\n    float4 topoffset;\n    float4 subscale;\n    float4 topscale;\n\n\n  void define() \{\n        defineParam (absNoise, \"absNoise\", false);    \n        defineParam (curveNoise, \"curveNoise\", false);    \n        defineParam (curveInvert, \"curveInvert\", false);   \n        defineParam (curveGain, \"curveGain\", 1.0f);\n        defineParam (curveOffset, \"curveOffset\", 1.0f);\n        defineParam (octaves, \"Octaves\", 10);\n        defineParam (gain, \"Gain\", 0.5f);\n        defineParam (lacunarity, \"Lacunarity\", 2.0f);\n        defineParam (gamma, \"Gamma\", 0.5f);\n        defineParam (amplitude, \"amplitude\", float3(0.5f));\n        defineParam (itterations, \"itterations\", 1);\n        defineParam(offset, \"Offset\", float4(0.0f, 0.0f, 0.0f,0.0f));\n        defineParam(scale, \"Scale\", float4(1.0f, 1.0f, 1.0f,1.0f));\n        defineParam(suboffset, \"suboffset\", float4(1.0f, 1.0f, 1.0f,1.0f));\n        defineParam(topoffset, \"topoffset\", float4(1.0f, 1.0f, 1.0f,1.0f));\n        defineParam(subscale, \"subscale\", float4(1.0f, 1.0f, 1.0f,1.0f));\n        defineParam(topscale, \"topscale\", float4(1.0f, 1.0f, 1.0f,1.0f));        \n  \}\n\nfloat octave_noise_4d( const float octaves, const float persistence, const float scale, const float x, const float y, const float z, const float w ) \n\{\n    float total = 0.0f;\n    float current;\n    float last = 1.0f;\n    float frequency = scale;\n    float amplitude = 1.0f;\n    float maxAmplitude = 0.0f;\n    float4 Tempoffset;\n    float4 Tempscale;\n\n\n    for( int i=0; i < octaves; i++ ) \{\n\n        /*\n        if (i == 0) \{\n            total += (float)raw_noise_4d( (x+suboffset.x) * frequency, (y+suboffset.y) * frequency, (z+suboffset.z) * frequency, (w+suboffset.w) * frequency ) * amplitude;\n        \}\n        else if (i == octaves-1) \{\n            total += (float)raw_noise_4d( (x+topoffset.x) * frequency, (y+topoffset.y) * frequency, (z+topoffset.z) * frequency, (w+topoffset.w) * frequency ) * amplitude;\n        \}\n        else \{\n            total += (float)raw_noise_4d( x * frequency, y * frequency, z * frequency, w * frequency ) * amplitude;\n        \}\n        */\n\n\n        Tempscale = (topscale * (i/(octaves-1.0f)))+(subscale * (1-(i/(octaves-1.0f))));       \n        Tempoffset = (topoffset * (i/(octaves-1.0f)))+(suboffset * (1-(i/(octaves-1.0f))));\n        current = (float)raw_noise_4d(   ((x*Tempscale.x)+Tempoffset.x) * frequency, \n                                        ((y*Tempscale.y)+Tempoffset.y) * frequency, \n                                        ((z*Tempscale.z)+Tempoffset.z) * frequency, \n                                        ((w*Tempscale.w)+Tempoffset.w) * frequency \n                                        ) * amplitude;\n        if (i == 0 && curveNoise)\{\n            if (curveInvert)\{\n                last = 0.5f-current;  \n            \}\n            else\{\n                last = current;  \n            \}\n               \n        \}\n        current = curveNoise?current*((last+curveOffset)*curveGain):current;\n        total += absNoise?fabs(current):current;\n        frequency *= 2.0f;\n        maxAmplitude += amplitude;\n        amplitude *= persistence;\n\n    \}\n    return float(total / maxAmplitude);\n\}\n\n\n\n\n  void process() \{\n    float4 srcSample = float4(src(0),src(1),src(2),src(3));\n    float sampleR,sampleG,sampleB;\n    for( int i=0; i < itterations; i++ ) \{\n        sampleR = (float)octave_noise_4d(float(octaves), gain, lacunarity, ( srcSample.x * scale.x ) + offset.x, ( srcSample.y * scale.y ) + offset.y,  ( srcSample.z * scale.z ) + offset.z, ( srcSample.w * scale.w ) + offset.w) * amplitude.x;\n        sampleG = (float)octave_noise_4d(float(octaves), gain, lacunarity, ( srcSample.x * scale.x ) + offset.x, ( srcSample.y * scale.y ) + offset.y,  ( srcSample.z * scale.z ) + offset.z, ( srcSample.w * scale.w ) + offset.w - 100.0f) * amplitude.y;\n        sampleB = (float)octave_noise_4d(float(octaves), gain, lacunarity, ( srcSample.x * scale.x ) + offset.x, ( srcSample.y * scale.y ) + offset.y,  ( srcSample.z * scale.z ) + offset.z, ( srcSample.w * scale.w ) + offset.w + 200.0f) * amplitude.z;\n        srcSample = float4(srcSample.x+sampleR,srcSample.y+sampleG,srcSample.z+sampleB,srcSample.w);\n    \}\n    dst() = float4(srcSample.x,srcSample.y,srcSample.z,1.0f);\n\}\n\};"
  rebuild ""
  Noise4D_curveNoise {{parent.CurveNoise_Enable}}
  Noise4D_curveInvert {{parent.CurveNoise_Invert}}
  Noise4D_curveGain {{parent.CurveGain}}
  Noise4D_curveOffset {{parent.CurveOffset}}
  Noise4D_Octaves {{parent.Noise_Octaves}}
  Noise4D_Gain {{parent.Noise_Gain}}
  Noise4D_Lacunarity {{parent.Noise_Lacunarity}}
  Noise4D_Gamma 0.79
  Noise4D_amplitude {{parent.Amplitude.r} {parent.Amplitude.g} {parent.Amplitude.b}}
  Noise4D_itterations {{parent.Itterations}}
  Noise4D_Offset {{parent.Freq_Offset} {parent.Freq_Offset} {parent.Freq_Offset} {parent.Freq_Offset}}
  Noise4D_Scale {{parent.Freq_GeneralScale} {parent.Freq_GeneralScale} {parent.Freq_GeneralScale} {parent.Freq_GeneralScale}}
  Noise4D_suboffset {{(frame*parent.Freq_EvolveLow.r)/50} {(frame*parent.Freq_EvolveLow.g)/50} {(frame*parent.Freq_EvolveLow.b)/50} {(frame*parent.Freq_EvolveLow.a)/50}}
  Noise4D_topoffset {{(frame*parent.Freq_EvolveHigh.r)/10} {(frame*parent.Freq_EvolveHigh.g)/10} {(frame*parent.Freq_EvolveHigh.b)/10} {(frame*parent.Freq_EvolveHigh.a)/10}}
  Noise4D_subscale {{parent.Freq_ScaleLow} {parent.Freq_ScaleLow} {parent.Freq_ScaleLow} {parent.Freq_ScaleLow}}
  Noise4D_topscale {{parent.Freq_ScaleHigh} {parent.Freq_ScaleHigh} {parent.Freq_ScaleHigh} {parent.Freq_ScaleHigh}}
  rebuild_finalise ""
  name Noise4D1
  selected true
  xpos -470
  ypos 177
 }
 Expression {
  expr0 abs(r)
  expr1 abs(g)
  expr2 abs(b)
  name Expression2
  xpos -470
  ypos 259
  disable {{!parent.Noise_Absolute}}
 }
 Shuffle {
  out pos
  name Shuffle2
  xpos -470
  ypos 330
 }
push $N548b0e60
 Merge2 {
  inputs 2+1
  operation copy
  bbox B
  Achannels {pos.red pos.green pos.blue -pos.alpha}
  Bchannels {pos.red pos.green pos.blue -pos.alpha}
  output {pos.red pos.green pos.blue -pos.alpha}
  maskChannelMask -rgba.alpha
  name Merge1
  xpos -582
  ypos 326
 }
 Output {
  name Output1
  xpos -582
  ypos 497
 }
push $N548b0e60
 Crop {
  box {0 0 {width} {height}}
  reformat true
  crop false
  name InputFormat
  xpos -713
  ypos 111
 }
end_group
set N580991e0 [stack 0]
Dot {
 name Dot305
 selected true
 xpos 10117
 ypos 32178
}
push $N580991e0
Dot {
 name Dot306
 selected true
 xpos 10244
 ypos 32316
}
Group {
 inputs 2
 name Point_OffsetShader2
 tile_color 0x434343ff
 note_font_color 0x55ffffff
 selected true
 xpos 10083
 ypos 32312
 addUserKnob {20 User}
 addUserKnob {26 info l "" +STARTLINE T "Point Offset Shader v1.0\n\nCalcualtes the distance between 2 point sets.\nThis can for example be used to see the difference between the original generator\nand the modified one."}
 addUserKnob {26 devider_general l "<b><font color=#70EE70>General</font><b>"}
 addUserKnob {7 Gain}
 Gain 3
 addUserKnob {7 Offset R -0.5 0.5}
 Offset -0.1
 addUserKnob {6 Absolute +STARTLINE}
 Absolute true
 addUserKnob {6 Reverse +STARTLINE}
}
 BackdropNode {
  inputs 0
  name BackdropNode1
  tile_color 0x388e8e00
  label Offset
  note_font_size 42
  xpos -591
  ypos 304
  bdwidth 224
  bdheight 161
 }
 Input {
  inputs 0
  name Input2
  xpos -438
  ypos 40
  number 1
 }
 Shuffle {
  in pos
  name Shuffle1
  xpos -438
  ypos 120
 }
 Dot {
  name Dot4
  xpos -404
  ypos 285
 }
 Dot {
  name Dot1
  xpos -404
  ypos 392
 }
 Input {
  inputs 0
  name Input1
  xpos -580
  ypos 50
 }
 Shuffle {
  in pos
  name Shuffle5
  xpos -580
  ypos 120
 }
 Dot {
  name Dot3
  xpos -546
  ypos 256
 }
 MergeExpression {
  inputs 2
  temp_name0 xd
  temp_expr0 A.red-B.red
  temp_name1 yd
  temp_expr1 A.green-B.green
  temp_name2 zd
  temp_expr2 A.blue-B.blue
  temp_name3 Distance
  temp_expr3 "sqrt(xd*xd + yd*yd + zd*zd)"
  expr0 Distance
  expr1 Distance
  expr2 Distance
  name Distance
  xpos -584
  ypos 388
 }
 Grade {
  add {{parent.Offset}}
  black_clamp false
  name Grade3
  xpos -584
  ypos 412
 }
 Grade {
  white {{parent.Gain}}
  black_clamp {{!parent.Absolute}}
  name Grade1
  xpos -584
  ypos 436
 }
 Expression {
  expr0 abs(r)
  expr1 abs(g)
  expr2 abs(b)
  name Expression1
  xpos -584
  ypos 459
  disable {{!parent.Absolute}}
 }
 Expression {
  expr0 max(0,1-r)
  expr1 max(0,1-r)
  expr2 max(0,1-r)
  name Expression2
  selected true
  xpos -584
  ypos 483
  disable {{!parent.Reverse}}
 }
 Group {
  name SoftLook_NF1
  xpos -584
  ypos 650
  disable true
  addUserKnob {20 User}
  addUserKnob {26 Info l "" +STARTLINE T "SoftLook\nby Mads Hagbarth Lund - 2016"}
  addUserKnob {26 ""}
  addUserKnob {7 Add R 0 4}
  Add 1.14
  addUserKnob {7 Offset R 0 4}
  Offset 0.86
 }
  Input {
   inputs 0
   name Input1
   xpos -248
   ypos 500
  }
set N2aae6450 [stack 0]
  Expression {
   expr0 r/(r+parent.Offset)*parent.Add
   expr1 g/(g+parent.Offset)*parent.Add
   expr2 b/(b+parent.Offset)*parent.Add
   expr3 a/(a+parent.Offset)*parent.Add
   name Expression1
   selected true
   xpos -339
   ypos 576
  }
push $N2aae6450
  ShuffleCopy {
   inputs 2
   red red
   green green
   blue blue
   alpha alpha2
   name ShuffleCopy1
   xpos -248
   ypos 576
  }
  Output {
   name Output1
   xpos -248
   ypos 651
  }
 end_group
 Output {
  name Output1
  xpos -584
  ypos 686
 }
end_group
Grade {
 white 1.3
 multiply {0.6887242198 0.9288096428 1 1}
 gamma {0.2101119161 0.3576882482 1 1}
 name Grade22
 selected true
 xpos 10083
 ypos 32488
}
Group {
 inputs 2
 name Point_Render5
 tile_color 0x434343ff
 note_font_color 0x7dadf9ff
 selected true
 xpos 10083
 ypos 32627
 addUserKnob {20 User l "Point Render" t dd}
 addUserKnob {26 info_header l "" +STARTLINE T "Point Render v1.0"}
 addUserKnob {26 devider_general l "<b><font color=#7DADF9>General</font><b>"}
 addUserKnob {4 RenderMode l "Render Mode" t "Some generators support multiple render modes other than just point rendering. This should be considered a experimental feature, but can be used to great effect.\n\nIn the Render Settings tab you can find more controls relating to Wire and Facet rendering modes.\n\nNote that Facet Render can be slow when really close to a object. " M {"Point Render" "Wire Render" "Facet Render (experimental)" "" "" ""}}
 addUserKnob {7 FocalLength l "Focal Length" t "The point render does not take the focal length from the input camera, so if you want to match it to a camera you should link the focal length from the camera to this." R 0 200}
 FocalLength 20
 addUserKnob {7 horizontalApeture l "Horiz Apeture" R 0 100}
 horizontalApeture 24.576
 addUserKnob {7 AlphaMultiplier l Exposure t "This is a general exposure modifier that lets you adjust the overall brightness of the render." R 0 2}
 AlphaMultiplier 0.15
 addUserKnob {6 UseOcclusionMap l "Use Occlusion Map" t "Enable the Occlusion map input. This lets you use a depth map as a holdout.\n\nNote:\nThe Red channal should contain the depth (absolute distance, not 1/depth)\nThe Alpha channal must be 1 for the areas that you want to holdout." +STARTLINE}
 addUserKnob {26 devider_cc l "<b><font color=#7DADF9>Preview</font><b>"}
 addUserKnob {6 FastPreview l "Fast Preview" t "Reduce the number of points for a quick preview of the final render." +STARTLINE}
 addUserKnob {6 HighlightCompression l "Hilight Compression" t "Compresses the highlights to make it easier to see bright details." +STARTLINE}
 addUserKnob {7 HighlightCeiling l "Highlight Ceiling" t "Adjust the cealing for the highlight compression." R 1 10}
 HighlightCeiling 1.15
 addUserKnob {7 Compression t "The compression amount." -STARTLINE R 0 5}
 Compression 1
 addUserKnob {26 devider_format l "<b><font color=#7DADF9>Format</font><b>"}
 addUserKnob {41 format l "output format" T Settings_Format.format}
 addUserKnob {20 WireRender l "Render Settings"}
 addUserKnob {26 devider_wirerender l "<b><font color=#7DADF9>Wire Rendering</font><b>"}
 addUserKnob {4 wire_type l "Connection Mode" t "*Normal\nConnect lines between the local neigbours of the 2d position map\n\n*Nearest\nConnect lines to the nearest points (in 3D space). This mode is limited to 100x100 points for performence reasons!" M {Normal Nearest "" "" "" "" "" "" "" ""}}
 addUserKnob {26 text l "Normal Mode Wires" T " "}
 addUserKnob {6 connect_x l x t "Connect wires in the (uv) X axis." -STARTLINE}
 connect_x true
 addUserKnob {6 connect_xy l xy t "Connect wires in the (uv) XY axis." -STARTLINE}
 connect_xy true
 addUserKnob {6 connect_y l y t "Connect wires in the (uv) Y axis." -STARTLINE}
 connect_y true
 addUserKnob {6 connect_aux l aux t "If you input a vector map into the Aux input for this node, and enable this option, you will get a wire from each point along that vector." -STARTLINE}
 addUserKnob {7 wire_maxdistance l "Max Distance" t "The maximum distance that the wires connect." R 0 10}
 wire_maxdistance 6
 addUserKnob {7 wire_Threshold l "Distance Threshold" t "Control the max distance threshold" R 0 2}
 wire_Threshold 0.5
 addUserKnob {3 wire_connections l "Max Connections" t "The maximum number of connections (Not Yet Implemented)"}
 wire_connections 4
 addUserKnob {7 maxSamples l "Max Line Samples" t "The maximum length of a line. Once a line is longer than this, it will start break up. \nThis can also be used as a creative effect if you set it low, try setting it to 10 in wire mode to get dotted lines" R 0 10000}
 maxSamples 10000
 addUserKnob {7 lineoffset l "Line Offset" t "Expand or contract the lines."}
 lineoffset 1
 addUserKnob {7 inGain l "In Gain" t "Gain the brightness of the in-point of the lines"}
 inGain 1
 addUserKnob {7 outGain l "Out Gain" t "Gain the brightness of the out-point of the lines" -STARTLINE}
 outGain 1
 addUserKnob {26 devider_facet l "<b><font color=#7DADF9>Facet Rendering</font><b>"}
 addUserKnob {4 renderMode l "Render Mode" t "Pick the desidered render mode." M {Diffuse "Local ST" Normal "Facing Ratio" UV ST "View Normal" "World Position" "" ""}}
 addUserKnob {6 facet_flatShading l "Flat Shading" t "Flat shading" +STARTLINE}
 addUserKnob {6 facet_depth l "Depth Buffer" t "Enable depth sorting to avoid additive surfaces." -STARTLINE}
 addUserKnob {6 facet_front l "Front Face" t "Render front facing facets" +STARTLINE}
 facet_front true
 addUserKnob {6 facet_backface l "Back Face" t "Render backfacing faces" -STARTLINE}
 facet_backface true
 addUserKnob {26 _1 l "<b><font color=#7DADF9>Other</font><b>"}
 addUserKnob {6 CloseX l "Close X" t "On spheres or round objects this closes the loop" +STARTLINE}
 addUserKnob {6 CloseY l "Close Y" t "On spheres or round objects this closes the loop" -STARTLINE}
 addUserKnob {20 Fog_1 l Fog}
 addUserKnob {26 Devider_Fog l "<b><font color=#7DADF9>Fog</font><b>"}
 addUserKnob {6 Fog t "Fog reduces the brightness of poins far from the camera." +STARTLINE}
 addUserKnob {7 FogNear l "Fog Near" R 0 200}
 FogNear 3
 addUserKnob {7 FogFar l "Fog Far" R 0 200}
 FogFar 10
 addUserKnob {7 FogExponent l "Fog Exponent" R 0 8}
 FogExponent 8
 addUserKnob {20 DepthOfField l "Depth of Field"}
 addUserKnob {26 devider_dof l "<b><font color=#7DADF9>Depth Of Field</font><b>"}
 addUserKnob {6 dof_enable l Enable +STARTLINE}
 addUserKnob {7 dof_focaldepth l "Focal Depth" R 0 40}
 dof_focaldepth 5
 addUserKnob {7 dof_dof l "Depth of Field" R 0 10}
 dof_dof 2
 addUserKnob {7 dof_maxSize l "Max Size"}
 dof_maxSize 0.5
 addUserKnob {7 dof_Aspect l "Aspect Ratio"}
 dof_Aspect 1
 addUserKnob {7 dof_bias l Bias R -3 3}
 dof_bias -0.2
 addUserKnob {4 Dof_Quality l Quality M {Low Medium High Extreme}}
 addUserKnob {20 MotionBlur}
 addUserKnob {26 devider_MotionBlur l "<b><font color=#7DADF9>Motion Blur</font><b>"}
 addUserKnob {6 mb_enable l Enable +STARTLINE}
 mb_enable true
 addUserKnob {6 Fast l "Fast (Interpolated)" -STARTLINE}
 Fast true
 addUserKnob {3 Samples}
 Samples 4
 addUserKnob {7 Shutter R 0 2}
 Shutter 0.5
 addUserKnob {4 pulldown l "Shutter Offset" M {Centered Start End ""}}
 addUserKnob {20 preview_3d l "3D Preview"}
 addUserKnob {6 Enable3DPreview l "Enable 3D Preview" t "Display a preview of the points in the Nuke 3D view." +STARTLINE}
 addUserKnob {41 pointSize l "point size" T PreviewNode.pointSize}
 addUserKnob {41 detail l "point detail" T PreviewNode.detail}
}
 BackdropNode {
  inputs 0
  name BackdropNode1
  tile_color 0x388e8e00
  label "Output Format Manager"
  note_font_size 22
  xpos -1491
  ypos 149
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode10
  tile_color 0x388e8e00
  label "AUX Input"
  note_font_size 22
  xpos -385
  ypos 178
  bdwidth 207
  bdheight 178
 }
 BackdropNode {
  inputs 0
  name BackdropNode11
  tile_color 0x388e8e00
  label "Point Render"
  note_font_size 22
  xpos -96
  ypos 99
  bdwidth 198
  bdheight 135
 }
 BackdropNode {
  inputs 0
  name BackdropNode12
  tile_color 0x388e8e00
  label "Normal Generator\nFor Vertex Normals"
  note_font_size 22
  xpos -616
  ypos 243
  bdwidth 191
  bdheight 122
 }
 BackdropNode {
  inputs 0
  name BackdropNode13
  tile_color 0x388e8e00
  label "Ensure output format"
  note_font_size 22
  xpos -622
  ypos -41
  bdwidth 198
  bdheight 135
 }
 BackdropNode {
  inputs 0
  name BackdropNode14
  tile_color 0x388e8e00
  label "Motion Blur"
  note_font_size 22
  xpos -85
  ypos 526
  bdwidth 193
  bdheight 91
 }
 BackdropNode {
  inputs 0
  name BackdropNode15
  tile_color 0x388e8e00
  label "Soft Preview"
  note_font_size 22
  xpos -83
  ypos 414
  bdwidth 191
  bdheight 94
 }
 BackdropNode {
  inputs 0
  name BackdropNode16
  tile_color 0x388e8e00
  label "Final format"
  note_font_size 22
  xpos -84
  ypos 295
  bdwidth 192
  bdheight 95
 }
 BackdropNode {
  inputs 0
  name BackdropNode17
  tile_color 0x388e8e00
  label "No Clue =)"
  note_font_size 22
  xpos -385
  ypos -41
  bdwidth 160
  bdheight 87
 }
 BackdropNode {
  inputs 0
  name BackdropNode2
  tile_color 0x388e8e00
  label Motionblur
  note_font_size 22
  xpos -672
  ypos -781
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode3
  tile_color 0x388e8e00
  label "Fast Preview"
  note_font_size 22
  xpos -669
  ypos -971
  bdwidth 254
  bdheight 138
 }
 BackdropNode {
  inputs 0
  name BackdropNode4
  tile_color 0x388e8e00
  label "Nearest Wire Mode Clamp"
  note_font_size 22
  xpos -666
  ypos -1184
  bdwidth 253
  bdheight 111
 }
 BackdropNode {
  inputs 0
  name BackdropNode5
  tile_color 0x388e8e00
  label Occlution
  note_font_size 22
  xpos 208
  ypos 27
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode6
  tile_color 0x388e8e00
  label "Input Camera Container"
  note_font_size 22
  xpos -1215
  ypos 148
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode7
  tile_color 0x388e8e00
  label "3D Preview"
  note_font_size 22
  xpos -88
  ypos -45
  bdwidth 207
  bdheight 102
 }
 BackdropNode {
  inputs 0
  name BackdropNode8
  tile_color 0x388e8e00
  label "Input Format Manager"
  note_font_size 22
  xpos -526
  ypos -459
  bdwidth 208
  bdheight 97
 }
 BackdropNode {
  inputs 0
  name BackdropNode9
  tile_color 0x388e8e00
  label FOG
  note_font_size 22
  xpos -602
  ypos -253
  bdwidth 370
  bdheight 152
 }
 Input {
  inputs 0
  name InputPointData
  xpos -584
  ypos -1321
 }
 Dot {
  name Dot4
  xpos -550
  ypos -1234
 }
set N541f9070 [stack 0]
 Reformat {
  type "to box"
  box_width 100
  box_height 100
  box_fixed true
  scale 0.1
  resize fill
  filter impulse
  black_outside true
  name Reformat5
  xpos -584
  ypos -906
  disable {{!parent.FastPreview==1}}
 }
 Grade {
  white 10
  name Grade2
  xpos -584
  ypos -874
  disable {{!parent.FastPreview}}
 }
 Dot {
  name Dot2
  xpos -550
  ypos -712
 }
set N549968e0 [stack 0]
 Group {
  name FrameHold3
  tile_color 0xb0a45dff
  label "(frame \[value first_frames])"
  xpos -501
  ypos -719
  disable {{1-parent.mb_enable}}
  addUserKnob {20 User}
  addUserKnob {3 first_frames l "first frame"}
  first_frames {{frame+1}}
  addUserKnob {41 increment T FrameHold2.increment}
  addUserKnob {22 SetCurrentFrame l "Set This Frame" T "nuke.thisNode()\[\"first_frames\"].setValue(nuke.frame())" +STARTLINE}
 }
  Input {
   inputs 0
   name Input1
   xpos -7
   ypos -154
  }
  FrameHold {
   first_frame {{parent.knob.first_frames}}
   name FrameHold2
   xpos -7
   ypos -114
  }
  Output {
   name Output1
   xpos -7
   ypos -14
  }
 end_group
 Dot {
  name Dot6
  xpos -467
  ypos -659
 }
push $N549968e0
 Group {
  name FrameHold2
  tile_color 0xb0a45dff
  label "(frame \[value first_frames])"
  xpos -660
  ypos -719
  disable {{1-parent.mb_enable}}
  addUserKnob {20 User}
  addUserKnob {3 first_frames l "first frame"}
  first_frames {{frame}}
  addUserKnob {41 increment T FrameHold2.increment}
  addUserKnob {22 SetCurrentFrame l "Set This Frame" T "nuke.thisNode()\[\"first_frames\"].setValue(nuke.frame())" +STARTLINE}
 }
  Input {
   inputs 0
   name Input1
   xpos -7
   ypos -154
  }
  FrameHold {
   first_frame {{parent.knob.first_frames}}
   name FrameHold2
   xpos -7
   ypos -114
  }
  Output {
   name Output1
   xpos -7
   ypos -14
  }
 end_group
 Dot {
  name Dot5
  xpos -626
  ypos -659
 }
 Dissolve {
  inputs 2
  which {{frame-floor(frame)}}
  name Dissolve1
  xpos -582
  ypos -666
  disable {{1-parent.mb_enable}}
 }
push $N549968e0
 Switch {
  inputs 2
  which {{parent.Fast}}
  name Switch2
  xpos -582
  ypos -619
 }
 Dot {
  name DataFetch
  label "data fetch\t"
  note_font_color 0xff21ff
  xpos -550
  ypos -513
  addUserKnob {20 User}
  addUserKnob {3 n_particles l "Number of Particles"}
  n_particles {{"\[metadata pointrender/n_points]"}}
  addUserKnob {3 gentype l "Type Of Generator"}
  gentype {{"\[metadata pointrender/gen_type]"}}
  addUserKnob {26 info l "" -STARTLINE T "0 = unknown, 1 = Card, 2 = Sphere, 3 = Grid"}
 }
set N54b96ea0 [stack 0]
 Dot {
  name Dot3
  xpos -635
  ypos -513
 }
 Dot {
  name Dot1
  xpos -635
  ypos 676
 }
 Input {
  inputs 0
  name InputOcclution
  xpos 238
  ypos 75
  number 2
 }
 Constant {
  inputs 0
  channels rgb
  color 1
  name Empty
  xpos 371
  ypos 139
 }
 Switch {
  inputs 2
  which {{parent.UseOcclusionMap}}
  name Switch1
  xpos 238
  ypos 163
 }
 Input {
  inputs 0
  name Aux
  xpos -324
  ypos 214
  number 3
 }
 Reformat {
  type "to box"
  format "1280 720 0 0 1280 720 1 HD_720"
  box_width {{input.width>Settings_Format.format.width?input.width:Settings_Format.format.width}}
  box_height {{input.height>Settings_Format.format.height?input.height:Settings_Format.format.height}}
  box_fixed true
  resize none
  center false
  filter impulse
  black_outside true
  name Reformat2
  xpos -324
  ypos 238
 }
 Crop {
  box {0 0 {input.width} {input.height}}
  name Crop1
  xpos -324
  ypos 275
 }
push $N54b96ea0
 Shuffle {
  in pos
  name Shuffle1
  xpos -584
  ypos -192
 }
set N560a24f0 [stack 0]
 Reformat {
  type "to box"
  format "1280 720 0 0 1280 720 1 HD_720"
  box_width {{input.width>Settings_Format.format.width?input.width:Settings_Format.format.width}}
  box_height {{input.height>Settings_Format.format.height?input.height:Settings_Format.format.height}}
  box_fixed true
  resize none
  center false
  filter impulse
  black_outside true
  name Reformat4
  xpos -584
  ypos 18
 }
 Crop {
  box {0 0 {input.width} {input.height}}
  name Crop2
  xpos -584
  ypos 48
 }
 Dot {
  name Dot8
  xpos -550
  ypos 166
 }
set N5a118d70 [stack 0]
 Group {
  name Point_Normal2
  tile_color 0x434343ff
  note_font_color 0x55ffffff
  xpos -584
  ypos 311
  disable {{!(renderMode==2&&RenderMode==2)}}
  addUserKnob {20 User}
  addUserKnob {26 info l "" +STARTLINE T "Point Normal v1.0"}
  addUserKnob {26 devider_general l "<b><font color=#7DADF9>General</font><b>"}
  addUserKnob {26 info_1 l "" +STARTLINE T "well, not much to do here =)"}
 }
  Input {
   inputs 0
   name Input1
   xpos 389
   ypos 207
  }
  Shuffle {
   in pos
   name Shuffle1
   xpos 389
   ypos 294
  }
  BlinkScript {
   kernelSourceFile /Users/madshagbarth/Github/Nuke-Private/Blink/PointRender/Modify/BasicLight.cpp
   recompileCount 69
   ProgramGroup 1
   KernelDescription "2 \"PointRender3D\" iterate pixelWise d5452fe7b684561fcfa5182d0c789025a037cc4fe4474c24e065e3fa53fcd8ce 2 \"ppos\" Read Random \"dst\" Write Point 9 \"cam_Matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== \"focallength\" Float 1 AAA4QQ== \"hapeture\" Float 1 ppvEQQ== \"format\" Int 2 AAgAAAAIAAA= \"Zoom\" Float 1 AACAPw== \"half Lambert\" Bool 1 AQ== \"light Mode\" Int 1 AAAAAA== \"light_position\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"light_color\" Float 3 AACAPwAAgD8AAIA/AAAAAA== 9 \"cam_Matrix\" 16 1 \"cam_Focal\" 1 1 \"cam_Hapeture\" 1 1 \"WHformat\" 2 1 \"zoom\" 1 1 \"halfLambert\" 1 1 \"lightMode\" 1 1 \"lightPos\" 3 1 \"lightcolor\" 3 1 10 \"vRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"pRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"tRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"vWorld\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"canvasWidth\" Float 1 1 AAAAAA== \"canvasHeight\" Float 1 1 AAAAAA== \"matrixData\" Float 1 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cameraToWorld\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"worldToCamera\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"namount\" Float 1 1 AAAAAA=="
   kernelSource "inline float Frac(float a_X)\n\{\n    return a_X-floor(a_X);\n\}\n\ninline float Fmax(float a_X,float b_X,float c_X)\n\{\n    return max(c_X,max(a_X,b_X));\n\}\ninline float Fmin(float a_X,float b_X,float c_X)\n\{\n    return min(c_X,min(a_X,b_X));\n\}\n\ninline float saturate(float _in)\n\{\n    return max(0.0f,min(1.0f,_in));\n\}\n\ninline float3 reflect(float3 incidence,float3 normal)\n\{\n  return incidence - 2.f * dot(incidence, normal) * normal;\n\}\n\n//This function is used to multiply a float3 by a matrix4x4\ninline float3 multVecMatrix( float3 src, float4x4 matrix)\n\{\n    float   x,y,z,w;\n    \n    x = src\[0]*matrix\[0]\[0] + src\[1]*matrix\[1]\[0] +\n    src\[2]*matrix\[2]\[0] + matrix\[3]\[0];\n    y = src\[0]*matrix\[0]\[1] + src\[1]*matrix\[1]\[1] +\n    src\[2]*matrix\[2]\[1] + matrix\[3]\[1];\n    z = src\[0]*matrix\[0]\[2] + src\[1]*matrix\[1]\[2] +\n    src\[2]*matrix\[2]\[2] + matrix\[3]\[2];\n    w = src\[0]*matrix\[0]\[3] + src\[1]*matrix\[1]\[3] +\n    src\[2]*matrix\[2]\[3] + matrix\[3]\[3];\n    \n    return float3(x/w, y/w, z/w);\n\}\n\n//This function is used to calculate the screenspace coordinates.\ninline bool computePixelCoordinates( \n    const float3 pWorld, \n    float3 &pRaster, \n    const float4x4 &worldToCamera, \n    const float &canvasWidth, \n    const float &canvasHeight, \n    const int &imageWidth, \n    const int &imageHeight\n) \n\{ \n    float3 pCamera; \n    pCamera = multVecMatrix(pWorld, worldToCamera); \n    float2 pScreen; \n    pScreen.x = pCamera.x / -pCamera.z; \n    pScreen.y = pCamera.y / -pCamera.z; \n    if (fabs(pScreen.x) > canvasWidth || fabs(pScreen.y) > canvasHeight) \n         return false; \n    float2 pNDC; \n    pNDC.x = (pScreen.x + canvasWidth * 0.5f) / canvasWidth; \n    pNDC.y = (pScreen.y + canvasHeight * 0.5f) / canvasHeight; \n    pRaster.x = (pNDC.x * imageWidth); \n    pRaster.y = ((pNDC.y) * imageHeight); \n    pRaster.z = -pCamera.z; \n    if (pRaster.x < 0.0f || pRaster.x > imageWidth || \n       pRaster.y < 0.0f || pRaster.y > imageHeight) \{\n       return false;  \n    \}\n    return true;\n\} \n\n\n\nkernel PointRender3D : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessRandom, eEdgeClamped> ppos;    //The point position map\n  Image<eWrite> dst;                 //the output image\n\n  param: //Parameters available to the user\n    float4x4 cam_Matrix;    //The world matrix of the camera\n    float cam_Focal;        //The focal length of the camera\n    float cam_Hapeture;     //The horizontal apeture of the camera\n    int2 WHformat;          //The format of the output image\n    float zoom;             //A \"post\" zoom function\n    bool halfLambert;\n    int lightMode;\n    float3 lightPos;\n    float3 lightcolor;\n\n\n  local: //Local variables\n    float3 vRaster;\n    float3 pRaster;\n    float3 tRaster;    \n    float3 vWorld;\n    float canvasWidth;\n    float canvasHeight; \n    float matrixData\[4]\[4];\n    float4x4 cameraToWorld;\n    float4x4 worldToCamera;\n    float namount; //dither amount\n\n\n  void define() \{\n    defineParam(cam_Matrix, \"cam_Matrix\", float4x4( 1.0f,0.0f,0.0f,0.0f,\n                                                    0.0f,1.0f,0.0f,0.0f,\n                                                    0.0f,0.0f,1.0f,0.0f,\n                                                    0.0f,0.0f,0.0f,1.0f));\n    defineParam(cam_Focal,      \"focallength\", 11.5f);\n    defineParam(cam_Hapeture,      \"hapeture\", 24.576f);\n    defineParam(WHformat,      \"format\", int2(2048,2048));\n    defineParam(zoom, \"Zoom\", 1.0f);\n    defineParam(halfLambert, \"half Lambert\", true);\n    defineParam(lightMode, \"light Mode\", 0);\n    defineParam(lightPos,      \"light_position\", float3(0,0,0));  \n    defineParam(lightcolor,      \"light_color\", float3(1.0,1.0,1.0)); \n  \}\n\n\n  //The init() function is run before any calls to process().\n  void init() \{\n    canvasWidth = ((cam_Hapeture)/cam_Focal);\n    canvasHeight = ((cam_Hapeture)/cam_Focal)*float(float(WHformat.y)/float(WHformat.x)); \n    float matrixData\[] = \{cam_Matrix\[0]\[0], cam_Matrix\[1]\[0], cam_Matrix\[2]\[0], cam_Matrix\[3]\[0], \n                          cam_Matrix\[0]\[1], cam_Matrix\[1]\[1], cam_Matrix\[2]\[1], cam_Matrix\[3]\[1], \n                          cam_Matrix\[0]\[2], cam_Matrix\[1]\[2], cam_Matrix\[2]\[2], cam_Matrix\[3]\[2], \n                          cam_Matrix\[0]\[3], cam_Matrix\[1]\[3], cam_Matrix\[2]\[3], cam_Matrix\[3]\[3]\};\n    cameraToWorld.setArray(matrixData); //This is a workaround. Due to the buggy matrix implementation, we pass the matrix on from another structure.\n    worldToCamera = cameraToWorld.invert();\n    namount = 0.0001; //dither amount\n  \}\n\n\n\nfloat3 Reconsile3D(float3 _PointPos)\{\n    vWorld = float3(_PointPos.x,_PointPos.y,_PointPos.z)*(zoom);\n    int ret = computePixelCoordinates(vWorld, tRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1]);\n    return tRaster;\n\}\n\n\n\n//-------------------------------------\n// Facet_Render\n//-------------------------------------\n//This function is used to calculate what triangels to draw\nfloat3 facet_render(int2 pos, float3 _vWorld)\{\n\n    float3 screen_pos = Reconsile3D(_vWorld);\n    bool insideX = ppos.bounds.inside(pos.x+1,pos.y );\n    bool insideY = ppos.bounds.inside(pos.x,pos.y-1 );\n    bool insideYtop = ppos.bounds.inside(pos.x,pos.y+1);\n    float2 fpos = float2(pos.x,pos.y);\n    float3 V1_Pos,V2_Pos,V1_wPos,V2_wPos;\n    float4 V0_Sample,V1_Sample,V2_Sample;\n    float3 normal0,normal1,normal2;\n\n    //for area calculation\n    float area;\n    float3 V0,V1,V2;\n    float3 output = float3(0.0f);\n  if (insideX) \{\n    V2_Sample = ppos(pos.x+1,pos.y);\n    V2_wPos = float3(V2_Sample.x,V2_Sample.y,V2_Sample.z);\n    V2_Pos = Reconsile3D(V2_wPos);\n    if (V2_Sample.w != 0.0f) \{ \n\n      if (insideY) \{\n        V1_Sample = ppos(pos.x+1,pos.y-1);\n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (V1_Sample.w != 0.0f) \{ \n            float3 Normal = CalculateVertexNormals(_vWorld,V2_wPos,V1_wPos);\n\n            //Calculate Area for density:\n            V0 = screen_pos;\n            V1 = V1_Pos;\n            V2 = V2_Pos;\n            V0.z = 1.0f / V0.z, V1.z = 1.0f / V1.z, V2.z = 1.0f / V2.z; \n            area = length(V0-V1)+length(V0-V2)+length(V1-V2);\n\n          //write output\n          output +=  float3(Normal.x,Normal.y,Normal.z);\n        \}\n      \}\n      if (insideYtop) \{\n        V1_Sample = ppos(pos.x,pos.y+1);\n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (V1_Sample.w != 0.0f) \{ \n          float3 Normal = CalculateVertexNormals(_vWorld,V1_wPos,V2_wPos);\n\n            //Calculate Area for density:\n            V0 = screen_pos;\n            V1 = V1_Pos;\n            V2 = V2_Pos;\n            V0.z = 1.0f / V0.z, V1.z = 1.0f / V1.z, V2.z = 1.0f / V2.z; \n            area = length(V0-V1)+length(V0-V2)+length(V1-V2);\n\n          output += float3(Normal.x,Normal.y,Normal.z);\n\n        \}\n      \}\n    \}\n  \}\n  return output;\n\}\n\n\n\nfloat3 CalculateSurfaceNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat3 CalculateVertexNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 hitNormal = cross((V1 - V0),(V2 - V0)); \n        return hitNormal;\n\}\n\n\n\n//-------------------------------------\n// Process\n//-------------------------------------\n  void process(int2 pos) \{\n    float3 output = float3(0.0f);\n    float4 _sample = ppos(pos.x,pos.y); //Get the XYZ Coordinates\n    float3 point_pos = float3(_sample.x,_sample.y,_sample.z);\n    if (_sample.w != 0.0f) \{  //No need to process if there is no data.\n      dst() = float4(0.0f);\n      output+=facet_render(pos,float3(_sample.x,_sample.y,_sample.z))*2.0f;\n      _sample = ppos(pos.x-1,pos.y); //Get the XYZ Coordinates\n      output+=facet_render(int2(pos.x-1,pos.y),float3(_sample.x,_sample.y,_sample.z));\n\n      _sample = ppos(pos.x-1,pos.y+1); //Get the XYZ Coordinates\n      output+=facet_render(int2(pos.x-1,pos.y+1),float3(_sample.x,_sample.y,_sample.z));\n\n      _sample = ppos(pos.x,pos.y-1); //Get the XYZ Coordinates\n      output+=facet_render(int2(pos.x,pos.y-1),float3(_sample.x,_sample.y,_sample.z));\n\n      output = normalize(output);\n      float3 normal = -output;\n\n      \n\n\n      dst() = float4(normal.x,normal.y,normal.z,1.0f);\n    \}\n  \} //----> process\n\};\n"
   rebuild ""
   "PointRender3D_half Lambert" false
   "PointRender3D_light Mode" {{parent.LightFalloff}}
   PointRender3D_light_position {{parent.Axis1.translate} {parent.Axis1.translate} {parent.Axis1.translate}}
   PointRender3D_light_color {{parent.LightColor} {parent.LightColor} {parent.LightColor}}
   rebuild_finalise ""
   name BlinkScript1
   xpos 389
   ypos 344
  }
  Grade {
   multiply 0.5
   add 0.5
   black_clamp false
   name Grade1
   xpos 389
   ypos 376
   disable true
  }
  Output {
   name Output1
   xpos 389
   ypos 459
  }
  Axis2 {
   inputs 0
   translate {0.5 0.5 0.5}
   name Axis1
   xpos 661
   ypos 318
   addUserKnob {20 Ivy}
   addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.toolbox.v1.nodes.docs', fromlist=\['open_docs_name']).open_docs_name('IvyTab')" +STARTLINE}
   addUserKnob {26 divider4 l "" +STARTLINE}
   addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
   _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
   addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
   addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
   addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
   _expressions {{curve}}
   addUserKnob {26 divider0 l "" +STARTLINE}
   addUserKnob {20 dbinfo l "DB Info" n 1}
   dbinfo 0
   addUserKnob {1 twig_dnuuid l "Twig Id"}
   addUserKnob {1 stalk_dnuuid l "Stalk Id"}
   addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
   addUserKnob {1 leaf_dnuuid l "Leaf Id"}
   addUserKnob {26 divider1 l "" +STARTLINE}
   addUserKnob {1 twigtype l "Twig Type"}
   addUserKnob {1 leaf_label l Leaf}
   addUserKnob {1 ivy_version l Version}
   addUserKnob {43 ivy_notes l Notes}
   addUserKnob {26 divider2 l "" +STARTLINE}
   addUserKnob {1 build_label l "Build Label"}
   addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
  }
 end_group
 Switch {
  inputs 2
  which {{parent.connect_aux}}
  name Switch3
  xpos -324
  ypos 311
 }
push $N560a24f0
 Expression {
  temp_name0 xd
  temp_expr0 red-Camera1.world_matrix.3
  temp_name1 yd
  temp_expr1 green-Camera1.world_matrix.7
  temp_name2 zd
  temp_expr2 blue-Camera1.world_matrix.11
  temp_name3 Distance
  temp_expr3 "sqrt(xd*xd + yd*yd + zd*zd)"
  expr0 Distance
  expr1 Distance
  expr2 Distance
  expr3 Distance
  name Expression1
  xpos -456
  ypos -192
 }
 Grade {
  channels rgba
  blackpoint {{parent.FogFar}}
  whitepoint {{parent.FogNear}}
  gamma {{1/(parent.FogExponent+0.000000001)}}
  white_clamp true
  name Grade1
  xpos -456
  ypos -168
 }
push $N54b96ea0
 Dot {
  name Dot7
  xpos -307
  ypos -513
 }
 Merge2 {
  inputs 2
  operation multiply
  name Merge1
  xpos -341
  ypos -168
  disable {{!parent.Fog}}
 }
 Shuffle {
  name Shuffle3
  xpos -341
  ypos 8
 }
set N564e1960 [stack 0]
push $N5a118d70
 BlinkScript {
  inputs 4
  kernelSourceFile /Users/madshagbarth/Github/Nuke-Private/Blink/PointRender/Render/3D_PointRender_v15.cpp
  recompileCount 792
  ProgramGroup 1
  KernelDescription "2 \"PointRender3D\" iterate pixelWise e0ecbbf4cba39730471d23bc9f9ec846fcae1bbb869971a11b15641cf6fd5620 5 \"ppos\" Read Random \"src\" Read Random \"normals\" Read Random \"occlusion\" Read Random \"dst\" Write Random 48 \"cam_Matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== \"focallength\" Float 1 AAA4QQ== \"hapeture\" Float 1 ppvEQQ== \"format\" Int 2 AAgAAAAIAAA= \"vertexformat\" Int 2 CgAAAAoAAAA= \"Zoom\" Float 1 AACAPw== \"Filtering Method\" Int 1 AQAAAA== \"_alphaMultiplier\" Float 1 AACAPw== \"_pointRender\" Bool 1 AQ== \"_wireRender\" Bool 1 AQ== \"_facetRender\" Bool 1 AQ== \"_maxLDistance\" Float 1 AACAPw== \"_maxLConnections\" Int 1 AQAAAA== \"_maxPlexType\" Int 1 AAAAAA== \"_plexLinedefXY\" Bool 1 AA== \"_plexLinedefX\" Bool 1 AA== \"_plexLinedefY\" Bool 1 AA== \"_plexLinedefXtoY\" Bool 1 AA== \"_plexLinedefAUX\" Bool 1 AA== \"_plexConnectX\" Bool 1 AA== \"_plexConnectY\" Bool 1 AA== \"_L_gamma\" Float 1 AACAPw== \"Enable Depth of Field\" Bool 1 AA== \"samples\" Int 1 AwAAAA== \"rings\" Int 1 BQAAAA== \"focalDepth\" Float 1 AACAPw== \"_depthOfField\" Float 1 AACAQA== \"_depthMult\" Float 1 zczMPQ== \"_maxDofSize\" Float 1 AAAAQQ== \"dof_aspect\" Float 1 AACAPw== \"dof_threshold\" Float 1 AACAPw== \"dof_gain\" Float 1 AAAAAA== \"dof_bias\" Float 1 AAAAwA== \"dof_fringe\" Float 1 AAAAAA== \"_flatshading\" Bool 1 AQ== \"_backfacing\" Bool 1 AQ== \"_frontfacing\" Bool 1 AQ== \"_vertexMode\" Int 1 AAAAAA== \"_depthBuffer\" Bool 1 AQ== \"_texoffset\" Float 2 AAAAPwAAAD8= \"_pointSize\" Int 1 AQAAAA== \"_gaussigma\" Float 1 AACAPw== \"_depthOcclusion\" Bool 1 AQ== \"depthMultiplier\" Float 1 AACAPw== \"_maxLineSteps\" Float 1 AAB6RQ== \"_lineOffset\" Float 1 AACAPw== \"_lineInMultiplier\" Float 1 AACAPw== \"_lineOutMultiplier\" Float 1 AACAPw== 48 \"cam_Matrix\" 16 1 \"cam_Focal\" 1 1 \"cam_Hapeture\" 1 1 \"WHformat\" 2 1 \"Vformat\" 2 1 \"zoom\" 1 1 \"_filtering\" 1 1 \"_alphaMultiplier\" 1 1 \"_pointRender\" 1 1 \"_wireRender\" 1 1 \"_facetRender\" 1 1 \"_maxPlexDistance\" 1 1 \"_maxPlexConnections\" 1 1 \"_maxPlexType\" 1 1 \"_plexLinedefXY\" 1 1 \"_plexLinedefX\" 1 1 \"_plexLinedefY\" 1 1 \"_plexLinedefXtoY\" 1 1 \"_plexLinedefAUX\" 1 1 \"_plexConnectX\" 1 1 \"_plexConnectY\" 1 1 \"_plex_gamma\" 1 1 \"_dof_enable\" 1 1 \"_dof_samples\" 1 1 \"_dof_rings\" 1 1 \"focalDepth\" 1 1 \"_depthOfField\" 1 1 \"_depthMult\" 1 1 \"_maxDofSize\" 1 1 \"dof_aspect\" 1 1 \"dof_threshold\" 1 1 \"dof_gain\" 1 1 \"dof_bias\" 1 1 \"dof_fringe\" 1 1 \"_flatshading\" 1 1 \"_backfacing\" 1 1 \"_frontfacing\" 1 1 \"_vertexMode\" 1 1 \"_depthBuffer\" 1 1 \"_texoffset\" 2 1 \"_pointSize\" 1 1 \"_gaussigma\" 1 1 \"_depthOcclusion\" 1 1 \"depthMultiplier\" 1 1 \"_maxLineSteps\" 1 1 \"_lineOffset\" 1 1 \"_lineInMultiplier\" 1 1 \"_lineOutMultiplier\" 1 1 10 \"max_line_connections\" Int 1 1 AAAAAA== \"vRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"pRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"tRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"vWorld\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"canvasWidth\" Float 1 1 AAAAAA== \"canvasHeight\" Float 1 1 AAAAAA== \"matrixData\" Float 1 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cameraToWorld\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"worldToCamera\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "//Some basic generic functions.\ninline float Frac(float a_X)\n\{\n    return a_X-floor(a_X);\n\}\n\ninline float3 Cross(float3 A,float3 B)\n\{\n    return float3(A.y*B.z - A.z*B.y,A.z*B.x - A.x*B.z,A.x*B.y - A.y*B.x);\n\}\n\ninline float Fmax(float a_X,float b_X,float c_X)\n\{\n    return max(c_X,max(a_X,b_X));\n\}\ninline float Fmin(float a_X,float b_X,float c_X)\n\{\n    return min(c_X,min(a_X,b_X));\n\}     \n\ninline float3 mix(float3 _X,float3 _Y,float _A)\{\n  return _X*(1.0f-_A)+_Y*_A;\n\}\ninline float mix(float _X,float _Y,float _A)\{\n  return _X*(1.0f-_A)+_Y*_A;\n\}                                                                                              \n\n//This function is used to multiply a float3 by a matrix4x4\ninline float3 multVecMatrix( float3 src, float4x4 matrix)\n\{\n    float   x,y,z,w;\n\n    x = src\[0]*matrix\[0]\[0] + src\[1]*matrix\[1]\[0] +\n    src\[2]*matrix\[2]\[0] + matrix\[3]\[0];\n    y = src\[0]*matrix\[0]\[1] + src\[1]*matrix\[1]\[1] +\n    src\[2]*matrix\[2]\[1] + matrix\[3]\[1];\n    z = src\[0]*matrix\[0]\[2] + src\[1]*matrix\[1]\[2] +\n    src\[2]*matrix\[2]\[2] + matrix\[3]\[2];\n    w = src\[0]*matrix\[0]\[3] + src\[1]*matrix\[1]\[3] +\n    src\[2]*matrix\[2]\[3] + matrix\[3]\[3];\n    \n    return float3(x/w, y/w, z/w);\n\}\n\n//This function is used to calculate the screenspace coordinates.\ninline bool computePixelCoordinates( \n    const float3 pWorld, \n    float3 &pRaster, \n    const float4x4 &worldToCamera, \n    const float &canvasWidth, \n    const float &canvasHeight, \n    const int &imageWidth, \n    const int &imageHeight\n) \n\{ \n    float3 pCamera; \n    pCamera = multVecMatrix(pWorld, worldToCamera); \n    float2 pScreen; \n    pScreen.x = pCamera.x / -pCamera.z; \n    pScreen.y = pCamera.y / -pCamera.z; \n    float2 pNDC; \n    pNDC.x = (pScreen.x + canvasWidth * 0.5f) / canvasWidth; \n    pNDC.y = (pScreen.y + canvasHeight * 0.5f) / canvasHeight; \n    pRaster.x = (pNDC.x * imageWidth); \n    pRaster.y = ((pNDC.y) * imageHeight); \n    pRaster.z = -pCamera.z; \n    if (pRaster.x < 0.0f || pRaster.x > imageWidth || \n       pRaster.y < 0.0f || pRaster.y > imageHeight || pRaster.z < 0.0f) \{\n       return false;  \n    \}\n    return true;\n\} \n\n\nkernel PointRender3D : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessRandom, eEdgeClamped> ppos;    //The point position map\n  Image<eRead, eAccessRandom, eEdgeClamped> src;     //The texture map\n  Image<eRead, eAccessRandom, eEdgeClamped> normals;     //The texture map  \n  Image<eRead, eAccessRandom, eEdgeClamped> occlusion;     //The texture map \n  Image<eWrite, eAccessRandom> dst;                 //the output image\n\n  param: //Parameters available to the user\n    float4x4 cam_Matrix;    //The world matrix of the camera\n    float cam_Focal;        //The focal length of the camera\n    float cam_Hapeture;     //The horizontal apeture of the camera\n    int2 WHformat,Vformat;          //The format of the output image\n    float zoom;             //A \"post\" zoom function\n    int _filtering;        //Filter method\n    float _alphaMultiplier; //Additive multiplier\n    bool _pointRender,_wireRender,_facetRender;\n    float _maxPlexDistance; //Additive multiplier\n    int _maxPlexConnections;\n    int _maxPlexType; // 0==Grid, -1==Nearest\n    bool _plexLinedefXY,_plexLinedefX,_plexLinedefY,_plexLinedefXtoY,_plexLinedefAUX; // Define what connections NOT to include\n    bool _plexConnectX,_plexConnectY; //Connect from the edge of x to 0, or edge of y to 0, usually for spheres\n    float _plex_gamma; //The threshold making shorter paths bright and longer paths dark\n    bool _dof_enable; // Enable DOF\n    int _dof_samples; // How many samples per DOF ring\n    int _dof_rings; // How many rings \n    float focalDepth,_depthOfField,_depthMult,_maxDofSize; //DOF Settings\n    float dof_aspect; //Pixel aspect ratio\n    float dof_threshold;\n    float dof_gain;\n    float dof_bias; //bokeh edge bias\n    float dof_fringe; //bokeh chromatic aberration/fringing\n    bool _flatshading,_backfacing,_frontfacing; //Vertex rendering settings\n    int _vertexMode;  //The rendering output mode, (think AOV)\n    bool _depthBuffer; //Non-additive, only render front most pixel\n    float2 _texoffset;\n    int _pointSize;\n    float _gaussigma;\n    bool _depthOcclusion;\n    float depthMultiplier;\n    float _maxLineSteps; //cap the line length to avoid process lock\n    float _lineOffset; //Alow you to shrink or extend the lines\n    float _lineInMultiplier,_lineOutMultiplier; //Control the brightness of the wires at the tips.\n\n  local: //Local variables\n    int max_line_connections;\n    float3 vRaster;\n    float3 pRaster;\n    float3 tRaster;    \n    float3 vWorld;\n    float canvasWidth;\n    float canvasHeight; \n    float matrixData\[4]\[4];\n    float4x4 cameraToWorld;\n    float4x4 worldToCamera;\n\n  void define() \{\n    defineParam(cam_Matrix, \"cam_Matrix\", float4x4( 1.0f,0.0f,0.0f,0.0f,\n                                                    0.0f,1.0f,0.0f,0.0f,\n                                                    0.0f,0.0f,1.0f,0.0f,\n                                                    0.0f,0.0f,0.0f,1.0f));\n    defineParam(cam_Focal,      \"focallength\", 11.5f);\n    defineParam(cam_Hapeture,      \"hapeture\", 24.576f);\n    defineParam(WHformat,      \"format\", int2(2048,2048));\n    defineParam(Vformat,      \"vertexformat\", int2(10,10));\n    defineParam(zoom, \"Zoom\", 1.0f);\n    defineParam(_filtering, \"Filtering Method\", 1); \n    defineParam(_alphaMultiplier, \"_alphaMultiplier\", 1.0f);     \n    defineParam(_pointRender, \"_pointRender\", true);  \n    defineParam(_wireRender, \"_wireRender\", true);\n    defineParam(_facetRender, \"_facetRender\", true);\n    defineParam(_maxPlexDistance, \"_maxLDistance\", 1.0f);    \n    defineParam(_maxPlexConnections, \"_maxLConnections\", 1);    \n    defineParam(_maxPlexType, \"_maxPlexType\", 0); \n    defineParam(_plexLinedefXY, \"_plexLinedefXY\", false);      \n    defineParam(_plexLinedefXtoY, \"_plexLinedefXtoY\", false); //NYI\n    defineParam(_plexLinedefAUX, \"_plexLinedefAUX\", false); \n    defineParam(_plexLinedefX, \"_plexLinedefX\", false);  \n    defineParam(_plexLinedefY, \"_plexLinedefY\", false);  \n    defineParam(_plexConnectX, \"_plexConnectX\", false);      \n    defineParam(_plexConnectY, \"_plexConnectY\", false);   \n    defineParam(_plex_gamma, \"_L_gamma\", 1.0f);\n    //DOF SETTINGS   \n    defineParam(_dof_enable, \"Enable Depth of Field\", false);   \n    defineParam(_dof_samples, \"samples\", 3);    \n    defineParam(_dof_rings, \"rings\", 5);   \n    defineParam(focalDepth, \"focalDepth\", 1.0f);  \n    defineParam(_depthOfField, \"_depthOfField\", 4.0f);  \n    defineParam(_depthMult, \"_depthMult\", 0.1f);  \n    defineParam(_maxDofSize, \"_maxDofSize\", 8.0f);  \n    defineParam(dof_aspect, \"dof_aspect\", 1.0f);  \n    defineParam(dof_threshold, \"dof_threshold\", 1.0f);  \n    defineParam(dof_gain, \"dof_gain\", 0.0f);  \n    defineParam(dof_bias, \"dof_bias\", -2.0f);  \n    defineParam(dof_fringe, \"dof_fringe\", 0.0f); \n    //SHADING SETTINGS \n    defineParam(_flatshading, \"_flatshading\", true);  \n    defineParam(_vertexMode, \"_vertexMode\", 0);  \n    defineParam(_backfacing, \"_backfacing\", true);    \n    defineParam(_frontfacing, \"_frontfacing\", true);        \n    defineParam(_depthBuffer, \"_depthBuffer\", true);  \n    defineParam(_texoffset, \"_texoffset\", float2(0.5f,0.5f)); \n    defineParam(_pointSize, \"_pointSize\", 1); \n    defineParam(_gaussigma, \"_gaussigma\", 1.0f); \n    defineParam(_depthOcclusion, \"_depthOcclusion\", true); \n    defineParam(depthMultiplier, \"depthMultiplier\", 1.0f); \n    defineParam(_maxLineSteps, \"_maxLineSteps\", 4000.0f); \n    defineParam(_lineOffset, \"_lineOffset\", 1.0f); \n    defineParam(_lineInMultiplier, \"_lineInMultiplier\", 1.0f);   \n    defineParam(_lineOutMultiplier, \"_lineOutMultiplier\", 1.0f);     \n\n  \}\n\n  //The init() function is run before any calls to process().\n  void init() \{\n    max_line_connections = 80;\n    canvasWidth = ((cam_Hapeture)/cam_Focal);\n    canvasHeight = ((cam_Hapeture)/cam_Focal)*float(float(WHformat.y)/float(WHformat.x)); \n    float matrixData\[] = \{cam_Matrix\[0]\[0], cam_Matrix\[1]\[0], cam_Matrix\[2]\[0], cam_Matrix\[3]\[0], \n                          cam_Matrix\[0]\[1], cam_Matrix\[1]\[1], cam_Matrix\[2]\[1], cam_Matrix\[3]\[1], \n                          cam_Matrix\[0]\[2], cam_Matrix\[1]\[2], cam_Matrix\[2]\[2], cam_Matrix\[3]\[2], \n                          cam_Matrix\[0]\[3], cam_Matrix\[1]\[3], cam_Matrix\[2]\[3], cam_Matrix\[3]\[3]\};\n    cameraToWorld.setArray(matrixData); //This is a workaround. Due to the buggy matrix implementation, we pass the matrix on from another structure.\n    worldToCamera = cameraToWorld.invert();\n  \}\n\n  //Convert a 3d point position into a 2d raster position.\n  float3 Reconsile3D(float3 _PointPos)\{\n      vWorld = float3(_PointPos.x,_PointPos.y,_PointPos.z)*(zoom);\n      int ret = computePixelCoordinates(vWorld, tRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1]);\n      return tRaster;\n  \}\n\n//------------------------------\n//-------DRAW FUNCTIONS---------\n//------------------------------\n  //Write pixels to output.\n  void writepixel(float posx,float posy, float4 color,int index,float weight=1.0f)\n  \{ \n      if (_depthOcclusion)\{\n        float4 depthSample = occlusion(posx,posy);\n        if (depthSample.x<=vRaster.z && depthSample.w>0.0f)\{\n\n          float depth = (vRaster.z-depthSample.x);\n          color = color*(1.0f-depthSample.w);\n          color = color / (((depth*depth)*depthMultiplier)+1.0f);\n          //return;\n        \}\n      \}\n      float4 finalOutput; //This is used to store the final output\n      float4 dstSample; //This is used to store a sample of the destination\n      if ( dst.bounds.inside( posx, posy ) ) \{ //Test if the pixel written to is inside the output image. \n        if (_depthBuffer) \{\n          dstSample = (float4)dst(posx,posy); //Sample the destination image\n          if ((dstSample.w>color.w)||dstSample.w==0.0f) \{\n            dst(posx,posy) = color;\n          \}\n        \}\n        else \{\n          dstSample = (float4)dst(posx,posy); //Sample the destination image\n          finalOutput = dstSample + (color*_alphaMultiplier*weight);\n          finalOutput.w = dstSample.w + ((color.w*_alphaMultiplier*weight));\n\n          finalOutput.w = (dstSample.w + ((color.w*_alphaMultiplier*weight)))-(dstSample.w * ((color.w*_alphaMultiplier*weight)));\n\n          dst(posx,posy) = finalOutput;\n        \}\n      \} \n  \}\n\n  //Calculate a Bilinear Plot\n  void bilinear_Plot(float2 temppos,float4 color,int index)\n  \{\n    float2 p;\n    p.x=Frac(temppos.x);\n    p.y=Frac(temppos.y);\n    float weights\[] = \{(1.0f-p.x)*(1.0f-p.y), p.x*(1.0f-p.y), (1.0f-p.x)*p.y, p.x*p.y\};\n    int2 _position = int2(floor(temppos.x)-0,floor(temppos.y)-0); \n    writepixel(_position.x,_position.y,color,index,weights\[0]);\n    writepixel(_position.x+1,_position.y,color,index,weights\[1]);\n    writepixel(_position.x,_position.y+1,color,index,weights\[2]);\n    writepixel(_position.x+1,_position.y+1,color,index,weights\[3]);\n  \}\n\n  //NYI, unused!\n  void gaussian(float2 temppos,float4 color,int index)\{\n    float in_x = temppos.x;\n    float in_y = temppos.y;\n    int kernelSize = (_pointSize+1)*2;\n    int subsize = (kernelSize /2)-1;\n    float gKernel\[64]\[64];\n    float sigma = _gaussigma;\n    float intSigma = float(_pointSize);\n    float r, s = intSigma * sigma * sigma;\n\n    float sum = 0.0f;\n\n    // generate 5x5 kernel\n    for (int x = -subsize; x <= subsize; x++)\n    \{\n        for(int y = -subsize; y <= subsize; y++)\n        \{\n            r = float(sqrt(x*x + y*y));\n            gKernel\[x + subsize]\[y + subsize] = (exp(-(r*r)/s))/(3.141592654f * s);\n            sum += gKernel\[x + subsize]\[y + subsize];\n        \}\n    \}\n\n    // normalize the Kernel\n    for (int x = -subsize; x <= subsize; x++)\n    \{\n        for(int y = -subsize; y <= subsize; y++)\n        \{\n            gKernel\[x + subsize]\[y + subsize] /= sum;\n            writepixel(in_x+x,in_y+y,color,index,gKernel\[x + subsize]\[y + subsize]);\n        \}\n    \}\n  \}\n\n//-------------------------------------\n// DrawLine\n// ----------\n// Draw a line between two points, \n// x,y being 2d screenspace pos and z being depth.\n//-------------------------------------\n  void DrawLine(float3 origin, float3 endpoint,float4 _colorA,float4 _colorB) \{\n    float4 _color;\n    float3 delta = origin-endpoint;\n    float3 curPoint = origin;\n    float mag = sqrt(delta.x*delta.x+delta.y*delta.y);\n    mag = min(mag,_maxLineSteps); //Lets not go crazy, we cap it at 10.000 to avoid insane unwated processing time \n    for( float a = 0; a < mag*_lineOffset; a = a + 1.0f )\{\n      curPoint -= (delta/mag);\n      _color = (_colorA*(1.0f-(a/mag*1.0f)))+(_colorB*(a/mag*1.00f));\n      if (_dof_enable)\{\n        Bokeh(curPoint,_color);\n      \}\n      else \{\n        bilinear_Plot(float2(curPoint.x,curPoint.y),_color,1);\n      \}\n      \n    \}\n  \}\n\n//-------------------------------------\n// Point_Render\n//-------------------------------------\nvoid point_render(int2 pos, float3 screen_pos)\{\n  float4 color = src(pos.x,pos.y);\n\n  if (_filtering == 1)\{\n      if (_dof_enable)\{\n        Bokeh(screen_pos,color);\n      \}\n      else \{\n        bilinear_Plot(float2(screen_pos.x,screen_pos.y),color,1);\n      \}\n  \}\n  /*\n  //THIS PART NEEDS TO BE RE-WRITTEN.\n  else if (_filtering == 2)\{ \n      if (_dof_enable)\{\n        Bokeh(screen_pos,color);\n      \}\n      else \{\n        gaussian(float2(screen_pos.x,screen_pos.y),color,1);\n      \}\n  \}\n  */\n  else \{\n      int2 _position = int2(floor(screen_pos.x),floor(screen_pos.y)); \n      if (_depthBuffer) \{color.w = screen_pos.z;\}\n      writepixel(_position.x,_position.y, color,1,1.0f); //OutputSample\n  \}\n\n\}\n\n//-------------------------------------\n// Facet_Render\n//-------------------------------------\n//This function is used to calculate what triangels to draw\nvoid facet_render(int2 pos, float3 _vWorld)\{\n\n    float3 screen_pos = Reconsile3D(_vWorld);\n\n    bool insideX = ppos.bounds.inside(pos.x+1,pos.y );\n    bool insideY = ppos.bounds.inside(pos.x+1,pos.y-1 );\n    bool insideYtop = ppos.bounds.inside(pos.x,pos.y+1);\n    float2 fpos = float2(pos.x,pos.y);\n    float3 V1_Pos,V2_Pos,V1_wPos,V2_wPos,V0_N,V1_N,V2_N;\n    float2 V0_ST,V1_ST,V2_ST;\n    float4 V1_Sample,V2_Sample;\n    float4 _tn;\n    float3 normal0,normal1,normal2;\n    float2 UV_Format = float2(Vformat.x,Vformat.y);\n\n\n    int2 P0 = int2(pos.x-1,pos.y-1);\n    int2 P1 = int2(pos.x+1,pos.y+1);\n    if (_plexConnectX && pos.x == int(Vformat.x))\{\n      insideX == true;\n      P1 = int2(0.0f,pos.y+1);\n    \}\n    if (_plexConnectY && pos.y == int(Vformat.y))\{\n      insideYtop == true;\n      P1 = int2(pos.x+1,0);\n    \} \n\n    if (_plexConnectY && pos.y == 0)\{\n      insideY == true;\n      P0 = int2(pos.x-1,int(UV_Format.y));\n    \} \n\n    if (!_flatshading) \{\n      _tn = normals(pos.x,pos.y);\n      V0_N =float3(_tn.x,_tn.y,_tn.z);\n    \}\n    V0_ST = float2(pos.x,pos.y)/UV_Format;\n\n  if (insideX) \{\n    V2_Sample = ppos(P1.x,pos.y);\n    V2_ST = float2(P1.x,pos.y)/UV_Format;\n    V2_wPos = float3(V2_Sample.x,V2_Sample.y,V2_Sample.z);\n    V2_Pos = Reconsile3D(V2_wPos);\n    if (!_flatshading) \{\n      _tn = normals(P1.x,pos.y);\n      V2_N =float3(_tn.x,_tn.y,_tn.z);\n    \}\n        \n\n    if (V2_Sample.w != 0.0f) \{ \n\n      if (insideY) \{\n        V1_Sample = ppos(P1.x,P0.y);\n        V1_ST = float2(P1.x,P0.y)/UV_Format;\n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (!_flatshading) \{\n          _tn = normals(P1.x,P0.y);\n          V1_N =float3(_tn.x,_tn.y,_tn.z);\n        \}\n        if (V1_Sample.w != 0.0f) \{ \n          DrawTriangle(screen_pos,V2_Pos,V1_Pos,_vWorld,V2_wPos,V1_wPos,V0_N,V2_N,V1_N,V0_ST,V2_ST,V1_ST);\n        \}\n      \}\n      if (insideYtop) \{\n        V1_Sample = ppos(pos.x,P1.y);\n        V1_ST = float2(pos.x,P1.y)/UV_Format;        \n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (!_flatshading) \{\n          _tn = normals(pos.x,P1.y);\n          V1_N =float3(_tn.x,_tn.y,_tn.z);\n        \}        \n        if (V1_Sample.w != 0.0f) \{ \n          DrawTriangle(screen_pos,V1_Pos,V2_Pos,_vWorld,V1_wPos,V2_wPos,V0_N,V1_N,V2_N,V0_ST,V1_ST,V2_ST);\n        \}\n      \}\n    \}\n  \}\n\}\n\n\n\n//This function will calculate if pixel C is inside the triangle\nfloat edgeFunction(float3 a, float3 b, float3 c) \n\{ \n    return ((c.x - a.x) * (b.y - a.y) - (c.y - a.y) * (b.x - a.x)); \n\} \n\nfloat3 CalculateSurfaceNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat3 CalculateVertexNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat Distance(float3 _a,float3 _b)\n\{\n          float xd = _a.x - _b.x;\n          float yd = _a.y - _b.y;\n          float zd = _a.z - _b.z;\n          return sqrt(xd*xd + yd*yd + zd*zd);\n\}\n\nvoid DrawTriangle(float3 V0, float3 V1, float3 V2,float3 WP0, float3 WP1, float3 WP2,float3 N0, float3 N1, float3 N2, float2 st0,float2 st1,float2 st2) \{\n\n  // Precompute reciprocal of vertex z-coordinate \n  V0.z = 1.0f / V0.z, V1.z = 1.0f / V1.z, V2.z = 1.0f / V2.z; \n\n  float2 st0n = st0 * V0.z;\n  float2 st1n = st1 * V1.z; \n  float2 st2n = st2 * V2.z; //Normal version of ST\n\n  bool inside; \n  float X0 = Fmin(V0.x,V1.x,V2.x)-1.0f;\n  float X1 = Fmax(V0.x,V1.x,V2.x)+1.0f;\n  float Y0 = Fmin(V0.y,V1.y,V2.y)-1.0f;\n  float Y1 = Fmax(V0.y,V1.y,V2.y)+1.0f;\n  float area = edgeFunction(V2, V1, V0);\n\n\n  float2 sampos = float2(st0.x*float(Vformat.x),st0.y*float(Vformat.y));\n  float4 text0 = src(sampos.x,sampos.y);\n  sampos = float2(st1.x*float(Vformat.x),st1.y*float(Vformat.y));\n  float4 text1 = src(sampos.x,sampos.y);\n  sampos = float2(st2.x*float(Vformat.x),st2.y*float(Vformat.y));  //Why do we have to do this? =(\n  float4 text2 = src(sampos.x,sampos.y);\n  sampos = float2(min(min(st0.x,st1.x),st2.x)*float(Vformat.x),min(min(st0.y,st1.y),st2.y)*float(Vformat.y));\n  float4 text3 = src(sampos.x,sampos.y);\n\n\n  for( int x = X0; x < X1 ; x++) \{\n    for( int y = Y0; y < Y1 ; y++) \{\n      float3 pixelSample(x + _texoffset.x, y + _texoffset.y,0.0f); \n\n      //This is the part where we test if the current pixel is inside the triangle\n      //We check both for front facing and back faing options\n      float w0 = edgeFunction(V1, V0, pixelSample); //Front Facing\n      float w1 = edgeFunction(V2, V1, pixelSample); \n      float w2 = edgeFunction(V0, V2, pixelSample); \n      float w3 = edgeFunction(V0, V1, pixelSample); //Back Facing\n      float w4 = edgeFunction(V1, V2, pixelSample); \n      float w5 = edgeFunction(V2, V0, pixelSample);\n\n      //writepixel(x,y, float4(w1),1,1.0f);\n      if ((w0 >= 0 && w1 >= 0 && w2 >= 0 && _frontfacing) || (w3 >= 0 && w4 >= 0 && w5 >= 0 && _backfacing)) \{ //The curent pixel is inside the triangle\n\n       // calculate vectors from point f to vertices p1, p2 and p3:\n       float3 f1 = V0-pixelSample;\n       float3 f2 = V1-pixelSample;\n       float3 f3 = V2-pixelSample;\n       // calculate the areas and factors (order of parameters doesn't matter):\n       float a = length(cross(V0-V1,V0-V2 )); // main triangle area a\n       area = length(V0-V1)+length(V0-V2)+length(V1-V2);\n\n        w0 /= area; \n        w1 /= area; \n        w2 /= area; \n\n        w3 /= area; \n        w4 /= area; \n        w5 /= area; \n\n       float a1 = length(cross(f2, f3)) / a; // p1's triangle area / a\n       float a2 = length(cross(f3, f1)) / a; // p2's triangle area / a \n       float a3 = length(cross(f1, f2)) / a; // p3's triangle area / a\n       float a_magnitude = a1+a2+a3;\n       a1 = a1/a_magnitude;\n       a2 = a2/a_magnitude;\n       a3 = a3/a_magnitude;\n       float z = 1.0f / (V0.z * a1 + V1.z * a2 + V2.z * a3); \n\n\n        // find the uv corresponding to point f (uv1/uv2/uv3 are associated to p1/p2/p3):\n        float2 uv = st0 * a1 + st1 * a2 + st2 * a3;\n        float2 st = st0 * w0 + st1 * w1 + st2 * w2; \n        st *= z;      \n\n\n        //Calculate normals. Eighter we have flat shading, else we calculate a normal per pixel\n        float3 normalB;\n        if (_flatshading) \{\n          normalB = CalculateSurfaceNormals(WP0,WP1,WP2);\n\n        \}\n        else \{\n          float3 c0 = N2/float3(V0.z); \n          float3 c1 = N0/float3(V1.z); \n          float3 c2 = N1/float3(V2.z);  \n\n          normalB.x = w0 * c0.x + w1 * c1.x + w2 * c2.x; \n          normalB.y = w0 * c0.y + w1 * c1.y + w2 * c2.y; \n          normalB.z = w0 * c0.z + w1 * c1.z + w2 * c2.z; \n\n          normalB.x *= z, normalB.y *= z, normalB.z *= z; \n        \}\n        normalB = normalize(normalB);\n\n        //CALCULATE THE OBJECT TEXTURE COORDINATES\n        float zn = 1.0f / (V0.z * w0 + V1.z * w1 + V2.z * w2); \n        st = st0n * w0 + st1n * w1 + st2n * w2; \n        st *= zn;   \n        //--END \n\n        float3 Wpos = WP0*a1 + WP1*a2 + WP2*a3; //World Position.\n        float3 ViewNormal = normalize(float3(cameraToWorld\[3]\[0],cameraToWorld\[3]\[1],cameraToWorld\[3]\[2])-Wpos);\n\n        float nDotView =  dot(normalB,ViewNormal);\n        nDotView = 1.0f-fabs(nDotView); //make sure that the view normal ramps back around when doing backface\n        float4 tempout;\n\n        //Flatshading or regular?\n        if (!_flatshading) \{\n          tempout = text0 * a1 + text1 * a2 + text2 * a3; \n        \}\n        else\{\n          tempout = text3;\n        \}\n\n        //Additional Render Modes\n        if (_vertexMode == 1)\{\n          tempout = float4(a1,a2,a3,1.0f);\n        \}\n        else if (_vertexMode == 2)\{\n          tempout = float4(normalB.x,normalB.y,normalB.z,1.0f);\n        \}\n        else if (_vertexMode == 3)\{\n          tempout = float4(nDotView,nDotView,nDotView,1.0f);\n        \}\n        else if (_vertexMode == 4)\{\n          tempout = float4(uv.x,uv.y,0.0f,1.0f);\n        \}       \n        else if (_vertexMode == 5)\{\n          tempout = float4(st.x,st.y,0.0f,1.0f);\n        \}               \n        else if (_vertexMode == 6)\{\n          tempout = float4(ViewNormal.x,ViewNormal.y,ViewNormal.z,1.0f);\n        \}             \n        else if (_vertexMode == 7)\{\n          tempout = float4(Wpos.x,Wpos.y,Wpos.z,1.0f);\n        \}   \n\n        if (_depthBuffer)\{\n          writepixel(x,y, float4(tempout.x,tempout.y,tempout.z,z),1,1.0f);  \n        \}\n        else \{\n          if (_dof_enable)\{\n            Bokeh(float3(x,y,z),float4(tempout.x,tempout.y,tempout.z,z));\n          \}\n          else \{\n            bilinear_Plot(float2(x,y),float4(tempout.x,tempout.y,tempout.z,z),1);\n          \}\n        \}\n\n      \}  \n\n    \}\n  \}\n\}\n\n//-------------------------------------\n// Wire_Render\n//-------------------------------------\nvoid wire_render(int2 pos) \{\n  float4 temp = float4(0.0f,0.0f,0.0f,FLT_MAX);\n  float4 wire_ref_sample;\n  int2 tempXY = int2(0,0);\n  float4 plexlist\[11] = \{temp,temp,temp,temp,temp,temp,temp,temp,temp,temp,temp\}; \n  int2 plexlistXY\[11] = \{tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY\};\n  int plex_count = 0; //We use this to figure how many points that should connect.\n  float plex_dist;\n  float3 plex_position,plex_position_b;\n  float4 temp_pos, temp_pos_b; //Temporary Position Containers\n  if (_maxPlexType == -1) \{ //Used for random connection types\n    for( int x = 0; x < max_line_connections ; x++)\{ //THIS 80 NUMBER IS THE LIMIT TO AVOID TOO SLOW PROCESSING!\n      for( int y = 0; y < max_line_connections ; y++)\{\n        wire_ref_sample = ppos(x,y);\n        if (wire_ref_sample.w != 0.0f && pos.x!=x && pos.y != y) \{ \n          plex_position = float3(wire_ref_sample.x,wire_ref_sample.y,wire_ref_sample.z)*(zoom);\n          float xd = plex_position.x - vWorld.x;\n          float yd = plex_position.y - vWorld.y;\n          float zd = plex_position.z - vWorld.z;\n          float plex_dist = sqrt(xd*xd + yd*yd + zd*zd);\n          if (plex_dist<_maxPlexDistance)\{\n            plex_count = min(10,plex_count+1); //Add one to the count\n            for( int h = 0; h < plex_count+1 ; h++) \{ //Loop thought all the points. If the distance is shorter then insert it into the array and push the rest of the array down\n              if (plex_dist < plexlist\[h].w) \{                  \n                for( int i = plex_count+1; i > h ; i--) \{\n                  plexlist\[i] = plexlist\[i-1];\n                  plexlistXY\[i] = plexlistXY\[i-1];\n                \}\n                plexlist\[h] = float4(plex_position.x,plex_position.y,plex_position.z,plex_dist);\n                plexlistXY\[h] = int2(x,y);\n                break;        \n              \}\n            \}\n          \} \n        \}\n      \}\n    \}\n  \}\n  else\{ //Used for standard connection types\n    float4 temp_pos;\n    bool insideX = !(Vformat.x < pos.x+1);\n    bool insideY = !(Vformat.y < pos.y+1);\n\n\n    if (!_plexLinedefAUX)\{\n      temp_pos = normals(pos.x,pos.y);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,vWorld+plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    if ( insideX && !_plexLinedefX) \{\n      temp_pos = ppos(pos.x+1,pos.y );\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && !_plexLinedefX) \{\n      temp_pos = ppos(0,pos.y);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    if ( insideY && !_plexLinedefY) \{\n      temp_pos = ppos(pos.x,pos.y+1);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\}                          \n    \}\n    else if ( _plexConnectY  && !_plexLinedefY) \{\n      temp_pos = ppos(pos.x,0);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    //_plexConnect\n    if ( insideX && insideY && !_plexLinedefXY) \{              \n      temp_pos = ppos(pos.x+1,pos.y+1);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && _plexConnectY && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && insideY && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectY && insideX && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n  \}   \n\n  //now that all the connections have been sorted by distance then we connect the dots.\n  for( int x = 0; x < min(_maxPlexConnections,plex_count) ; x++)\{\n    plex_position = float3(plexlist\[x].x,plexlist\[x].y,plexlist\[x].z);\n    plex_dist = plexlist\[x].w;\n\n\n    float plex_distribution = 1.0f-((plexlist\[x].w-plexlist\[0].w)/((plexlist\[min(_maxPlexConnections,plex_count)].w-plexlist\[0].w)+0.00001f)); //Where does it lie between the best and the worst distance?\n    //plexlistXY\n\n    float4 plex_col = float4(pow(1.0f-(plex_dist/_maxPlexDistance),1.0f/_plex_gamma))*float4(plex_distribution); //This one is quite cool aswell, but does leave the center ones a bit too focused \n    float4 plex_colorA = src(pos.x,pos.y);\n    float4 plex_colorB = src( plexlistXY\[x].x,plexlistXY\[x].y);\n    plex_col *= 0.1f;\n\n    computePixelCoordinates(plex_position, pRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1]);\n    if (dst.bounds.inside(int(vRaster.x),int(vRaster.y)) || dst.bounds.inside(int(pRaster.x),int(pRaster.y)))\{\n        DrawLine(vRaster,pRaster,(plex_colorA*plex_col)*_lineInMultiplier,(plex_colorB*plex_col)*_lineOutMultiplier);\n    \}\n  \}\n\}\n\nvoid wire_connection(float3 p_source,float3 p_target, float4 (&p_plexlist)\[11], int2 (&p_plexlistXY)\[11],int &p_plexcount,int2 position) \{\n  float xd = p_target.x - p_source.x;\n  float yd = p_target.y - p_source.y;\n  float zd = p_target.z - p_source.z;\n  float plex_dist = sqrt(xd*xd + yd*yd + zd*zd);\n  if (plex_dist<_maxPlexDistance)\{\n    p_plexcount = min(11,p_plexcount+1); //Add one to the count\n    for( int h = 0; h < p_plexcount+1 ; h++) \{ //Loop thought all the points. If the distance is shorter then insert it into the array and push the rest of the array down\n      if (plex_dist < p_plexlist\[h].w) \{                  \n        for( int i = p_plexcount+1; i > h ; i--) \{\n          p_plexlist\[i] = p_plexlist\[i-1];\n          p_plexlistXY\[i] = p_plexlistXY\[i-1];\n        \}\n        p_plexlist\[h] = float4(p_target.x,p_target.y,p_target.z,plex_dist);\n        p_plexlistXY\[h] = int2(position.x,position.y);\n        break;        \n      \}\n    \}  \n  \}\n\}\n//-------END OF WIRE RENDER FUNCTIONS---------\n\n\n\n\n//-------------------------------\n//-------BOKEH FUNCTIONS---------\n//thanks to: http://devlog-martinsh.blogspot.dk/2011/11/glsl-depth-of-field-with-bokeh-v21.html\nfloat2 rand(float2 coord) //generating noise/pattern texture for dithering\n\{\n  float noiseX = ((Frac(1.0-coord.x*(WHformat\[0]/2.0))*0.25)+(Frac(coord.y*(WHformat\[1]/2.0))*0.75))*2.0-1.0;\n  float noiseY = ((Frac(1.0-coord.x*(WHformat\[0]/2.0))*0.75)+(Frac(coord.y*(WHformat\[1]/2.0))*0.25))*2.0-1.0;\n  noiseX = clamp(Frac(sin(dot(coord ,float2(12.9898f,78.233f))) * 43758.5453f),0.0f,1.0f)*2.0f-1.0f;\n  noiseY = clamp(Frac(sin(dot(coord ,float2(12.9898f,78.233f)*2.0f)) * 43758.5453f),0.0f,1.0f)*2.0-1.0f;\n  return float2(noiseX,noiseY);\n\}\n//-------------------------------------\n// Bokeh\n//-------------------------------------\nvoid Bokeh(float3 pos,float4 color)\{\n  float blur = 0.0;\n  blur = clamp((fabs(pos.z - focalDepth)/_depthOfField)*100.0f,-_maxDofSize,_maxDofSize);\n  \n  float w = (1.0/WHformat.x)*blur;//+noise.x;\n  float h = (1.0/(WHformat.x*dof_aspect))*blur;//+noise.y;\n  float3 v3_col = float3(color.x,color.y,color.z);\n  int ringsamples;\n  float s = 1.0;  \n\n  for (int i = 1; i <= _dof_rings; i += 1)\n  \{   \n    ringsamples = i * _dof_samples; \n    for (int j = 0 ; j < ringsamples ; j += 1)  \n    \{ \n      s += (1.0f*mix(1.0f,(float(i))/(float(_dof_rings)),dof_bias)*1.0f); //No need to do this in the loop\n    \}\n  \}\n\n  for (int i = 1; i <= _dof_rings; i += 1)\n  \{   \n    ringsamples = i * _dof_samples;\n     \n    for (int j = 0 ; j < ringsamples ; j += 1)   \n    \{\n      float step = PI*2.0 / float(ringsamples);\n      float pw = (cos(float(j)*step)*(float(i)/_dof_rings));\n      float ph = (sin(float(j)*step)*(float(i)/_dof_rings));\n      float p = 1.0;\n\n      float posx = pos.x+((pw*w)*blur);\n      float posy = pos.y+((ph*h)*blur);\n\n\n      float3 lumcoeff = float3(0.299,0.587,0.114);\n      float lum = dot(v3_col, lumcoeff);\n      float thresh = max((lum-dof_threshold)*dof_gain, 0.0f);\n      v3_col+mix(float3(0.0),v3_col,thresh*blur);\n\n      float3 col = (v3_col*mix(1.0,(float(i))/(float(_dof_rings)),dof_bias)*p)/s; \n      bilinear_Plot(float2(posx,posy),float4(col.x,col.y,col.z,color.w/(_dof_rings*_dof_rings)),1);\n    \}\n  \}\n\}\n//-------END OF BOKEH FUNCTIONS---------\n\n\n\n//-------------------------------------\n// Process\n//-------------------------------------\n  void process(int2 pos) \{\n    float4 _sample = ppos(pos.x,pos.y); //Get the XYZ Coordinates\n    float2 posf = float2(pos.x,pos.y);\n\n    if (_sample.w != 0.0f) \{  //No need to process if there is no data.\n\n      //Convert worldspace coordinates to screenspcace coordinates.\n      vWorld = float3(_sample.x,_sample.y,_sample.z)*(zoom);\n      int ret = computePixelCoordinates(vWorld, vRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1]);\n      if (ret) \{ //Only create points that are visible on screen\n        if (_pointRender)\{\n          point_render(pos,vRaster);\n        \}\n      \} //Pointrender over\n\n      if (_wireRender && _maxPlexConnections>=1) \{\n        if (max(pos.x,pos.y)<=max_line_connections || (_maxPlexType==0))\{ // Don't process more wires than allowed in nearest mode.\n          wire_render(pos);\n        \}\n      \} //WireRender over\n\n      if (_facetRender) \{\n        facet_render(pos,float3(_sample.x,_sample.y,_sample.z));\n      \}  //FacetRender over\n      \n    \}\n  \} //----> process\n\};\n"
  useGPUIfAvailable false
  rebuild ""
  PointRender3D_cam_Matrix {
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
    }
  PointRender3D_focallength {{parent.Camera1.focal}}
  PointRender3D_hapeture {{parent.Camera1.haperture}}
  PointRender3D_format {{Settings_Format.width} {Settings_Format.height}}
  PointRender3D_vertexformat {{parent.InputFormat.box.r-1} {parent.InputFormat.box.t-1}}
  PointRender3D__alphaMultiplier {{parent.AlphaMultiplier}}
  PointRender3D__pointRender {{parent.RenderMode==0}}
  PointRender3D__wireRender {{parent.RenderMode==1}}
  PointRender3D__facetRender {{parent.RenderMode==2}}
  PointRender3D__maxLDistance {{parent.wire_maxdistance}}
  PointRender3D__maxLConnections {{parent.wire_connections}}
  PointRender3D__maxPlexType {{-parent.wire_type}}
  PointRender3D__plexLinedefXY {{!parent.connect_xy}}
  PointRender3D__plexLinedefX {{!parent.connect_x}}
  PointRender3D__plexLinedefY {{!parent.connect_y}}
  PointRender3D__plexLinedefAUX {{!connect_aux}}
  PointRender3D__plexConnectX {{parent.CloseX}}
  PointRender3D__plexConnectY {{parent.CloseY}}
  PointRender3D__L_gamma {{parent.wire_Threshold}}
  "PointRender3D_Enable Depth of Field" {{parent.dof_enable}}
  PointRender3D_samples {{3*(parent.Dof_Quality*parent.Dof_Quality+1)}}
  PointRender3D_rings {{3*(parent.Dof_Quality*parent.Dof_Quality+1)}}
  PointRender3D_focalDepth {{parent.dof_focaldepth}}
  PointRender3D__depthOfField {{parent.dof_dof}}
  PointRender3D__depthMult {{parent.DofMultiplier}}
  PointRender3D__maxDofSize {{parent.dof_maxSize*400}}
  PointRender3D_dof_aspect {{parent.dof_Aspect}}
  PointRender3D_dof_bias {{parent.dof_bias}}
  PointRender3D__flatshading {{parent.facet_flatShading}}
  PointRender3D__backfacing {{parent.facet_backface}}
  PointRender3D__frontfacing {{parent.facet_front}}
  PointRender3D__vertexMode {{parent.renderMode}}
  PointRender3D__depthBuffer {{parent.facet_depth}}
  PointRender3D__texoffset {-0.5 0.5}
  PointRender3D__pointSize 0
  PointRender3D__depthOcclusion {{parent.UseOcclusionMap}}
  PointRender3D__maxLineSteps {{parent.maxSamples}}
  PointRender3D__lineOffset {{parent.lineoffset}}
  PointRender3D__lineInMultiplier {{parent.inGain}}
  PointRender3D__lineOutMultiplier {{parent.outGain}}
  format "1280 720 0 0 1280 720 1 HD_720"
  rebuild_finalise ""
  name BlinkScript1
  selected true
  xpos -27
  ypos 159
 }
 Reformat {
  format {{{Settings_Format.format}}}
  resize none
  center false
  name Reformat1
  xpos -27
  ypos 343
 }
 Group {
  name SoftLook
  xpos -27
  ypos 460
  disable {{!parent.HighlightCompression}}
  addUserKnob {20 User}
  addUserKnob {26 ""}
  addUserKnob {7 Add R 0 4}
  Add {{parent.HighlightCeiling}}
  addUserKnob {7 Offset R 0 4}
  Offset {{parent.Compression}}
 }
  Input {
   inputs 0
   name Input1
   xpos -248
   ypos 500
  }
set N68bdb7a0 [stack 0]
  Expression {
   expr0 r/(r+parent.Offset)*parent.Add
   expr1 g/(g+parent.Offset)*parent.Add
   expr2 b/(b+parent.Offset)*parent.Add
   expr3 a/(a+parent.Offset)*parent.Add
   name Expression1
   xpos -339
   ypos 576
  }
push $N68bdb7a0
  ShuffleCopy {
   inputs 2
   red red
   green green
   blue blue
   alpha alpha2
   name ShuffleCopy1
   xpos -248
   ypos 576
  }
  Output {
   name Output1
   xpos -248
   ypos 651
  }
 end_group
 TimeBlur {
  divisions {{parent.Samples}}
  shutter {{parent.Shutter}}
  shutteroffset centred
  shuttercustomoffset 0
  name MotionBlur
  xpos -27
  ypos 581
  disable {{1-parent.mb_enable x89 0}}
 }
 ShuffleCopy {
  inputs 2
  in pos
  red red
  green green
  blue blue
  out pos
  name ShuffleCopy1
  xpos -27
  ypos 673
  disable true
 }
 Output {
  name Output1
  xpos -27
  ypos 710
 }
 Input {
  inputs 0
  name InputCamera
  xpos -1129
  ypos 116
  number 1
 }
 Camera2 {
  focal {{parent.FocalLength}}
  haperture {{parent.horizontalApeture}}
  name Camera1
  xpos -1119
  ypos 223
  addUserKnob {20 Ivy}
  addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.toolbox.v1.nodes.docs', fromlist=\['open_docs_name']).open_docs_name('IvyTab')" +STARTLINE}
  addUserKnob {26 divider4 l "" +STARTLINE}
  addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
  _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
  addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
  addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
  addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
  _expressions {{curve}}
  addUserKnob {26 divider0 l "" +STARTLINE}
  addUserKnob {20 dbinfo l "DB Info" n 1}
  dbinfo 0
  addUserKnob {1 twig_dnuuid l "Twig Id"}
  addUserKnob {1 stalk_dnuuid l "Stalk Id"}
  addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
  addUserKnob {1 leaf_dnuuid l "Leaf Id"}
  addUserKnob {26 divider1 l "" +STARTLINE}
  addUserKnob {1 twigtype l "Twig Type"}
  addUserKnob {1 leaf_label l Leaf}
  addUserKnob {1 ivy_version l Version}
  addUserKnob {43 ivy_notes l Notes}
  addUserKnob {26 divider2 l "" +STARTLINE}
  addUserKnob {1 build_label l "Build Label"}
  addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
 }
 Reformat {
  inputs 0
  format "2156 1806 0 0 2156 1806 2 JOYRIDE Working"
  resize none
  center false
  name Settings_Format
  xpos -1404
  ypos 241
 }
push $N564e1960
 PositionToPoints2 {
  display textured
  render_mode textured
  P_channel pos
  detail 0.25
  pointSize 0.6
  name PreviewNode
  xpos -22
  ypos 8
  disable {{!parent.Enable3DPreview}}
 }
push $N541f9070
 Reformat {
  type "to box"
  box_width 100
  box_height 100
  box_fixed true
  scale 0.1
  resize none
  filter impulse
  black_outside true
  name Reformat3
  xpos -633
  ypos -1109
  disable {{!wire_type==1}}
 }
push $N54b96ea0
 Crop {
  box {0 0 {width} {height}}
  reformat true
  crop false
  name InputFormat
  xpos -456
  ypos -402
 }
end_group
TimeOffset {
 time_offset -1182
 time ""
 name TimeOffset6
 selected true
 xpos 10083
 ypos 32680
}
Dot {
 name Dot307
 selected true
 xpos 10117
 ypos 32962
}
FileOut {
 name FileOut5
 tile_color 0xbfbf00ff
 label 2DparticleFX_2
 selected true
 xpos 10083
 ypos 33010
 icon smartgrade.png
 channels rgba
 _destination /jobs
 _stemstatus ""
 file ""
 proxy ""
 fileProxy ""
 views {main}
 first 1001
 last 1400
 pbb true
 smart_grade on
 dw_compression_level 0
 tex_metadata "default metadata and exr/*"
 disable_autolabel_format true
 _defaults "\{'smart_grade': 0, 'compression': 1, 'tile_color': 3216965887, 'pbb': True, 'dw_compression_level': 0, 'label': u'2DparticleFX_2', 'exr_metadata': 2\}"
 _format ""
 _generator "NukeRenderGenerator dnnuke.core.render.v1"
 _ivyVals "\{'variant': None, 'host': None, 'versionNum': '3', 'twigType': 'spider://query@TwigType.one?TwigType.code==2d', 'twigNameTags': \{'subtask': u'precomp', 'task': u'comp', 'label': u'2DparticleFX_2', 'out_dir': u'ELEMENT'\}, 'job': 'STONE', 'stalk': None, 'stalkAttrs': \{'framerange': '1017-1053'\}, 'twig': None, 'stem': 'spider://query@Stem.one?Stem.dnuuid==cfb45239-1375-4623-b0a4-12b2a5fba3d0&Stem.stemname==110_fof_0010&Stem.stemtype==shot'\}"
 _old_filetype exr
 _stalkname E_110_fof_0010_comp_precomp_2DparticleFX_2_v003
 _twigtype 2d
 _wrapper "FileOut dnnuke.nodes.file_out.wrapper"
 beforeRender ""
 beforeFrameRender ""
 afterFrameRender ""
 afterRender ""
 renderProgress ""
 _invert_grade /tools/STONE/ivyasset/110_fof_0010/ivy/grade/GRD_110_fof_0010_neutral_v001/GRD_110_fof_0010_neutral_v001.grade
}
BagAndTagKeep {
 name BagAndTagKeep11
 selected true
 xpos 10083
 ypos 33122
}
Read {
 inputs 0
 file_type exr
 file /jobs/JOYRIDE/hap0850/ELEMENT/E_hap0850_comp_precomp_2DparticleFX_2_v003/2156x1806/E_hap0850_comp_precomp_2DparticleFX_2_v003.####.exr
 localizationPolicy off
 format "2156 1806 0 0 2156 1806 2 JOYRIDE Working"
 proxy_format "640 480 0 0 640 480 1 PC_Video"
 first 1001
 last 1400
 origfirst 1001
 origlast 1400
 origset true
 smartGrade true
 name Read269
 selected true
 xpos 10090
 ypos 33213
 postage_stamp_frame 1200
 addUserKnob {20 Ivy}
 addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.toolbox.v1.nodes.docs', fromlist=\['open_docs_name']).open_docs_name('IvyTab')" +STARTLINE}
 addUserKnob {26 divider4 l "" +STARTLINE}
 addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
 _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
 addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
 addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
 _ivyFile /jobs/JOYRIDE/hap0850/ELEMENT/E_hap0850_comp_precomp_2DparticleFX_2_v003/2156x1806/E_hap0850_comp_precomp_2DparticleFX_2_v003.####.exr
 addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
 _expressions {{curve}}
 addUserKnob {26 divider0 l "" +STARTLINE}
 addUserKnob {20 dbinfo l "DB Info" n 1}
 dbinfo 0
 addUserKnob {1 twig_dnuuid l "Twig Id"}
 twig_dnuuid 776d86dd-5bde-4453-9885-d4e475541d96
 addUserKnob {1 stalk_dnuuid l "Stalk Id"}
 stalk_dnuuid c5999af3-68a2-4d10-9b51-0013934c02c6
 addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
 twigtype_dnuuid e9f824fa-c932-4c3e-acbd-c612fb5ea846
 addUserKnob {1 leaf_dnuuid l "Leaf Id"}
 leaf_dnuuid bdbf5872-f813-453c-bb94-28a817852a06
 addUserKnob {26 divider1 l "" +STARTLINE}
 addUserKnob {1 twigtype l "Twig Type"}
 twigtype elmr
 addUserKnob {1 leaf_label l Leaf}
 leaf_label main_proxy0
 addUserKnob {1 ivy_version l Version}
 ivy_version 3
 addUserKnob {43 ivy_notes l Notes}
 addUserKnob {26 divider2 l "" +STARTLINE}
 addUserKnob {1 build_label l "Build Label"}
 addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
}
BagAndTagKeep {
 name BagAndTagKeep12
 selected true
 xpos 10090
 ypos 33366
}
push $cut_paste_input
Camera2 {
 translate {5 0.1 0.07756583}
 rotate {0 87.69209641 0}
 name Camera15
 selected true
 xpos 11271
 ypos 32602
 addUserKnob {20 Ivy}
 addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.toolbox.v1.nodes.docs', fromlist=\['open_docs_name']).open_docs_name('IvyTab')" +STARTLINE}
 addUserKnob {26 divider4 l "" +STARTLINE}
 addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
 _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
 addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
 addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
 addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
 _expressions {{curve}}
 addUserKnob {26 divider0 l "" +STARTLINE}
 addUserKnob {20 dbinfo l "DB Info" n 1}
 dbinfo 0
 addUserKnob {1 twig_dnuuid l "Twig Id"}
 addUserKnob {1 stalk_dnuuid l "Stalk Id"}
 addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
 addUserKnob {1 leaf_dnuuid l "Leaf Id"}
 addUserKnob {26 divider1 l "" +STARTLINE}
 addUserKnob {1 twigtype l "Twig Type"}
 addUserKnob {1 leaf_label l Leaf}
 addUserKnob {1 ivy_version l Version}
 addUserKnob {43 ivy_notes l Notes}
 addUserKnob {26 divider2 l "" +STARTLINE}
 addUserKnob {1 build_label l "Build Label"}
 addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
}
Group {
 inputs 0
 name Point_Grid5
 tile_color 0x434343ff
 note_font_color 0x7dadf9ff
 selected true
 xpos 11241
 ypos 32107
 addUserKnob {20 User}
 addUserKnob {26 text l "" +STARTLINE T "Point Grid v1.0\n\nThis node generates a grid.\nAs it is defined in a non-euclidian space, \nmost of the shaders and wire or facet rendering won't work. "}
 addUserKnob {26 ""}
 addUserKnob {41 size_x l "Number of Points" T CONTROLER.size_x}
 addUserKnob {41 size_y l "" -STARTLINE T CONTROLER.size_y}
 addUserKnob {41 size_z l "" -STARTLINE T CONTROLER.size_z}
 addUserKnob {18 Position}
 Position {0 0 0}
 addUserKnob {6 Position_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Position_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Position_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {18 Scale}
 Scale {3 5 3}
 addUserKnob {6 Scale_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Scale_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Scale_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
}
 NoOp {
  inputs 0
  name CONTROLER
  xpos 224
  ypos -62
  addUserKnob {20 User}
  addUserKnob {3 VoxelDensity}
  VoxelDensity {{ceil(pow(size_x*size_y*size_z,1/3))}}
  addUserKnob {3 size_x l "Voxel Grid Size"}
  size_x 140
  addUserKnob {3 size_y l "" -STARTLINE}
  size_y 100
  addUserKnob {3 size_z l "" -STARTLINE}
  size_z 130
 }
 Crop {
  inputs 0
  box {0 0 {ceil(sqrt(pow(parent.CONTROLER.VoxelDensity,3)))} {sqrt(pow(parent.CONTROLER.VoxelDensity,3))}}
  reformat true
  crop false
  name Crop3
  xpos 372
  ypos -108
 }
 BlinkScript {
  recompileCount 9
  ProgramGroup 1
  KernelDescription "2 \"InvertKernel\" iterate pixelWise 21048e0522d3524e03cb582229852f2e33dbe569cd86686b92f460148f8700cf 2 \"src\" Read Point \"dst\" Write Point 1 \"Cube Size\" Int 3 IAAAACAAAAAgAAAAAAAAAA== 1 \"cube_size\" 3 1 0"
  kernelSource "kernel InvertKernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;  \n  Image<eWrite> dst;\n\n  param:\n    int3 cube_size;\n\n  local:\n    \n\n  void define() \{\n    defineParam(cube_size, \"Cube Size\", int3(32,32,32));\n  \}\n\n  void init() \{\n    \n  \}\n\n  void process(int2 pos) \{\n    int t_offset = (pos.x+(pos.y*src.bounds.width()));\n    float4 position;\n    float maxSize = max(max(cube_size.x,cube_size.y),cube_size.z);\n\n    position.x = fmod(t_offset,cube_size.x)/float(cube_size.x-1);\n    position.y = fmod(int(t_offset/cube_size.x),cube_size.y)/float(cube_size.y-1);\n    position.z = fmod(int(t_offset/(cube_size.x*cube_size.y)),cube_size.z)/float(cube_size.z-1);\n    position.w = 1-min(fmod(int(t_offset/(cube_size.x*cube_size.y*cube_size.z)),maxSize),1.0f);\n\n    dst() = float4(position.x*position.w,position.y*position.w,position.z*position.w,position.w);\n   \}\n\};\n\n"
  rebuild ""
  "InvertKernel_Cube Size" {{parent.CONTROLER.size_x} {parent.CONTROLER.size_y} {parent.CONTROLER.size_z}}
  rebuild_finalise ""
  name BlinkScript8
  selected true
  xpos 372
  ypos -79
 }
 Grade {
  add -0.5
  black_clamp false
  name Grade1
  xpos 372
  ypos -47
 }
 Grade {
  white {{parent.Scale.r} {parent.Scale.g} {parent.Scale.b} 0.9}
  add {{parent.Position.r} {parent.Position.g} {parent.Position.b} 0}
  black_clamp false
  name Grade2
  xpos 372
  ypos -26
 }
 Shuffle {
  red white
  green white
  blue white
  black red
  white green
  red2 blue
  green2 alpha
  out2 pos
  name Shuffle1
  xpos 372
  ypos -2
 }
 ModifyMetaData {
  metadata {
   {set pointrender/n_points "\[expr \[value parent.size_x]*\[value parent.size_y] *\[value parent.size_z]]"}
   {set pointrender/gen_type 3}
  }
  name SetMetaData
  xpos 372
  ypos 22
 }
 Grade {
  white {{1/((parent.size_x*parent.size_y*parent.size_z)/200000)}}
  black_clamp false
  name Grade9
  xpos 372
  ypos 46
 }
 Crop {
  box {0 0 {ceil(sqrt(pow(parent.CONTROLER.VoxelDensity,3)))} {sqrt(pow(parent.CONTROLER.VoxelDensity,3))}}
  crop false
  name Crop1
  xpos 372
  ypos 70
 }
 Output {
  name Output1
  xpos 372
  ypos 149
 }
end_group
Group {
 name Fractal3
 tile_color 0x434343ff
 note_font_color 0x7dadf9ff
 selected true
 xpos 11241
 ypos 32177
 addUserKnob {20 User t test}
 addUserKnob {26 _1 l "" +STARTLINE T "Point Fractal 1.0\n"}
 addUserKnob {26 devider_noise l "<b><font color=#7DADF9>Noise Settings</font><b>"}
 addUserKnob {6 Noise_Absolute l Absolute t "Negative values in the noise offset is made positive." +STARTLINE}
 addUserKnob {3 Noise_Octaves l Octaves}
 Noise_Octaves 5
 addUserKnob {7 Noise_Gain l Gain}
 Noise_Gain 0.3
 addUserKnob {7 Noise_Lacunarity l Lacunarity R 0 4}
 Noise_Lacunarity 0.5
 addUserKnob {18 Amplitude}
 Amplitude 1.3
 addUserKnob {6 Amplitude_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Amplitude_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Amplitude_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Amplitude_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {3 Itterations}
 Itterations 5
 addUserKnob {26 invis_devider_noise l "" +STARTLINE T " "}
 addUserKnob {26 Devider_Frequency l "<b><font color=#7DADF9>Freq Control</font><b>"}
 addUserKnob {19 Freq_Offset l "General Offset" t "This is like a 3D translation, letting you move the current noise pattern in the X, Y, Z and W (4th dimention)" R 0 10}
 Freq_Offset {0 0 0 0}
 addUserKnob {6 Freq_Offset_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_Offset_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_Offset_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_Offset_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_Offset_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 Freq_GeneralScale l "Genral Scale" t "This lets you control the scale of each individual noise axis."}
 Freq_GeneralScale {1.1 1.1 1.1 1.2}
 addUserKnob {6 Freq_GeneralScale_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_GeneralScale_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_GeneralScale_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_GeneralScale_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_GeneralScale_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {26 invis_devider_freq l "" +STARTLINE T " "}
 addUserKnob {19 Freq_EvolveLow l "Evolve Low" t "This lets you evolve (auto animate) the noise in a particular direction. The \"Low\" part means that this only affects the low frequencies.\n\nTo avoid a \"scrolling\" effect you can use the 4th dimention to break up the spatial cohearence." R 0 10}
 Freq_EvolveLow {2 0 0 0.5}
 addUserKnob {6 Freq_EvolveLow_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveLow_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveLow_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveLow_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveLow_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleLow_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 Freq_EvolveHigh l "Evolve High" t "This lets you evolve (auto animate) the noise in a particular direction. The \"High\" part means that this only affects the high frequencies.\n\nTo avoid a \"scrolling\" effect you can use the 4th dimention to break up the spatial cohearence."}
 Freq_EvolveHigh {0.9 0 -1 1}
 addUserKnob {6 Freq_EvolveHigh_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveHigh_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveHigh_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveHigh_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveHigh_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {26 invis_devider_freq2 l "" +STARTLINE T " "}
 addUserKnob {19 Freq_ScaleLow l "Scale Low" t "This lets you scale the noise in a particular axis. The \"Low\" part means that this only affects the low frequencies."}
 Freq_ScaleLow {1.7 1.7 1.7 2}
 addUserKnob {6 Freq_ScaleLow_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleLow_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleLow_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleLow_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleLow_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 Freq_ScaleHigh l "Scale High" t "This lets you scale the noise in a particular axis. The \"High\" part means that this only affects the high frequencies."}
 Freq_ScaleHigh {3 3 3 3}
 addUserKnob {6 Freq_ScaleHigh_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleHigh_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleHigh_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleHigh_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleHigh_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {26 invis_devider_freq3 l "" +STARTLINE T " "}
 addUserKnob {26 Curve l "<b><font color=#7DADF9>Curve Noise</font><b>"}
 addUserKnob {6 CurveNoise_Enable l Enable t "Adds a gamma curve to the noise intensity making noise near the \"Offset\" value more flat. This is a experimental feature." +STARTLINE}
 addUserKnob {6 CurveNoise_Invert l Invert t "Inverts the effect of the curved noise." -STARTLINE}
 addUserKnob {7 CurveGain l "Curve Gain" R -10 10}
 CurveGain 2
 addUserKnob {7 CurveOffset R -2 2}
 addUserKnob {26 gabgen l "" +STARTLINE T "\n"}
 addUserKnob {26 info_mask l "<b><font color=#7DADF9>Mask</font><b>"}
 addUserKnob {41 maskChannelMask l "" t "If a node is connected to the mask input, this will let you mask off the effect of the noise.\nIts recommended that you use the Point_Texture node to ensure a correct aspect and size." -STARTLINE T Merge1.maskChannelMask}
 addUserKnob {41 inject -STARTLINE T Merge1.inject}
 addUserKnob {41 invert_mask l invert -STARTLINE T Merge1.invert_mask}
 addUserKnob {41 fringe -STARTLINE T Merge1.fringe}
 addUserKnob {41 mix T Merge1.mix}
}
 Input {
  inputs 0
  name InputMask
  xpos -714
  ypos 207
  number 1
 }
 Reformat {
  type "to box"
  box_width {{parent.InputFormat.box.r}}
  box_height {{parent.InputFormat.box.t}}
  box_fixed true
  resize distort
  name Reformat2
  xpos -714
  ypos 306
 }
 Shuffle {
  name Shuffle3
  xpos -714
  ypos 330
 }
 Input {
  inputs 0
  name InputData
  xpos -582
  ypos 73
 }
 Dot {
  name Dot1
  xpos -548
  ypos 114
 }
set N55eed1f0 [stack 0]
 Shuffle {
  in pos
  name Shuffle1
  xpos -470
  ypos 110
 }
 BlinkScript {
  kernelSourceFile /Users/madshagbarth/Github/Nuke-Private/Blink/PointRender/Modify/Fractal_v06.cpp
  recompileCount 60
  ProgramGroup 1
  KernelDescription "2 \"Noise4D\" iterate pixelWise d54284af3e5573ad197bef9032773e8653de2cad590694fcc9fd5af993e97da3 2 \"src\" Read Point \"dst\" Write Point 17 \"absNoise\" Bool 1 AA== \"curveNoise\" Bool 1 AA== \"curveInvert\" Bool 1 AA== \"curveGain\" Float 1 AACAPw== \"curveOffset\" Float 1 AACAPw== \"Octaves\" Int 1 CgAAAA== \"Gain\" Float 1 AAAAPw== \"Lacunarity\" Float 1 AAAAQA== \"Gamma\" Float 1 AAAAPw== \"amplitude\" Float 3 AAAAPwAAAD8AAAA/AAAAAA== \"itterations\" Int 1 AQAAAA== \"Offset\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"Scale\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"suboffset\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"topoffset\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"subscale\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"topscale\" Float 4 AACAPwAAgD8AAIA/AACAPw== 17 \"absNoise\" 1 1 \"curveNoise\" 1 1 \"curveInvert\" 1 1 \"curveGain\" 1 1 \"curveOffset\" 1 1 \"octaves\" 1 1 \"gain\" 1 1 \"lacunarity\" 1 1 \"gamma\" 1 1 \"amplitude\" 3 1 \"itterations\" 1 1 \"offset\" 4 1 \"scale\" 4 1 \"suboffset\" 4 1 \"topoffset\" 4 1 \"subscale\" 4 1 \"topscale\" 4 1 0"
  kernelSource "//Based on https://github.com/Draradech/csworldgen/blob/master/simplexnoise.cpp\n//Ported by Mads Hagbarth Lund 2014\n\n/* Copyright (c) 2007-2012 Eliot Eshelman\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n\nint fastfloor( const float x ) \{ return x > 0 ? (int) x : (int) x - 1; \}\ninline float raw_noise_4d( const float x, const float y, const float z, const float w ) \n\{\nint simplex\[64]\[4] = \{\n    \{0,1,2,3\},\{0,1,3,2\},\{0,0,0,0\},\{0,2,3,1\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{1,2,3,0\},\n    \{0,2,1,3\},\{0,0,0,0\},\{0,3,1,2\},\{0,3,2,1\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{1,3,2,0\},\n    \{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\n    \{1,2,0,3\},\{0,0,0,0\},\{1,3,0,2\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{2,3,0,1\},\{2,3,1,0\},\n    \{1,0,2,3\},\{1,0,3,2\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{2,0,3,1\},\{0,0,0,0\},\{2,1,3,0\},\n    \{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\n    \{2,0,1,3\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{3,0,1,2\},\{3,0,2,1\},\{0,0,0,0\},\{3,1,2,0\},\n    \{2,1,0,3\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{3,1,0,2\},\{0,0,0,0\},\{3,2,0,1\},\{3,2,1,0\}\n\};\n    int perm\[512] = \{\n        151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,\n        8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,\n        35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,\n        134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,\n        55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208, 89,\n        18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,\n        250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,\n        189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,\n        172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,\n        228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,\n        107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,\n        138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180,\n\n        151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,\n        8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,\n        35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,\n        134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,\n        55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208, 89,\n        18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,\n        250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,\n        189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,\n        172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,\n        228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,\n        107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,\n        138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180\n    \};\n   int grad4\[32]\[4]= \{\n    \{0,1,1,1\},  \{0,1,1,-1\},  \{0,1,-1,1\},  \{0,1,-1,-1\},\n    \{0,-1,1,1\}, \{0,-1,1,-1\}, \{0,-1,-1,1\}, \{0,-1,-1,-1\},\n    \{1,0,1,1\},  \{1,0,1,-1\},  \{1,0,-1,1\},  \{1,0,-1,-1\},\n    \{-1,0,1,1\}, \{-1,0,1,-1\}, \{-1,0,-1,1\}, \{-1,0,-1,-1\},\n    \{1,1,0,1\},  \{1,1,0,-1\},  \{1,-1,0,1\},  \{1,-1,0,-1\},\n    \{-1,1,0,1\}, \{-1,1,0,-1\}, \{-1,-1,0,1\}, \{-1,-1,0,-1\},\n    \{1,1,1,0\},  \{1,1,-1,0\},  \{1,-1,1,0\},  \{1,-1,-1,0\},\n    \{-1,1,1,0\}, \{-1,1,-1,0\}, \{-1,-1,1,0\}, \{-1,-1,-1,0\}\n   \};\n    float F4 = (sqrt(5.0f)-1.0f)/4.0f;\n    float G4 = (5.0f-sqrt(5.0f))/20.0f;\n    float n0, n1, n2, n3, n4;\n    float s = (x + y + z + w) * F4;\n    int i = fastfloor(x + s);\n    int j = fastfloor(y + s);\n    int k = fastfloor(z + s);\n    int l = fastfloor(w + s);\n    float t = (i + j + k + l) * G4;\n    float X0 = i - t;\n    float Y0 = j - t;\n    float Z0 = k - t;\n    float W0 = l - t;\n\n    float x0 = x - X0;\n    float y0 = y - Y0;\n    float z0 = z - Z0;\n    float w0 = w - W0;\n    int c1 = (x0 > y0) ? 32 : 0;\n    int c2 = (x0 > z0) ? 16 : 0;\n    int c3 = (y0 > z0) ? 8 : 0;\n    int c4 = (x0 > w0) ? 4 : 0;\n    int c5 = (y0 > w0) ? 2 : 0;\n    int c6 = (z0 > w0) ? 1 : 0;\n    int c = c1 + c2 + c3 + c4 + c5 + c6;\n\n    int i1, j1, k1, l1;\n    int i2, j2, k2, l2;\n    int i3, j3, k3, l3;\n    i1 = simplex\[c]\[0]>=3 ? 1 : 0;\n    j1 = simplex\[c]\[1]>=3 ? 1 : 0;\n    k1 = simplex\[c]\[2]>=3 ? 1 : 0;\n    l1 = simplex\[c]\[3]>=3 ? 1 : 0;\n    i2 = simplex\[c]\[0]>=2 ? 1 : 0;\n    j2 = simplex\[c]\[1]>=2 ? 1 : 0;\n    k2 = simplex\[c]\[2]>=2 ? 1 : 0;\n    l2 = simplex\[c]\[3]>=2 ? 1 : 0;\n    i3 = simplex\[c]\[0]>=1 ? 1 : 0;\n    j3 = simplex\[c]\[1]>=1 ? 1 : 0;\n    k3 = simplex\[c]\[2]>=1 ? 1 : 0;\n    l3 = simplex\[c]\[3]>=1 ? 1 : 0;\n    float x1 = x0 - i1 + G4;\n    float y1 = y0 - j1 + G4;\n    float z1 = z0 - k1 + G4;\n    float w1 = w0 - l1 + G4;\n    float x2 = x0 - i2 + 2.0*G4;\n    float y2 = y0 - j2 + 2.0*G4;\n    float z2 = z0 - k2 + 2.0*G4;\n    float w2 = w0 - l2 + 2.0*G4;\n    float x3 = x0 - i3 + 3.0*G4;\n    float y3 = y0 - j3 + 3.0*G4;\n    float z3 = z0 - k3 + 3.0*G4;\n    float w3 = w0 - l3 + 3.0*G4;\n    float x4 = x0 - 1.0 + 4.0*G4;\n    float y4 = y0 - 1.0 + 4.0*G4;\n    float z4 = z0 - 1.0 + 4.0*G4;\n    float w4 = w0 - 1.0 + 4.0*G4;\n    int ii = i & 255;\n    int jj = j & 255;\n    int kk = k & 255;\n    int ll = l & 255;\n    int gi0 = perm\[ii+perm\[jj+perm\[kk+perm\[ll]]]] % 32;\n    int gi1 = perm\[ii+i1+perm\[jj+j1+perm\[kk+k1+perm\[ll+l1]]]] % 32;\n    int gi2 = perm\[ii+i2+perm\[jj+j2+perm\[kk+k2+perm\[ll+l2]]]] % 32;\n    int gi3 = perm\[ii+i3+perm\[jj+j3+perm\[kk+k3+perm\[ll+l3]]]] % 32;\n    int gi4 = perm\[ii+1+perm\[jj+1+perm\[kk+1+perm\[ll+1]]]] % 32;\n    float t0 = 0.6 - x0*x0 - y0*y0 - z0*z0 - w0*w0;\n    if(t0<0) n0 = 0.0;\n    else \{\n        t0 *= t0;\n        n0 = t0 * t0 * dot(float4(grad4\[gi0]\[0],grad4\[gi0]\[2],grad4\[gi0]\[3],grad4\[gi0]\[3]), float4(x0, y0, z0, w0));\n    \}\n    float t1 = 0.6 - x1*x1 - y1*y1 - z1*z1 - w1*w1;\n    if(t1<0) n1 = 0.0;\n    else \{\n        t1 *= t1;\n        n1 = t1 * t1 * dot(float4(grad4\[gi1]\[0],grad4\[gi1]\[2],grad4\[gi1]\[3],grad4\[gi1]\[3]), float4(x1, y1, z1, w1));\n    \}\n    float t2 = 0.6 - x2*x2 - y2*y2 - z2*z2 - w2*w2;\n    if(t2<0) n2 = 0.0;\n    else \{\n        t2 *= t2;\n        n2 = t2 * t2 * dot(float4(grad4\[gi2]\[0],grad4\[gi2]\[2],grad4\[gi2]\[3],grad4\[gi2]\[3]), float4(x2, y2, z2, w2));\n    \}\n    float t3 = 0.6 - x3*x3 - y3*y3 - z3*z3 - w3*w3;\n    if(t3<0) n3 = 0.0;\n    else \{\n        t3 *= t3;\n        n3 = t3 * t3 * dot(float4(grad4\[gi3]\[0],grad4\[gi3]\[2],grad4\[gi3]\[3],grad4\[gi3]\[3]), float4(x3, y3, z3, w3));\n    \}\n    float t4 = 0.6 - x4*x4 - y4*y4 - z4*z4 - w4*w4;\n    if(t4<0) n4 = 0.0;\n    else \{\n        t4 *= t4;\n        n4 = t4 * t4 * dot(float4(grad4\[gi4]\[0],grad4\[gi4]\[2],grad4\[gi4]\[3],grad4\[gi4]\[3]), float4(x4, y4, z4, w4));\n    \}\n    return 27.0 * (n0 + n1 + n2 + n3 + n4);\n\}\n\n\n\n\nkernel Noise4D : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n  Image<eWrite, eAccessPoint> dst;\nparam:\n    bool absNoise;\n    bool curveNoise;\n    bool curveInvert;\n    float curveGain;\n    float curveOffset;\n    int octaves;\n    float gain;\n    float lacunarity;\n    float gamma;\n    float3 amplitude;\n    int itterations;\n    float4 offset;\n    float4 scale;\n    float4 suboffset;\n    float4 topoffset;\n    float4 subscale;\n    float4 topscale;\n\n\n  void define() \{\n        defineParam (absNoise, \"absNoise\", false);    \n        defineParam (curveNoise, \"curveNoise\", false);    \n        defineParam (curveInvert, \"curveInvert\", false);   \n        defineParam (curveGain, \"curveGain\", 1.0f);\n        defineParam (curveOffset, \"curveOffset\", 1.0f);\n        defineParam (octaves, \"Octaves\", 10);\n        defineParam (gain, \"Gain\", 0.5f);\n        defineParam (lacunarity, \"Lacunarity\", 2.0f);\n        defineParam (gamma, \"Gamma\", 0.5f);\n        defineParam (amplitude, \"amplitude\", float3(0.5f));\n        defineParam (itterations, \"itterations\", 1);\n        defineParam(offset, \"Offset\", float4(0.0f, 0.0f, 0.0f,0.0f));\n        defineParam(scale, \"Scale\", float4(1.0f, 1.0f, 1.0f,1.0f));\n        defineParam(suboffset, \"suboffset\", float4(1.0f, 1.0f, 1.0f,1.0f));\n        defineParam(topoffset, \"topoffset\", float4(1.0f, 1.0f, 1.0f,1.0f));\n        defineParam(subscale, \"subscale\", float4(1.0f, 1.0f, 1.0f,1.0f));\n        defineParam(topscale, \"topscale\", float4(1.0f, 1.0f, 1.0f,1.0f));        \n  \}\n\nfloat octave_noise_4d( const float octaves, const float persistence, const float scale, const float x, const float y, const float z, const float w ) \n\{\n    float total = 0.0f;\n    float current;\n    float last = 1.0f;\n    float frequency = scale;\n    float amplitude = 1.0f;\n    float maxAmplitude = 0.0f;\n    float4 Tempoffset;\n    float4 Tempscale;\n\n\n    for( int i=0; i < octaves; i++ ) \{\n\n        /*\n        if (i == 0) \{\n            total += (float)raw_noise_4d( (x+suboffset.x) * frequency, (y+suboffset.y) * frequency, (z+suboffset.z) * frequency, (w+suboffset.w) * frequency ) * amplitude;\n        \}\n        else if (i == octaves-1) \{\n            total += (float)raw_noise_4d( (x+topoffset.x) * frequency, (y+topoffset.y) * frequency, (z+topoffset.z) * frequency, (w+topoffset.w) * frequency ) * amplitude;\n        \}\n        else \{\n            total += (float)raw_noise_4d( x * frequency, y * frequency, z * frequency, w * frequency ) * amplitude;\n        \}\n        */\n\n\n        Tempscale = (topscale * (i/(octaves-1.0f)))+(subscale * (1-(i/(octaves-1.0f))));       \n        Tempoffset = (topoffset * (i/(octaves-1.0f)))+(suboffset * (1-(i/(octaves-1.0f))));\n        current = (float)raw_noise_4d(   ((x*Tempscale.x)+Tempoffset.x) * frequency, \n                                        ((y*Tempscale.y)+Tempoffset.y) * frequency, \n                                        ((z*Tempscale.z)+Tempoffset.z) * frequency, \n                                        ((w*Tempscale.w)+Tempoffset.w) * frequency \n                                        ) * amplitude;\n        if (i == 0 && curveNoise)\{\n            if (curveInvert)\{\n                last = 0.5f-current;  \n            \}\n            else\{\n                last = current;  \n            \}\n               \n        \}\n        current = curveNoise?current*((last+curveOffset)*curveGain):current;\n        total += absNoise?fabs(current):current;\n        frequency *= 2.0f;\n        maxAmplitude += amplitude;\n        amplitude *= persistence;\n\n    \}\n    return float(total / maxAmplitude);\n\}\n\n\n\n\n  void process() \{\n    float4 srcSample = float4(src(0),src(1),src(2),src(3));\n    float sampleR,sampleG,sampleB;\n    for( int i=0; i < itterations; i++ ) \{\n        sampleR = (float)octave_noise_4d(float(octaves), gain, lacunarity, ( srcSample.x * scale.x ) + offset.x, ( srcSample.y * scale.y ) + offset.y,  ( srcSample.z * scale.z ) + offset.z, ( srcSample.w * scale.w ) + offset.w) * amplitude.x;\n        sampleG = (float)octave_noise_4d(float(octaves), gain, lacunarity, ( srcSample.x * scale.x ) + offset.x, ( srcSample.y * scale.y ) + offset.y,  ( srcSample.z * scale.z ) + offset.z, ( srcSample.w * scale.w ) + offset.w - 100.0f) * amplitude.y;\n        sampleB = (float)octave_noise_4d(float(octaves), gain, lacunarity, ( srcSample.x * scale.x ) + offset.x, ( srcSample.y * scale.y ) + offset.y,  ( srcSample.z * scale.z ) + offset.z, ( srcSample.w * scale.w ) + offset.w + 200.0f) * amplitude.z;\n        srcSample = float4(srcSample.x+sampleR,srcSample.y+sampleG,srcSample.z+sampleB,srcSample.w);\n    \}\n    dst() = float4(srcSample.x,srcSample.y,srcSample.z,1.0f);\n\}\n\};"
  rebuild ""
  Noise4D_curveNoise {{parent.CurveNoise_Enable}}
  Noise4D_curveInvert {{parent.CurveNoise_Invert}}
  Noise4D_curveGain {{parent.CurveGain}}
  Noise4D_curveOffset {{parent.CurveOffset}}
  Noise4D_Octaves {{parent.Noise_Octaves}}
  Noise4D_Gain {{parent.Noise_Gain}}
  Noise4D_Lacunarity {{parent.Noise_Lacunarity}}
  Noise4D_Gamma 0.79
  Noise4D_amplitude {{parent.Amplitude.r} {parent.Amplitude.g} {parent.Amplitude.b}}
  Noise4D_itterations {{parent.Itterations}}
  Noise4D_Offset {{parent.Freq_Offset} {parent.Freq_Offset} {parent.Freq_Offset} {parent.Freq_Offset}}
  Noise4D_Scale {{parent.Freq_GeneralScale} {parent.Freq_GeneralScale} {parent.Freq_GeneralScale} {parent.Freq_GeneralScale}}
  Noise4D_suboffset {{(frame*parent.Freq_EvolveLow.r)/50} {(frame*parent.Freq_EvolveLow.g)/50} {(frame*parent.Freq_EvolveLow.b)/50} {(frame*parent.Freq_EvolveLow.a)/50}}
  Noise4D_topoffset {{(frame*parent.Freq_EvolveHigh.r)/10} {(frame*parent.Freq_EvolveHigh.g)/10} {(frame*parent.Freq_EvolveHigh.b)/10} {(frame*parent.Freq_EvolveHigh.a)/10}}
  Noise4D_subscale {{parent.Freq_ScaleLow} {parent.Freq_ScaleLow} {parent.Freq_ScaleLow} {parent.Freq_ScaleLow}}
  Noise4D_topscale {{parent.Freq_ScaleHigh} {parent.Freq_ScaleHigh} {parent.Freq_ScaleHigh} {parent.Freq_ScaleHigh}}
  rebuild_finalise ""
  name Noise4D1
  selected true
  xpos -470
  ypos 177
 }
 Expression {
  expr0 abs(r)
  expr1 abs(g)
  expr2 abs(b)
  name Expression2
  xpos -470
  ypos 259
  disable {{!parent.Noise_Absolute}}
 }
 Shuffle {
  out pos
  name Shuffle2
  xpos -470
  ypos 330
 }
push $N55eed1f0
 Merge2 {
  inputs 2+1
  operation copy
  bbox B
  Achannels {pos.red pos.green pos.blue -pos.alpha}
  Bchannels {pos.red pos.green pos.blue -pos.alpha}
  output {pos.red pos.green pos.blue -pos.alpha}
  maskChannelMask -rgba.alpha
  name Merge1
  xpos -582
  ypos 326
 }
 Output {
  name Output1
  xpos -582
  ypos 497
 }
push $N55eed1f0
 Crop {
  box {0 0 {width} {height}}
  reformat true
  crop false
  name InputFormat
  xpos -713
  ypos 111
 }
end_group
set N579d4250 [stack 0]
Dot {
 name Dot308
 selected true
 xpos 11148
 ypos 32181
}
push $N579d4250
Dot {
 name Dot309
 selected true
 xpos 11275
 ypos 32358
}
Group {
 inputs 2
 name Point_OffsetShader3
 tile_color 0x434343ff
 note_font_color 0x55ffffff
 selected true
 xpos 11114
 ypos 32354
 addUserKnob {20 User}
 addUserKnob {26 info l "" +STARTLINE T "Point Offset Shader v1.0\n\nCalcualtes the distance between 2 point sets.\nThis can for example be used to see the difference between the original generator\nand the modified one."}
 addUserKnob {26 devider_general l "<b><font color=#70EE70>General</font><b>"}
 addUserKnob {7 Gain}
 Gain 3
 addUserKnob {7 Offset R -0.5 0.5}
 Offset -0.1
 addUserKnob {6 Absolute +STARTLINE}
 Absolute true
 addUserKnob {6 Reverse +STARTLINE}
}
 BackdropNode {
  inputs 0
  name BackdropNode1
  tile_color 0x388e8e00
  label Offset
  note_font_size 42
  xpos -591
  ypos 304
  bdwidth 224
  bdheight 161
 }
 Input {
  inputs 0
  name Input2
  xpos -438
  ypos 40
  number 1
 }
 Shuffle {
  in pos
  name Shuffle1
  xpos -438
  ypos 120
 }
 Dot {
  name Dot4
  xpos -404
  ypos 285
 }
 Dot {
  name Dot1
  xpos -404
  ypos 392
 }
 Input {
  inputs 0
  name Input1
  xpos -580
  ypos 50
 }
 Shuffle {
  in pos
  name Shuffle5
  xpos -580
  ypos 120
 }
 Dot {
  name Dot3
  xpos -546
  ypos 256
 }
 MergeExpression {
  inputs 2
  temp_name0 xd
  temp_expr0 A.red-B.red
  temp_name1 yd
  temp_expr1 A.green-B.green
  temp_name2 zd
  temp_expr2 A.blue-B.blue
  temp_name3 Distance
  temp_expr3 "sqrt(xd*xd + yd*yd + zd*zd)"
  expr0 Distance
  expr1 Distance
  expr2 Distance
  name Distance
  xpos -584
  ypos 388
 }
 Grade {
  add {{parent.Offset}}
  black_clamp false
  name Grade3
  xpos -584
  ypos 412
 }
 Grade {
  white {{parent.Gain}}
  black_clamp {{!parent.Absolute}}
  name Grade1
  xpos -584
  ypos 436
 }
 Expression {
  expr0 abs(r)
  expr1 abs(g)
  expr2 abs(b)
  name Expression1
  xpos -584
  ypos 459
  disable {{!parent.Absolute}}
 }
 Expression {
  expr0 max(0,1-r)
  expr1 max(0,1-r)
  expr2 max(0,1-r)
  name Expression2
  selected true
  xpos -584
  ypos 483
  disable {{!parent.Reverse}}
 }
 Group {
  name SoftLook_NF1
  xpos -584
  ypos 650
  disable true
  addUserKnob {20 User}
  addUserKnob {26 Info l "" +STARTLINE T "SoftLook\nby Mads Hagbarth Lund - 2016"}
  addUserKnob {26 ""}
  addUserKnob {7 Add R 0 4}
  Add 1.14
  addUserKnob {7 Offset R 0 4}
  Offset 0.86
 }
  Input {
   inputs 0
   name Input1
   xpos -248
   ypos 500
  }
set N47a1de20 [stack 0]
  Expression {
   expr0 r/(r+parent.Offset)*parent.Add
   expr1 g/(g+parent.Offset)*parent.Add
   expr2 b/(b+parent.Offset)*parent.Add
   expr3 a/(a+parent.Offset)*parent.Add
   name Expression1
   selected true
   xpos -339
   ypos 576
  }
push $N47a1de20
  ShuffleCopy {
   inputs 2
   red red
   green green
   blue blue
   alpha alpha2
   name ShuffleCopy1
   xpos -248
   ypos 576
  }
  Output {
   name Output1
   xpos -248
   ypos 651
  }
 end_group
 Output {
  name Output1
  xpos -584
  ypos 686
 }
end_group
Grade {
 white 1.3
 multiply {0.6887242198 0.9288096428 1 1}
 gamma {0.2101119161 0.3576882482 1 1}
 name Grade23
 selected true
 xpos 11114
 ypos 32500
}
Group {
 inputs 2
 name Point_Render6
 tile_color 0x434343ff
 note_font_color 0x7dadf9ff
 selected true
 xpos 11114
 ypos 32622
 addUserKnob {20 User l "Point Render" t dd}
 addUserKnob {26 info_header l "" +STARTLINE T "Point Render v1.0"}
 addUserKnob {26 devider_general l "<b><font color=#7DADF9>General</font><b>"}
 addUserKnob {4 RenderMode l "Render Mode" t "Some generators support multiple render modes other than just point rendering. This should be considered a experimental feature, but can be used to great effect.\n\nIn the Render Settings tab you can find more controls relating to Wire and Facet rendering modes.\n\nNote that Facet Render can be slow when really close to a object. " M {"Point Render" "Wire Render" "Facet Render (experimental)" "" "" ""}}
 addUserKnob {7 FocalLength l "Focal Length" t "The point render does not take the focal length from the input camera, so if you want to match it to a camera you should link the focal length from the camera to this." R 0 200}
 FocalLength 20
 addUserKnob {7 horizontalApeture l "Horiz Apeture" R 0 100}
 horizontalApeture 24.576
 addUserKnob {7 AlphaMultiplier l Exposure t "This is a general exposure modifier that lets you adjust the overall brightness of the render." R 0 2}
 AlphaMultiplier 0.15
 addUserKnob {6 UseOcclusionMap l "Use Occlusion Map" t "Enable the Occlusion map input. This lets you use a depth map as a holdout.\n\nNote:\nThe Red channal should contain the depth (absolute distance, not 1/depth)\nThe Alpha channal must be 1 for the areas that you want to holdout." +STARTLINE}
 addUserKnob {26 devider_cc l "<b><font color=#7DADF9>Preview</font><b>"}
 addUserKnob {6 FastPreview l "Fast Preview" t "Reduce the number of points for a quick preview of the final render." +STARTLINE}
 addUserKnob {6 HighlightCompression l "Hilight Compression" t "Compresses the highlights to make it easier to see bright details." +STARTLINE}
 addUserKnob {7 HighlightCeiling l "Highlight Ceiling" t "Adjust the cealing for the highlight compression." R 1 10}
 HighlightCeiling 1.15
 addUserKnob {7 Compression t "The compression amount." -STARTLINE R 0 5}
 Compression 1
 addUserKnob {26 devider_format l "<b><font color=#7DADF9>Format</font><b>"}
 addUserKnob {41 format l "output format" T Settings_Format.format}
 addUserKnob {20 WireRender l "Render Settings"}
 addUserKnob {26 devider_wirerender l "<b><font color=#7DADF9>Wire Rendering</font><b>"}
 addUserKnob {4 wire_type l "Connection Mode" t "*Normal\nConnect lines between the local neigbours of the 2d position map\n\n*Nearest\nConnect lines to the nearest points (in 3D space). This mode is limited to 100x100 points for performence reasons!" M {Normal Nearest "" "" "" "" "" "" "" ""}}
 addUserKnob {26 text l "Normal Mode Wires" T " "}
 addUserKnob {6 connect_x l x t "Connect wires in the (uv) X axis." -STARTLINE}
 connect_x true
 addUserKnob {6 connect_xy l xy t "Connect wires in the (uv) XY axis." -STARTLINE}
 connect_xy true
 addUserKnob {6 connect_y l y t "Connect wires in the (uv) Y axis." -STARTLINE}
 connect_y true
 addUserKnob {6 connect_aux l aux t "If you input a vector map into the Aux input for this node, and enable this option, you will get a wire from each point along that vector." -STARTLINE}
 addUserKnob {7 wire_maxdistance l "Max Distance" t "The maximum distance that the wires connect." R 0 10}
 wire_maxdistance 6
 addUserKnob {7 wire_Threshold l "Distance Threshold" t "Control the max distance threshold" R 0 2}
 wire_Threshold 0.5
 addUserKnob {3 wire_connections l "Max Connections" t "The maximum number of connections (Not Yet Implemented)"}
 wire_connections 4
 addUserKnob {7 maxSamples l "Max Line Samples" t "The maximum length of a line. Once a line is longer than this, it will start break up. \nThis can also be used as a creative effect if you set it low, try setting it to 10 in wire mode to get dotted lines" R 0 10000}
 maxSamples 10000
 addUserKnob {7 lineoffset l "Line Offset" t "Expand or contract the lines."}
 lineoffset 1
 addUserKnob {7 inGain l "In Gain" t "Gain the brightness of the in-point of the lines"}
 inGain 1
 addUserKnob {7 outGain l "Out Gain" t "Gain the brightness of the out-point of the lines" -STARTLINE}
 outGain 1
 addUserKnob {26 devider_facet l "<b><font color=#7DADF9>Facet Rendering</font><b>"}
 addUserKnob {4 renderMode l "Render Mode" t "Pick the desidered render mode." M {Diffuse "Local ST" Normal "Facing Ratio" UV ST "View Normal" "World Position" "" ""}}
 addUserKnob {6 facet_flatShading l "Flat Shading" t "Flat shading" +STARTLINE}
 addUserKnob {6 facet_depth l "Depth Buffer" t "Enable depth sorting to avoid additive surfaces." -STARTLINE}
 addUserKnob {6 facet_front l "Front Face" t "Render front facing facets" +STARTLINE}
 facet_front true
 addUserKnob {6 facet_backface l "Back Face" t "Render backfacing faces" -STARTLINE}
 facet_backface true
 addUserKnob {26 _1 l "<b><font color=#7DADF9>Other</font><b>"}
 addUserKnob {6 CloseX l "Close X" t "On spheres or round objects this closes the loop" +STARTLINE}
 addUserKnob {6 CloseY l "Close Y" t "On spheres or round objects this closes the loop" -STARTLINE}
 addUserKnob {20 Fog_1 l Fog}
 addUserKnob {26 Devider_Fog l "<b><font color=#7DADF9>Fog</font><b>"}
 addUserKnob {6 Fog t "Fog reduces the brightness of poins far from the camera." +STARTLINE}
 addUserKnob {7 FogNear l "Fog Near" R 0 200}
 FogNear 3
 addUserKnob {7 FogFar l "Fog Far" R 0 200}
 FogFar 10
 addUserKnob {7 FogExponent l "Fog Exponent" R 0 8}
 FogExponent 8
 addUserKnob {20 DepthOfField l "Depth of Field"}
 addUserKnob {26 devider_dof l "<b><font color=#7DADF9>Depth Of Field</font><b>"}
 addUserKnob {6 dof_enable l Enable +STARTLINE}
 addUserKnob {7 dof_focaldepth l "Focal Depth" R 0 40}
 dof_focaldepth 5
 addUserKnob {7 dof_dof l "Depth of Field" R 0 10}
 dof_dof 2
 addUserKnob {7 dof_maxSize l "Max Size"}
 dof_maxSize 0.5
 addUserKnob {7 dof_Aspect l "Aspect Ratio"}
 dof_Aspect 1
 addUserKnob {7 dof_bias l Bias R -3 3}
 dof_bias -0.2
 addUserKnob {4 Dof_Quality l Quality M {Low Medium High Extreme}}
 addUserKnob {20 MotionBlur}
 addUserKnob {26 devider_MotionBlur l "<b><font color=#7DADF9>Motion Blur</font><b>"}
 addUserKnob {6 mb_enable l Enable +STARTLINE}
 mb_enable true
 addUserKnob {6 Fast l "Fast (Interpolated)" -STARTLINE}
 Fast true
 addUserKnob {3 Samples}
 Samples 4
 addUserKnob {7 Shutter R 0 2}
 Shutter 0.5
 addUserKnob {4 pulldown l "Shutter Offset" M {Centered Start End ""}}
 addUserKnob {20 preview_3d l "3D Preview"}
 addUserKnob {6 Enable3DPreview l "Enable 3D Preview" t "Display a preview of the points in the Nuke 3D view." +STARTLINE}
 addUserKnob {41 pointSize l "point size" T PreviewNode.pointSize}
 addUserKnob {41 detail l "point detail" T PreviewNode.detail}
}
 BackdropNode {
  inputs 0
  name BackdropNode1
  tile_color 0x388e8e00
  label "Output Format Manager"
  note_font_size 22
  xpos -1491
  ypos 149
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode10
  tile_color 0x388e8e00
  label "AUX Input"
  note_font_size 22
  xpos -385
  ypos 178
  bdwidth 207
  bdheight 178
 }
 BackdropNode {
  inputs 0
  name BackdropNode11
  tile_color 0x388e8e00
  label "Point Render"
  note_font_size 22
  xpos -96
  ypos 99
  bdwidth 198
  bdheight 135
 }
 BackdropNode {
  inputs 0
  name BackdropNode12
  tile_color 0x388e8e00
  label "Normal Generator\nFor Vertex Normals"
  note_font_size 22
  xpos -616
  ypos 243
  bdwidth 191
  bdheight 122
 }
 BackdropNode {
  inputs 0
  name BackdropNode13
  tile_color 0x388e8e00
  label "Ensure output format"
  note_font_size 22
  xpos -622
  ypos -41
  bdwidth 198
  bdheight 135
 }
 BackdropNode {
  inputs 0
  name BackdropNode14
  tile_color 0x388e8e00
  label "Motion Blur"
  note_font_size 22
  xpos -85
  ypos 526
  bdwidth 193
  bdheight 91
 }
 BackdropNode {
  inputs 0
  name BackdropNode15
  tile_color 0x388e8e00
  label "Soft Preview"
  note_font_size 22
  xpos -83
  ypos 414
  bdwidth 191
  bdheight 94
 }
 BackdropNode {
  inputs 0
  name BackdropNode16
  tile_color 0x388e8e00
  label "Final format"
  note_font_size 22
  xpos -84
  ypos 295
  bdwidth 192
  bdheight 95
 }
 BackdropNode {
  inputs 0
  name BackdropNode17
  tile_color 0x388e8e00
  label "No Clue =)"
  note_font_size 22
  xpos -385
  ypos -41
  bdwidth 160
  bdheight 87
 }
 BackdropNode {
  inputs 0
  name BackdropNode2
  tile_color 0x388e8e00
  label Motionblur
  note_font_size 22
  xpos -672
  ypos -781
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode3
  tile_color 0x388e8e00
  label "Fast Preview"
  note_font_size 22
  xpos -669
  ypos -971
  bdwidth 254
  bdheight 138
 }
 BackdropNode {
  inputs 0
  name BackdropNode4
  tile_color 0x388e8e00
  label "Nearest Wire Mode Clamp"
  note_font_size 22
  xpos -666
  ypos -1184
  bdwidth 253
  bdheight 111
 }
 BackdropNode {
  inputs 0
  name BackdropNode5
  tile_color 0x388e8e00
  label Occlution
  note_font_size 22
  xpos 208
  ypos 27
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode6
  tile_color 0x388e8e00
  label "Input Camera Container"
  note_font_size 22
  xpos -1215
  ypos 148
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode7
  tile_color 0x388e8e00
  label "3D Preview"
  note_font_size 22
  xpos -88
  ypos -45
  bdwidth 207
  bdheight 102
 }
 BackdropNode {
  inputs 0
  name BackdropNode8
  tile_color 0x388e8e00
  label "Input Format Manager"
  note_font_size 22
  xpos -526
  ypos -459
  bdwidth 208
  bdheight 97
 }
 BackdropNode {
  inputs 0
  name BackdropNode9
  tile_color 0x388e8e00
  label FOG
  note_font_size 22
  xpos -602
  ypos -253
  bdwidth 370
  bdheight 152
 }
 Input {
  inputs 0
  name InputPointData
  xpos -584
  ypos -1321
 }
 Dot {
  name Dot4
  xpos -550
  ypos -1234
 }
set N46df5350 [stack 0]
 Reformat {
  type "to box"
  box_width 100
  box_height 100
  box_fixed true
  scale 0.1
  resize fill
  filter impulse
  black_outside true
  name Reformat5
  xpos -584
  ypos -906
  disable {{!parent.FastPreview==1}}
 }
 Grade {
  white 10
  name Grade2
  xpos -584
  ypos -874
  disable {{!parent.FastPreview}}
 }
 Dot {
  name Dot2
  xpos -550
  ypos -712
 }
set N46e1a7a0 [stack 0]
 Group {
  name FrameHold3
  tile_color 0xb0a45dff
  label "(frame \[value first_frames])"
  xpos -501
  ypos -719
  disable {{1-parent.mb_enable}}
  addUserKnob {20 User}
  addUserKnob {3 first_frames l "first frame"}
  first_frames {{frame+1}}
  addUserKnob {41 increment T FrameHold2.increment}
  addUserKnob {22 SetCurrentFrame l "Set This Frame" T "nuke.thisNode()\[\"first_frames\"].setValue(nuke.frame())" +STARTLINE}
 }
  Input {
   inputs 0
   name Input1
   xpos -7
   ypos -154
  }
  FrameHold {
   first_frame {{parent.knob.first_frames}}
   name FrameHold2
   xpos -7
   ypos -114
  }
  Output {
   name Output1
   xpos -7
   ypos -14
  }
 end_group
 Dot {
  name Dot6
  xpos -467
  ypos -659
 }
push $N46e1a7a0
 Group {
  name FrameHold2
  tile_color 0xb0a45dff
  label "(frame \[value first_frames])"
  xpos -660
  ypos -719
  disable {{1-parent.mb_enable}}
  addUserKnob {20 User}
  addUserKnob {3 first_frames l "first frame"}
  first_frames {{frame}}
  addUserKnob {41 increment T FrameHold2.increment}
  addUserKnob {22 SetCurrentFrame l "Set This Frame" T "nuke.thisNode()\[\"first_frames\"].setValue(nuke.frame())" +STARTLINE}
 }
  Input {
   inputs 0
   name Input1
   xpos -7
   ypos -154
  }
  FrameHold {
   first_frame {{parent.knob.first_frames}}
   name FrameHold2
   xpos -7
   ypos -114
  }
  Output {
   name Output1
   xpos -7
   ypos -14
  }
 end_group
 Dot {
  name Dot5
  xpos -626
  ypos -659
 }
 Dissolve {
  inputs 2
  which {{frame-floor(frame)}}
  name Dissolve1
  xpos -582
  ypos -666
  disable {{1-parent.mb_enable}}
 }
push $N46e1a7a0
 Switch {
  inputs 2
  which {{parent.Fast}}
  name Switch2
  xpos -582
  ypos -619
 }
 Dot {
  name DataFetch
  label "data fetch\t"
  note_font_color 0xff21ff
  xpos -550
  ypos -513
  addUserKnob {20 User}
  addUserKnob {3 n_particles l "Number of Particles"}
  n_particles {{"\[metadata pointrender/n_points]"}}
  addUserKnob {3 gentype l "Type Of Generator"}
  gentype {{"\[metadata pointrender/gen_type]"}}
  addUserKnob {26 info l "" -STARTLINE T "0 = unknown, 1 = Card, 2 = Sphere, 3 = Grid"}
 }
set N68147040 [stack 0]
 Dot {
  name Dot3
  xpos -635
  ypos -513
 }
 Dot {
  name Dot1
  xpos -635
  ypos 676
 }
 Input {
  inputs 0
  name InputOcclution
  xpos 238
  ypos 75
  number 2
 }
 Constant {
  inputs 0
  channels rgb
  color 1
  name Empty
  xpos 371
  ypos 139
 }
 Switch {
  inputs 2
  which {{parent.UseOcclusionMap}}
  name Switch1
  xpos 238
  ypos 163
 }
 Input {
  inputs 0
  name Aux
  xpos -324
  ypos 214
  number 3
 }
 Reformat {
  type "to box"
  format "1280 720 0 0 1280 720 1 HD_720"
  box_width {{input.width>Settings_Format.format.width?input.width:Settings_Format.format.width}}
  box_height {{input.height>Settings_Format.format.height?input.height:Settings_Format.format.height}}
  box_fixed true
  resize none
  center false
  filter impulse
  black_outside true
  name Reformat2
  xpos -324
  ypos 238
 }
 Crop {
  box {0 0 {input.width} {input.height}}
  name Crop1
  xpos -324
  ypos 275
 }
push $N68147040
 Shuffle {
  in pos
  name Shuffle1
  xpos -584
  ypos -192
 }
set N548efec0 [stack 0]
 Reformat {
  type "to box"
  format "1280 720 0 0 1280 720 1 HD_720"
  box_width {{input.width>Settings_Format.format.width?input.width:Settings_Format.format.width}}
  box_height {{input.height>Settings_Format.format.height?input.height:Settings_Format.format.height}}
  box_fixed true
  resize none
  center false
  filter impulse
  black_outside true
  name Reformat4
  xpos -584
  ypos 18
 }
 Crop {
  box {0 0 {input.width} {input.height}}
  name Crop2
  xpos -584
  ypos 48
 }
 Dot {
  name Dot8
  xpos -550
  ypos 166
 }
set N5491adf0 [stack 0]
 Group {
  name Point_Normal2
  tile_color 0x434343ff
  note_font_color 0x55ffffff
  xpos -584
  ypos 311
  disable {{!(renderMode==2&&RenderMode==2)}}
  addUserKnob {20 User}
  addUserKnob {26 info l "" +STARTLINE T "Point Normal v1.0"}
  addUserKnob {26 devider_general l "<b><font color=#7DADF9>General</font><b>"}
  addUserKnob {26 info_1 l "" +STARTLINE T "well, not much to do here =)"}
 }
  Input {
   inputs 0
   name Input1
   xpos 389
   ypos 207
  }
  Shuffle {
   in pos
   name Shuffle1
   xpos 389
   ypos 294
  }
  BlinkScript {
   kernelSourceFile /Users/madshagbarth/Github/Nuke-Private/Blink/PointRender/Modify/BasicLight.cpp
   recompileCount 69
   ProgramGroup 1
   KernelDescription "2 \"PointRender3D\" iterate pixelWise d5452fe7b684561fcfa5182d0c789025a037cc4fe4474c24e065e3fa53fcd8ce 2 \"ppos\" Read Random \"dst\" Write Point 9 \"cam_Matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== \"focallength\" Float 1 AAA4QQ== \"hapeture\" Float 1 ppvEQQ== \"format\" Int 2 AAgAAAAIAAA= \"Zoom\" Float 1 AACAPw== \"half Lambert\" Bool 1 AQ== \"light Mode\" Int 1 AAAAAA== \"light_position\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"light_color\" Float 3 AACAPwAAgD8AAIA/AAAAAA== 9 \"cam_Matrix\" 16 1 \"cam_Focal\" 1 1 \"cam_Hapeture\" 1 1 \"WHformat\" 2 1 \"zoom\" 1 1 \"halfLambert\" 1 1 \"lightMode\" 1 1 \"lightPos\" 3 1 \"lightcolor\" 3 1 10 \"vRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"pRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"tRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"vWorld\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"canvasWidth\" Float 1 1 AAAAAA== \"canvasHeight\" Float 1 1 AAAAAA== \"matrixData\" Float 1 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cameraToWorld\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"worldToCamera\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"namount\" Float 1 1 AAAAAA=="
   kernelSource "inline float Frac(float a_X)\n\{\n    return a_X-floor(a_X);\n\}\n\ninline float Fmax(float a_X,float b_X,float c_X)\n\{\n    return max(c_X,max(a_X,b_X));\n\}\ninline float Fmin(float a_X,float b_X,float c_X)\n\{\n    return min(c_X,min(a_X,b_X));\n\}\n\ninline float saturate(float _in)\n\{\n    return max(0.0f,min(1.0f,_in));\n\}\n\ninline float3 reflect(float3 incidence,float3 normal)\n\{\n  return incidence - 2.f * dot(incidence, normal) * normal;\n\}\n\n//This function is used to multiply a float3 by a matrix4x4\ninline float3 multVecMatrix( float3 src, float4x4 matrix)\n\{\n    float   x,y,z,w;\n    \n    x = src\[0]*matrix\[0]\[0] + src\[1]*matrix\[1]\[0] +\n    src\[2]*matrix\[2]\[0] + matrix\[3]\[0];\n    y = src\[0]*matrix\[0]\[1] + src\[1]*matrix\[1]\[1] +\n    src\[2]*matrix\[2]\[1] + matrix\[3]\[1];\n    z = src\[0]*matrix\[0]\[2] + src\[1]*matrix\[1]\[2] +\n    src\[2]*matrix\[2]\[2] + matrix\[3]\[2];\n    w = src\[0]*matrix\[0]\[3] + src\[1]*matrix\[1]\[3] +\n    src\[2]*matrix\[2]\[3] + matrix\[3]\[3];\n    \n    return float3(x/w, y/w, z/w);\n\}\n\n//This function is used to calculate the screenspace coordinates.\ninline bool computePixelCoordinates( \n    const float3 pWorld, \n    float3 &pRaster, \n    const float4x4 &worldToCamera, \n    const float &canvasWidth, \n    const float &canvasHeight, \n    const int &imageWidth, \n    const int &imageHeight\n) \n\{ \n    float3 pCamera; \n    pCamera = multVecMatrix(pWorld, worldToCamera); \n    float2 pScreen; \n    pScreen.x = pCamera.x / -pCamera.z; \n    pScreen.y = pCamera.y / -pCamera.z; \n    if (fabs(pScreen.x) > canvasWidth || fabs(pScreen.y) > canvasHeight) \n         return false; \n    float2 pNDC; \n    pNDC.x = (pScreen.x + canvasWidth * 0.5f) / canvasWidth; \n    pNDC.y = (pScreen.y + canvasHeight * 0.5f) / canvasHeight; \n    pRaster.x = (pNDC.x * imageWidth); \n    pRaster.y = ((pNDC.y) * imageHeight); \n    pRaster.z = -pCamera.z; \n    if (pRaster.x < 0.0f || pRaster.x > imageWidth || \n       pRaster.y < 0.0f || pRaster.y > imageHeight) \{\n       return false;  \n    \}\n    return true;\n\} \n\n\n\nkernel PointRender3D : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessRandom, eEdgeClamped> ppos;    //The point position map\n  Image<eWrite> dst;                 //the output image\n\n  param: //Parameters available to the user\n    float4x4 cam_Matrix;    //The world matrix of the camera\n    float cam_Focal;        //The focal length of the camera\n    float cam_Hapeture;     //The horizontal apeture of the camera\n    int2 WHformat;          //The format of the output image\n    float zoom;             //A \"post\" zoom function\n    bool halfLambert;\n    int lightMode;\n    float3 lightPos;\n    float3 lightcolor;\n\n\n  local: //Local variables\n    float3 vRaster;\n    float3 pRaster;\n    float3 tRaster;    \n    float3 vWorld;\n    float canvasWidth;\n    float canvasHeight; \n    float matrixData\[4]\[4];\n    float4x4 cameraToWorld;\n    float4x4 worldToCamera;\n    float namount; //dither amount\n\n\n  void define() \{\n    defineParam(cam_Matrix, \"cam_Matrix\", float4x4( 1.0f,0.0f,0.0f,0.0f,\n                                                    0.0f,1.0f,0.0f,0.0f,\n                                                    0.0f,0.0f,1.0f,0.0f,\n                                                    0.0f,0.0f,0.0f,1.0f));\n    defineParam(cam_Focal,      \"focallength\", 11.5f);\n    defineParam(cam_Hapeture,      \"hapeture\", 24.576f);\n    defineParam(WHformat,      \"format\", int2(2048,2048));\n    defineParam(zoom, \"Zoom\", 1.0f);\n    defineParam(halfLambert, \"half Lambert\", true);\n    defineParam(lightMode, \"light Mode\", 0);\n    defineParam(lightPos,      \"light_position\", float3(0,0,0));  \n    defineParam(lightcolor,      \"light_color\", float3(1.0,1.0,1.0)); \n  \}\n\n\n  //The init() function is run before any calls to process().\n  void init() \{\n    canvasWidth = ((cam_Hapeture)/cam_Focal);\n    canvasHeight = ((cam_Hapeture)/cam_Focal)*float(float(WHformat.y)/float(WHformat.x)); \n    float matrixData\[] = \{cam_Matrix\[0]\[0], cam_Matrix\[1]\[0], cam_Matrix\[2]\[0], cam_Matrix\[3]\[0], \n                          cam_Matrix\[0]\[1], cam_Matrix\[1]\[1], cam_Matrix\[2]\[1], cam_Matrix\[3]\[1], \n                          cam_Matrix\[0]\[2], cam_Matrix\[1]\[2], cam_Matrix\[2]\[2], cam_Matrix\[3]\[2], \n                          cam_Matrix\[0]\[3], cam_Matrix\[1]\[3], cam_Matrix\[2]\[3], cam_Matrix\[3]\[3]\};\n    cameraToWorld.setArray(matrixData); //This is a workaround. Due to the buggy matrix implementation, we pass the matrix on from another structure.\n    worldToCamera = cameraToWorld.invert();\n    namount = 0.0001; //dither amount\n  \}\n\n\n\nfloat3 Reconsile3D(float3 _PointPos)\{\n    vWorld = float3(_PointPos.x,_PointPos.y,_PointPos.z)*(zoom);\n    int ret = computePixelCoordinates(vWorld, tRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1]);\n    return tRaster;\n\}\n\n\n\n//-------------------------------------\n// Facet_Render\n//-------------------------------------\n//This function is used to calculate what triangels to draw\nfloat3 facet_render(int2 pos, float3 _vWorld)\{\n\n    float3 screen_pos = Reconsile3D(_vWorld);\n    bool insideX = ppos.bounds.inside(pos.x+1,pos.y );\n    bool insideY = ppos.bounds.inside(pos.x,pos.y-1 );\n    bool insideYtop = ppos.bounds.inside(pos.x,pos.y+1);\n    float2 fpos = float2(pos.x,pos.y);\n    float3 V1_Pos,V2_Pos,V1_wPos,V2_wPos;\n    float4 V0_Sample,V1_Sample,V2_Sample;\n    float3 normal0,normal1,normal2;\n\n    //for area calculation\n    float area;\n    float3 V0,V1,V2;\n    float3 output = float3(0.0f);\n  if (insideX) \{\n    V2_Sample = ppos(pos.x+1,pos.y);\n    V2_wPos = float3(V2_Sample.x,V2_Sample.y,V2_Sample.z);\n    V2_Pos = Reconsile3D(V2_wPos);\n    if (V2_Sample.w != 0.0f) \{ \n\n      if (insideY) \{\n        V1_Sample = ppos(pos.x+1,pos.y-1);\n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (V1_Sample.w != 0.0f) \{ \n            float3 Normal = CalculateVertexNormals(_vWorld,V2_wPos,V1_wPos);\n\n            //Calculate Area for density:\n            V0 = screen_pos;\n            V1 = V1_Pos;\n            V2 = V2_Pos;\n            V0.z = 1.0f / V0.z, V1.z = 1.0f / V1.z, V2.z = 1.0f / V2.z; \n            area = length(V0-V1)+length(V0-V2)+length(V1-V2);\n\n          //write output\n          output +=  float3(Normal.x,Normal.y,Normal.z);\n        \}\n      \}\n      if (insideYtop) \{\n        V1_Sample = ppos(pos.x,pos.y+1);\n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (V1_Sample.w != 0.0f) \{ \n          float3 Normal = CalculateVertexNormals(_vWorld,V1_wPos,V2_wPos);\n\n            //Calculate Area for density:\n            V0 = screen_pos;\n            V1 = V1_Pos;\n            V2 = V2_Pos;\n            V0.z = 1.0f / V0.z, V1.z = 1.0f / V1.z, V2.z = 1.0f / V2.z; \n            area = length(V0-V1)+length(V0-V2)+length(V1-V2);\n\n          output += float3(Normal.x,Normal.y,Normal.z);\n\n        \}\n      \}\n    \}\n  \}\n  return output;\n\}\n\n\n\nfloat3 CalculateSurfaceNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat3 CalculateVertexNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 hitNormal = cross((V1 - V0),(V2 - V0)); \n        return hitNormal;\n\}\n\n\n\n//-------------------------------------\n// Process\n//-------------------------------------\n  void process(int2 pos) \{\n    float3 output = float3(0.0f);\n    float4 _sample = ppos(pos.x,pos.y); //Get the XYZ Coordinates\n    float3 point_pos = float3(_sample.x,_sample.y,_sample.z);\n    if (_sample.w != 0.0f) \{  //No need to process if there is no data.\n      dst() = float4(0.0f);\n      output+=facet_render(pos,float3(_sample.x,_sample.y,_sample.z))*2.0f;\n      _sample = ppos(pos.x-1,pos.y); //Get the XYZ Coordinates\n      output+=facet_render(int2(pos.x-1,pos.y),float3(_sample.x,_sample.y,_sample.z));\n\n      _sample = ppos(pos.x-1,pos.y+1); //Get the XYZ Coordinates\n      output+=facet_render(int2(pos.x-1,pos.y+1),float3(_sample.x,_sample.y,_sample.z));\n\n      _sample = ppos(pos.x,pos.y-1); //Get the XYZ Coordinates\n      output+=facet_render(int2(pos.x,pos.y-1),float3(_sample.x,_sample.y,_sample.z));\n\n      output = normalize(output);\n      float3 normal = -output;\n\n      \n\n\n      dst() = float4(normal.x,normal.y,normal.z,1.0f);\n    \}\n  \} //----> process\n\};\n"
   rebuild ""
   "PointRender3D_half Lambert" false
   "PointRender3D_light Mode" {{parent.LightFalloff}}
   PointRender3D_light_position {{parent.Axis1.translate} {parent.Axis1.translate} {parent.Axis1.translate}}
   PointRender3D_light_color {{parent.LightColor} {parent.LightColor} {parent.LightColor}}
   rebuild_finalise ""
   name BlinkScript1
   xpos 389
   ypos 344
  }
  Grade {
   multiply 0.5
   add 0.5
   black_clamp false
   name Grade1
   xpos 389
   ypos 376
   disable true
  }
  Output {
   name Output1
   xpos 389
   ypos 459
  }
  Axis2 {
   inputs 0
   translate {0.5 0.5 0.5}
   name Axis1
   xpos 661
   ypos 318
   addUserKnob {20 Ivy}
   addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.toolbox.v1.nodes.docs', fromlist=\['open_docs_name']).open_docs_name('IvyTab')" +STARTLINE}
   addUserKnob {26 divider4 l "" +STARTLINE}
   addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
   _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
   addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
   addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
   addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
   _expressions {{curve}}
   addUserKnob {26 divider0 l "" +STARTLINE}
   addUserKnob {20 dbinfo l "DB Info" n 1}
   dbinfo 0
   addUserKnob {1 twig_dnuuid l "Twig Id"}
   addUserKnob {1 stalk_dnuuid l "Stalk Id"}
   addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
   addUserKnob {1 leaf_dnuuid l "Leaf Id"}
   addUserKnob {26 divider1 l "" +STARTLINE}
   addUserKnob {1 twigtype l "Twig Type"}
   addUserKnob {1 leaf_label l Leaf}
   addUserKnob {1 ivy_version l Version}
   addUserKnob {43 ivy_notes l Notes}
   addUserKnob {26 divider2 l "" +STARTLINE}
   addUserKnob {1 build_label l "Build Label"}
   addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
  }
 end_group
 Switch {
  inputs 2
  which {{parent.connect_aux}}
  name Switch3
  xpos -324
  ypos 311
 }
push $N548efec0
 Expression {
  temp_name0 xd
  temp_expr0 red-Camera1.world_matrix.3
  temp_name1 yd
  temp_expr1 green-Camera1.world_matrix.7
  temp_name2 zd
  temp_expr2 blue-Camera1.world_matrix.11
  temp_name3 Distance
  temp_expr3 "sqrt(xd*xd + yd*yd + zd*zd)"
  expr0 Distance
  expr1 Distance
  expr2 Distance
  expr3 Distance
  name Expression1
  xpos -456
  ypos -192
 }
 Grade {
  channels rgba
  blackpoint {{parent.FogFar}}
  whitepoint {{parent.FogNear}}
  gamma {{1/(parent.FogExponent+0.000000001)}}
  white_clamp true
  name Grade1
  xpos -456
  ypos -168
 }
push $N68147040
 Dot {
  name Dot7
  xpos -307
  ypos -513
 }
 Merge2 {
  inputs 2
  operation multiply
  name Merge1
  xpos -341
  ypos -168
  disable {{!parent.Fog}}
 }
 Shuffle {
  name Shuffle3
  xpos -341
  ypos 8
 }
set N57800580 [stack 0]
push $N5491adf0
 BlinkScript {
  inputs 4
  kernelSourceFile /Users/madshagbarth/Github/Nuke-Private/Blink/PointRender/Render/3D_PointRender_v15.cpp
  recompileCount 792
  ProgramGroup 1
  KernelDescription "2 \"PointRender3D\" iterate pixelWise e0ecbbf4cba39730471d23bc9f9ec846fcae1bbb869971a11b15641cf6fd5620 5 \"ppos\" Read Random \"src\" Read Random \"normals\" Read Random \"occlusion\" Read Random \"dst\" Write Random 48 \"cam_Matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== \"focallength\" Float 1 AAA4QQ== \"hapeture\" Float 1 ppvEQQ== \"format\" Int 2 AAgAAAAIAAA= \"vertexformat\" Int 2 CgAAAAoAAAA= \"Zoom\" Float 1 AACAPw== \"Filtering Method\" Int 1 AQAAAA== \"_alphaMultiplier\" Float 1 AACAPw== \"_pointRender\" Bool 1 AQ== \"_wireRender\" Bool 1 AQ== \"_facetRender\" Bool 1 AQ== \"_maxLDistance\" Float 1 AACAPw== \"_maxLConnections\" Int 1 AQAAAA== \"_maxPlexType\" Int 1 AAAAAA== \"_plexLinedefXY\" Bool 1 AA== \"_plexLinedefX\" Bool 1 AA== \"_plexLinedefY\" Bool 1 AA== \"_plexLinedefXtoY\" Bool 1 AA== \"_plexLinedefAUX\" Bool 1 AA== \"_plexConnectX\" Bool 1 AA== \"_plexConnectY\" Bool 1 AA== \"_L_gamma\" Float 1 AACAPw== \"Enable Depth of Field\" Bool 1 AA== \"samples\" Int 1 AwAAAA== \"rings\" Int 1 BQAAAA== \"focalDepth\" Float 1 AACAPw== \"_depthOfField\" Float 1 AACAQA== \"_depthMult\" Float 1 zczMPQ== \"_maxDofSize\" Float 1 AAAAQQ== \"dof_aspect\" Float 1 AACAPw== \"dof_threshold\" Float 1 AACAPw== \"dof_gain\" Float 1 AAAAAA== \"dof_bias\" Float 1 AAAAwA== \"dof_fringe\" Float 1 AAAAAA== \"_flatshading\" Bool 1 AQ== \"_backfacing\" Bool 1 AQ== \"_frontfacing\" Bool 1 AQ== \"_vertexMode\" Int 1 AAAAAA== \"_depthBuffer\" Bool 1 AQ== \"_texoffset\" Float 2 AAAAPwAAAD8= \"_pointSize\" Int 1 AQAAAA== \"_gaussigma\" Float 1 AACAPw== \"_depthOcclusion\" Bool 1 AQ== \"depthMultiplier\" Float 1 AACAPw== \"_maxLineSteps\" Float 1 AAB6RQ== \"_lineOffset\" Float 1 AACAPw== \"_lineInMultiplier\" Float 1 AACAPw== \"_lineOutMultiplier\" Float 1 AACAPw== 48 \"cam_Matrix\" 16 1 \"cam_Focal\" 1 1 \"cam_Hapeture\" 1 1 \"WHformat\" 2 1 \"Vformat\" 2 1 \"zoom\" 1 1 \"_filtering\" 1 1 \"_alphaMultiplier\" 1 1 \"_pointRender\" 1 1 \"_wireRender\" 1 1 \"_facetRender\" 1 1 \"_maxPlexDistance\" 1 1 \"_maxPlexConnections\" 1 1 \"_maxPlexType\" 1 1 \"_plexLinedefXY\" 1 1 \"_plexLinedefX\" 1 1 \"_plexLinedefY\" 1 1 \"_plexLinedefXtoY\" 1 1 \"_plexLinedefAUX\" 1 1 \"_plexConnectX\" 1 1 \"_plexConnectY\" 1 1 \"_plex_gamma\" 1 1 \"_dof_enable\" 1 1 \"_dof_samples\" 1 1 \"_dof_rings\" 1 1 \"focalDepth\" 1 1 \"_depthOfField\" 1 1 \"_depthMult\" 1 1 \"_maxDofSize\" 1 1 \"dof_aspect\" 1 1 \"dof_threshold\" 1 1 \"dof_gain\" 1 1 \"dof_bias\" 1 1 \"dof_fringe\" 1 1 \"_flatshading\" 1 1 \"_backfacing\" 1 1 \"_frontfacing\" 1 1 \"_vertexMode\" 1 1 \"_depthBuffer\" 1 1 \"_texoffset\" 2 1 \"_pointSize\" 1 1 \"_gaussigma\" 1 1 \"_depthOcclusion\" 1 1 \"depthMultiplier\" 1 1 \"_maxLineSteps\" 1 1 \"_lineOffset\" 1 1 \"_lineInMultiplier\" 1 1 \"_lineOutMultiplier\" 1 1 10 \"max_line_connections\" Int 1 1 AAAAAA== \"vRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"pRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"tRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"vWorld\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"canvasWidth\" Float 1 1 AAAAAA== \"canvasHeight\" Float 1 1 AAAAAA== \"matrixData\" Float 1 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cameraToWorld\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"worldToCamera\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "//Some basic generic functions.\ninline float Frac(float a_X)\n\{\n    return a_X-floor(a_X);\n\}\n\ninline float3 Cross(float3 A,float3 B)\n\{\n    return float3(A.y*B.z - A.z*B.y,A.z*B.x - A.x*B.z,A.x*B.y - A.y*B.x);\n\}\n\ninline float Fmax(float a_X,float b_X,float c_X)\n\{\n    return max(c_X,max(a_X,b_X));\n\}\ninline float Fmin(float a_X,float b_X,float c_X)\n\{\n    return min(c_X,min(a_X,b_X));\n\}     \n\ninline float3 mix(float3 _X,float3 _Y,float _A)\{\n  return _X*(1.0f-_A)+_Y*_A;\n\}\ninline float mix(float _X,float _Y,float _A)\{\n  return _X*(1.0f-_A)+_Y*_A;\n\}                                                                                              \n\n//This function is used to multiply a float3 by a matrix4x4\ninline float3 multVecMatrix( float3 src, float4x4 matrix)\n\{\n    float   x,y,z,w;\n\n    x = src\[0]*matrix\[0]\[0] + src\[1]*matrix\[1]\[0] +\n    src\[2]*matrix\[2]\[0] + matrix\[3]\[0];\n    y = src\[0]*matrix\[0]\[1] + src\[1]*matrix\[1]\[1] +\n    src\[2]*matrix\[2]\[1] + matrix\[3]\[1];\n    z = src\[0]*matrix\[0]\[2] + src\[1]*matrix\[1]\[2] +\n    src\[2]*matrix\[2]\[2] + matrix\[3]\[2];\n    w = src\[0]*matrix\[0]\[3] + src\[1]*matrix\[1]\[3] +\n    src\[2]*matrix\[2]\[3] + matrix\[3]\[3];\n    \n    return float3(x/w, y/w, z/w);\n\}\n\n//This function is used to calculate the screenspace coordinates.\ninline bool computePixelCoordinates( \n    const float3 pWorld, \n    float3 &pRaster, \n    const float4x4 &worldToCamera, \n    const float &canvasWidth, \n    const float &canvasHeight, \n    const int &imageWidth, \n    const int &imageHeight\n) \n\{ \n    float3 pCamera; \n    pCamera = multVecMatrix(pWorld, worldToCamera); \n    float2 pScreen; \n    pScreen.x = pCamera.x / -pCamera.z; \n    pScreen.y = pCamera.y / -pCamera.z; \n    float2 pNDC; \n    pNDC.x = (pScreen.x + canvasWidth * 0.5f) / canvasWidth; \n    pNDC.y = (pScreen.y + canvasHeight * 0.5f) / canvasHeight; \n    pRaster.x = (pNDC.x * imageWidth); \n    pRaster.y = ((pNDC.y) * imageHeight); \n    pRaster.z = -pCamera.z; \n    if (pRaster.x < 0.0f || pRaster.x > imageWidth || \n       pRaster.y < 0.0f || pRaster.y > imageHeight || pRaster.z < 0.0f) \{\n       return false;  \n    \}\n    return true;\n\} \n\n\nkernel PointRender3D : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessRandom, eEdgeClamped> ppos;    //The point position map\n  Image<eRead, eAccessRandom, eEdgeClamped> src;     //The texture map\n  Image<eRead, eAccessRandom, eEdgeClamped> normals;     //The texture map  \n  Image<eRead, eAccessRandom, eEdgeClamped> occlusion;     //The texture map \n  Image<eWrite, eAccessRandom> dst;                 //the output image\n\n  param: //Parameters available to the user\n    float4x4 cam_Matrix;    //The world matrix of the camera\n    float cam_Focal;        //The focal length of the camera\n    float cam_Hapeture;     //The horizontal apeture of the camera\n    int2 WHformat,Vformat;          //The format of the output image\n    float zoom;             //A \"post\" zoom function\n    int _filtering;        //Filter method\n    float _alphaMultiplier; //Additive multiplier\n    bool _pointRender,_wireRender,_facetRender;\n    float _maxPlexDistance; //Additive multiplier\n    int _maxPlexConnections;\n    int _maxPlexType; // 0==Grid, -1==Nearest\n    bool _plexLinedefXY,_plexLinedefX,_plexLinedefY,_plexLinedefXtoY,_plexLinedefAUX; // Define what connections NOT to include\n    bool _plexConnectX,_plexConnectY; //Connect from the edge of x to 0, or edge of y to 0, usually for spheres\n    float _plex_gamma; //The threshold making shorter paths bright and longer paths dark\n    bool _dof_enable; // Enable DOF\n    int _dof_samples; // How many samples per DOF ring\n    int _dof_rings; // How many rings \n    float focalDepth,_depthOfField,_depthMult,_maxDofSize; //DOF Settings\n    float dof_aspect; //Pixel aspect ratio\n    float dof_threshold;\n    float dof_gain;\n    float dof_bias; //bokeh edge bias\n    float dof_fringe; //bokeh chromatic aberration/fringing\n    bool _flatshading,_backfacing,_frontfacing; //Vertex rendering settings\n    int _vertexMode;  //The rendering output mode, (think AOV)\n    bool _depthBuffer; //Non-additive, only render front most pixel\n    float2 _texoffset;\n    int _pointSize;\n    float _gaussigma;\n    bool _depthOcclusion;\n    float depthMultiplier;\n    float _maxLineSteps; //cap the line length to avoid process lock\n    float _lineOffset; //Alow you to shrink or extend the lines\n    float _lineInMultiplier,_lineOutMultiplier; //Control the brightness of the wires at the tips.\n\n  local: //Local variables\n    int max_line_connections;\n    float3 vRaster;\n    float3 pRaster;\n    float3 tRaster;    \n    float3 vWorld;\n    float canvasWidth;\n    float canvasHeight; \n    float matrixData\[4]\[4];\n    float4x4 cameraToWorld;\n    float4x4 worldToCamera;\n\n  void define() \{\n    defineParam(cam_Matrix, \"cam_Matrix\", float4x4( 1.0f,0.0f,0.0f,0.0f,\n                                                    0.0f,1.0f,0.0f,0.0f,\n                                                    0.0f,0.0f,1.0f,0.0f,\n                                                    0.0f,0.0f,0.0f,1.0f));\n    defineParam(cam_Focal,      \"focallength\", 11.5f);\n    defineParam(cam_Hapeture,      \"hapeture\", 24.576f);\n    defineParam(WHformat,      \"format\", int2(2048,2048));\n    defineParam(Vformat,      \"vertexformat\", int2(10,10));\n    defineParam(zoom, \"Zoom\", 1.0f);\n    defineParam(_filtering, \"Filtering Method\", 1); \n    defineParam(_alphaMultiplier, \"_alphaMultiplier\", 1.0f);     \n    defineParam(_pointRender, \"_pointRender\", true);  \n    defineParam(_wireRender, \"_wireRender\", true);\n    defineParam(_facetRender, \"_facetRender\", true);\n    defineParam(_maxPlexDistance, \"_maxLDistance\", 1.0f);    \n    defineParam(_maxPlexConnections, \"_maxLConnections\", 1);    \n    defineParam(_maxPlexType, \"_maxPlexType\", 0); \n    defineParam(_plexLinedefXY, \"_plexLinedefXY\", false);      \n    defineParam(_plexLinedefXtoY, \"_plexLinedefXtoY\", false); //NYI\n    defineParam(_plexLinedefAUX, \"_plexLinedefAUX\", false); \n    defineParam(_plexLinedefX, \"_plexLinedefX\", false);  \n    defineParam(_plexLinedefY, \"_plexLinedefY\", false);  \n    defineParam(_plexConnectX, \"_plexConnectX\", false);      \n    defineParam(_plexConnectY, \"_plexConnectY\", false);   \n    defineParam(_plex_gamma, \"_L_gamma\", 1.0f);\n    //DOF SETTINGS   \n    defineParam(_dof_enable, \"Enable Depth of Field\", false);   \n    defineParam(_dof_samples, \"samples\", 3);    \n    defineParam(_dof_rings, \"rings\", 5);   \n    defineParam(focalDepth, \"focalDepth\", 1.0f);  \n    defineParam(_depthOfField, \"_depthOfField\", 4.0f);  \n    defineParam(_depthMult, \"_depthMult\", 0.1f);  \n    defineParam(_maxDofSize, \"_maxDofSize\", 8.0f);  \n    defineParam(dof_aspect, \"dof_aspect\", 1.0f);  \n    defineParam(dof_threshold, \"dof_threshold\", 1.0f);  \n    defineParam(dof_gain, \"dof_gain\", 0.0f);  \n    defineParam(dof_bias, \"dof_bias\", -2.0f);  \n    defineParam(dof_fringe, \"dof_fringe\", 0.0f); \n    //SHADING SETTINGS \n    defineParam(_flatshading, \"_flatshading\", true);  \n    defineParam(_vertexMode, \"_vertexMode\", 0);  \n    defineParam(_backfacing, \"_backfacing\", true);    \n    defineParam(_frontfacing, \"_frontfacing\", true);        \n    defineParam(_depthBuffer, \"_depthBuffer\", true);  \n    defineParam(_texoffset, \"_texoffset\", float2(0.5f,0.5f)); \n    defineParam(_pointSize, \"_pointSize\", 1); \n    defineParam(_gaussigma, \"_gaussigma\", 1.0f); \n    defineParam(_depthOcclusion, \"_depthOcclusion\", true); \n    defineParam(depthMultiplier, \"depthMultiplier\", 1.0f); \n    defineParam(_maxLineSteps, \"_maxLineSteps\", 4000.0f); \n    defineParam(_lineOffset, \"_lineOffset\", 1.0f); \n    defineParam(_lineInMultiplier, \"_lineInMultiplier\", 1.0f);   \n    defineParam(_lineOutMultiplier, \"_lineOutMultiplier\", 1.0f);     \n\n  \}\n\n  //The init() function is run before any calls to process().\n  void init() \{\n    max_line_connections = 80;\n    canvasWidth = ((cam_Hapeture)/cam_Focal);\n    canvasHeight = ((cam_Hapeture)/cam_Focal)*float(float(WHformat.y)/float(WHformat.x)); \n    float matrixData\[] = \{cam_Matrix\[0]\[0], cam_Matrix\[1]\[0], cam_Matrix\[2]\[0], cam_Matrix\[3]\[0], \n                          cam_Matrix\[0]\[1], cam_Matrix\[1]\[1], cam_Matrix\[2]\[1], cam_Matrix\[3]\[1], \n                          cam_Matrix\[0]\[2], cam_Matrix\[1]\[2], cam_Matrix\[2]\[2], cam_Matrix\[3]\[2], \n                          cam_Matrix\[0]\[3], cam_Matrix\[1]\[3], cam_Matrix\[2]\[3], cam_Matrix\[3]\[3]\};\n    cameraToWorld.setArray(matrixData); //This is a workaround. Due to the buggy matrix implementation, we pass the matrix on from another structure.\n    worldToCamera = cameraToWorld.invert();\n  \}\n\n  //Convert a 3d point position into a 2d raster position.\n  float3 Reconsile3D(float3 _PointPos)\{\n      vWorld = float3(_PointPos.x,_PointPos.y,_PointPos.z)*(zoom);\n      int ret = computePixelCoordinates(vWorld, tRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1]);\n      return tRaster;\n  \}\n\n//------------------------------\n//-------DRAW FUNCTIONS---------\n//------------------------------\n  //Write pixels to output.\n  void writepixel(float posx,float posy, float4 color,int index,float weight=1.0f)\n  \{ \n      if (_depthOcclusion)\{\n        float4 depthSample = occlusion(posx,posy);\n        if (depthSample.x<=vRaster.z && depthSample.w>0.0f)\{\n\n          float depth = (vRaster.z-depthSample.x);\n          color = color*(1.0f-depthSample.w);\n          color = color / (((depth*depth)*depthMultiplier)+1.0f);\n          //return;\n        \}\n      \}\n      float4 finalOutput; //This is used to store the final output\n      float4 dstSample; //This is used to store a sample of the destination\n      if ( dst.bounds.inside( posx, posy ) ) \{ //Test if the pixel written to is inside the output image. \n        if (_depthBuffer) \{\n          dstSample = (float4)dst(posx,posy); //Sample the destination image\n          if ((dstSample.w>color.w)||dstSample.w==0.0f) \{\n            dst(posx,posy) = color;\n          \}\n        \}\n        else \{\n          dstSample = (float4)dst(posx,posy); //Sample the destination image\n          finalOutput = dstSample + (color*_alphaMultiplier*weight);\n          finalOutput.w = dstSample.w + ((color.w*_alphaMultiplier*weight));\n\n          finalOutput.w = (dstSample.w + ((color.w*_alphaMultiplier*weight)))-(dstSample.w * ((color.w*_alphaMultiplier*weight)));\n\n          dst(posx,posy) = finalOutput;\n        \}\n      \} \n  \}\n\n  //Calculate a Bilinear Plot\n  void bilinear_Plot(float2 temppos,float4 color,int index)\n  \{\n    float2 p;\n    p.x=Frac(temppos.x);\n    p.y=Frac(temppos.y);\n    float weights\[] = \{(1.0f-p.x)*(1.0f-p.y), p.x*(1.0f-p.y), (1.0f-p.x)*p.y, p.x*p.y\};\n    int2 _position = int2(floor(temppos.x)-0,floor(temppos.y)-0); \n    writepixel(_position.x,_position.y,color,index,weights\[0]);\n    writepixel(_position.x+1,_position.y,color,index,weights\[1]);\n    writepixel(_position.x,_position.y+1,color,index,weights\[2]);\n    writepixel(_position.x+1,_position.y+1,color,index,weights\[3]);\n  \}\n\n  //NYI, unused!\n  void gaussian(float2 temppos,float4 color,int index)\{\n    float in_x = temppos.x;\n    float in_y = temppos.y;\n    int kernelSize = (_pointSize+1)*2;\n    int subsize = (kernelSize /2)-1;\n    float gKernel\[64]\[64];\n    float sigma = _gaussigma;\n    float intSigma = float(_pointSize);\n    float r, s = intSigma * sigma * sigma;\n\n    float sum = 0.0f;\n\n    // generate 5x5 kernel\n    for (int x = -subsize; x <= subsize; x++)\n    \{\n        for(int y = -subsize; y <= subsize; y++)\n        \{\n            r = float(sqrt(x*x + y*y));\n            gKernel\[x + subsize]\[y + subsize] = (exp(-(r*r)/s))/(3.141592654f * s);\n            sum += gKernel\[x + subsize]\[y + subsize];\n        \}\n    \}\n\n    // normalize the Kernel\n    for (int x = -subsize; x <= subsize; x++)\n    \{\n        for(int y = -subsize; y <= subsize; y++)\n        \{\n            gKernel\[x + subsize]\[y + subsize] /= sum;\n            writepixel(in_x+x,in_y+y,color,index,gKernel\[x + subsize]\[y + subsize]);\n        \}\n    \}\n  \}\n\n//-------------------------------------\n// DrawLine\n// ----------\n// Draw a line between two points, \n// x,y being 2d screenspace pos and z being depth.\n//-------------------------------------\n  void DrawLine(float3 origin, float3 endpoint,float4 _colorA,float4 _colorB) \{\n    float4 _color;\n    float3 delta = origin-endpoint;\n    float3 curPoint = origin;\n    float mag = sqrt(delta.x*delta.x+delta.y*delta.y);\n    mag = min(mag,_maxLineSteps); //Lets not go crazy, we cap it at 10.000 to avoid insane unwated processing time \n    for( float a = 0; a < mag*_lineOffset; a = a + 1.0f )\{\n      curPoint -= (delta/mag);\n      _color = (_colorA*(1.0f-(a/mag*1.0f)))+(_colorB*(a/mag*1.00f));\n      if (_dof_enable)\{\n        Bokeh(curPoint,_color);\n      \}\n      else \{\n        bilinear_Plot(float2(curPoint.x,curPoint.y),_color,1);\n      \}\n      \n    \}\n  \}\n\n//-------------------------------------\n// Point_Render\n//-------------------------------------\nvoid point_render(int2 pos, float3 screen_pos)\{\n  float4 color = src(pos.x,pos.y);\n\n  if (_filtering == 1)\{\n      if (_dof_enable)\{\n        Bokeh(screen_pos,color);\n      \}\n      else \{\n        bilinear_Plot(float2(screen_pos.x,screen_pos.y),color,1);\n      \}\n  \}\n  /*\n  //THIS PART NEEDS TO BE RE-WRITTEN.\n  else if (_filtering == 2)\{ \n      if (_dof_enable)\{\n        Bokeh(screen_pos,color);\n      \}\n      else \{\n        gaussian(float2(screen_pos.x,screen_pos.y),color,1);\n      \}\n  \}\n  */\n  else \{\n      int2 _position = int2(floor(screen_pos.x),floor(screen_pos.y)); \n      if (_depthBuffer) \{color.w = screen_pos.z;\}\n      writepixel(_position.x,_position.y, color,1,1.0f); //OutputSample\n  \}\n\n\}\n\n//-------------------------------------\n// Facet_Render\n//-------------------------------------\n//This function is used to calculate what triangels to draw\nvoid facet_render(int2 pos, float3 _vWorld)\{\n\n    float3 screen_pos = Reconsile3D(_vWorld);\n\n    bool insideX = ppos.bounds.inside(pos.x+1,pos.y );\n    bool insideY = ppos.bounds.inside(pos.x+1,pos.y-1 );\n    bool insideYtop = ppos.bounds.inside(pos.x,pos.y+1);\n    float2 fpos = float2(pos.x,pos.y);\n    float3 V1_Pos,V2_Pos,V1_wPos,V2_wPos,V0_N,V1_N,V2_N;\n    float2 V0_ST,V1_ST,V2_ST;\n    float4 V1_Sample,V2_Sample;\n    float4 _tn;\n    float3 normal0,normal1,normal2;\n    float2 UV_Format = float2(Vformat.x,Vformat.y);\n\n\n    int2 P0 = int2(pos.x-1,pos.y-1);\n    int2 P1 = int2(pos.x+1,pos.y+1);\n    if (_plexConnectX && pos.x == int(Vformat.x))\{\n      insideX == true;\n      P1 = int2(0.0f,pos.y+1);\n    \}\n    if (_plexConnectY && pos.y == int(Vformat.y))\{\n      insideYtop == true;\n      P1 = int2(pos.x+1,0);\n    \} \n\n    if (_plexConnectY && pos.y == 0)\{\n      insideY == true;\n      P0 = int2(pos.x-1,int(UV_Format.y));\n    \} \n\n    if (!_flatshading) \{\n      _tn = normals(pos.x,pos.y);\n      V0_N =float3(_tn.x,_tn.y,_tn.z);\n    \}\n    V0_ST = float2(pos.x,pos.y)/UV_Format;\n\n  if (insideX) \{\n    V2_Sample = ppos(P1.x,pos.y);\n    V2_ST = float2(P1.x,pos.y)/UV_Format;\n    V2_wPos = float3(V2_Sample.x,V2_Sample.y,V2_Sample.z);\n    V2_Pos = Reconsile3D(V2_wPos);\n    if (!_flatshading) \{\n      _tn = normals(P1.x,pos.y);\n      V2_N =float3(_tn.x,_tn.y,_tn.z);\n    \}\n        \n\n    if (V2_Sample.w != 0.0f) \{ \n\n      if (insideY) \{\n        V1_Sample = ppos(P1.x,P0.y);\n        V1_ST = float2(P1.x,P0.y)/UV_Format;\n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (!_flatshading) \{\n          _tn = normals(P1.x,P0.y);\n          V1_N =float3(_tn.x,_tn.y,_tn.z);\n        \}\n        if (V1_Sample.w != 0.0f) \{ \n          DrawTriangle(screen_pos,V2_Pos,V1_Pos,_vWorld,V2_wPos,V1_wPos,V0_N,V2_N,V1_N,V0_ST,V2_ST,V1_ST);\n        \}\n      \}\n      if (insideYtop) \{\n        V1_Sample = ppos(pos.x,P1.y);\n        V1_ST = float2(pos.x,P1.y)/UV_Format;        \n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (!_flatshading) \{\n          _tn = normals(pos.x,P1.y);\n          V1_N =float3(_tn.x,_tn.y,_tn.z);\n        \}        \n        if (V1_Sample.w != 0.0f) \{ \n          DrawTriangle(screen_pos,V1_Pos,V2_Pos,_vWorld,V1_wPos,V2_wPos,V0_N,V1_N,V2_N,V0_ST,V1_ST,V2_ST);\n        \}\n      \}\n    \}\n  \}\n\}\n\n\n\n//This function will calculate if pixel C is inside the triangle\nfloat edgeFunction(float3 a, float3 b, float3 c) \n\{ \n    return ((c.x - a.x) * (b.y - a.y) - (c.y - a.y) * (b.x - a.x)); \n\} \n\nfloat3 CalculateSurfaceNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat3 CalculateVertexNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat Distance(float3 _a,float3 _b)\n\{\n          float xd = _a.x - _b.x;\n          float yd = _a.y - _b.y;\n          float zd = _a.z - _b.z;\n          return sqrt(xd*xd + yd*yd + zd*zd);\n\}\n\nvoid DrawTriangle(float3 V0, float3 V1, float3 V2,float3 WP0, float3 WP1, float3 WP2,float3 N0, float3 N1, float3 N2, float2 st0,float2 st1,float2 st2) \{\n\n  // Precompute reciprocal of vertex z-coordinate \n  V0.z = 1.0f / V0.z, V1.z = 1.0f / V1.z, V2.z = 1.0f / V2.z; \n\n  float2 st0n = st0 * V0.z;\n  float2 st1n = st1 * V1.z; \n  float2 st2n = st2 * V2.z; //Normal version of ST\n\n  bool inside; \n  float X0 = Fmin(V0.x,V1.x,V2.x)-1.0f;\n  float X1 = Fmax(V0.x,V1.x,V2.x)+1.0f;\n  float Y0 = Fmin(V0.y,V1.y,V2.y)-1.0f;\n  float Y1 = Fmax(V0.y,V1.y,V2.y)+1.0f;\n  float area = edgeFunction(V2, V1, V0);\n\n\n  float2 sampos = float2(st0.x*float(Vformat.x),st0.y*float(Vformat.y));\n  float4 text0 = src(sampos.x,sampos.y);\n  sampos = float2(st1.x*float(Vformat.x),st1.y*float(Vformat.y));\n  float4 text1 = src(sampos.x,sampos.y);\n  sampos = float2(st2.x*float(Vformat.x),st2.y*float(Vformat.y));  //Why do we have to do this? =(\n  float4 text2 = src(sampos.x,sampos.y);\n  sampos = float2(min(min(st0.x,st1.x),st2.x)*float(Vformat.x),min(min(st0.y,st1.y),st2.y)*float(Vformat.y));\n  float4 text3 = src(sampos.x,sampos.y);\n\n\n  for( int x = X0; x < X1 ; x++) \{\n    for( int y = Y0; y < Y1 ; y++) \{\n      float3 pixelSample(x + _texoffset.x, y + _texoffset.y,0.0f); \n\n      //This is the part where we test if the current pixel is inside the triangle\n      //We check both for front facing and back faing options\n      float w0 = edgeFunction(V1, V0, pixelSample); //Front Facing\n      float w1 = edgeFunction(V2, V1, pixelSample); \n      float w2 = edgeFunction(V0, V2, pixelSample); \n      float w3 = edgeFunction(V0, V1, pixelSample); //Back Facing\n      float w4 = edgeFunction(V1, V2, pixelSample); \n      float w5 = edgeFunction(V2, V0, pixelSample);\n\n      //writepixel(x,y, float4(w1),1,1.0f);\n      if ((w0 >= 0 && w1 >= 0 && w2 >= 0 && _frontfacing) || (w3 >= 0 && w4 >= 0 && w5 >= 0 && _backfacing)) \{ //The curent pixel is inside the triangle\n\n       // calculate vectors from point f to vertices p1, p2 and p3:\n       float3 f1 = V0-pixelSample;\n       float3 f2 = V1-pixelSample;\n       float3 f3 = V2-pixelSample;\n       // calculate the areas and factors (order of parameters doesn't matter):\n       float a = length(cross(V0-V1,V0-V2 )); // main triangle area a\n       area = length(V0-V1)+length(V0-V2)+length(V1-V2);\n\n        w0 /= area; \n        w1 /= area; \n        w2 /= area; \n\n        w3 /= area; \n        w4 /= area; \n        w5 /= area; \n\n       float a1 = length(cross(f2, f3)) / a; // p1's triangle area / a\n       float a2 = length(cross(f3, f1)) / a; // p2's triangle area / a \n       float a3 = length(cross(f1, f2)) / a; // p3's triangle area / a\n       float a_magnitude = a1+a2+a3;\n       a1 = a1/a_magnitude;\n       a2 = a2/a_magnitude;\n       a3 = a3/a_magnitude;\n       float z = 1.0f / (V0.z * a1 + V1.z * a2 + V2.z * a3); \n\n\n        // find the uv corresponding to point f (uv1/uv2/uv3 are associated to p1/p2/p3):\n        float2 uv = st0 * a1 + st1 * a2 + st2 * a3;\n        float2 st = st0 * w0 + st1 * w1 + st2 * w2; \n        st *= z;      \n\n\n        //Calculate normals. Eighter we have flat shading, else we calculate a normal per pixel\n        float3 normalB;\n        if (_flatshading) \{\n          normalB = CalculateSurfaceNormals(WP0,WP1,WP2);\n\n        \}\n        else \{\n          float3 c0 = N2/float3(V0.z); \n          float3 c1 = N0/float3(V1.z); \n          float3 c2 = N1/float3(V2.z);  \n\n          normalB.x = w0 * c0.x + w1 * c1.x + w2 * c2.x; \n          normalB.y = w0 * c0.y + w1 * c1.y + w2 * c2.y; \n          normalB.z = w0 * c0.z + w1 * c1.z + w2 * c2.z; \n\n          normalB.x *= z, normalB.y *= z, normalB.z *= z; \n        \}\n        normalB = normalize(normalB);\n\n        //CALCULATE THE OBJECT TEXTURE COORDINATES\n        float zn = 1.0f / (V0.z * w0 + V1.z * w1 + V2.z * w2); \n        st = st0n * w0 + st1n * w1 + st2n * w2; \n        st *= zn;   \n        //--END \n\n        float3 Wpos = WP0*a1 + WP1*a2 + WP2*a3; //World Position.\n        float3 ViewNormal = normalize(float3(cameraToWorld\[3]\[0],cameraToWorld\[3]\[1],cameraToWorld\[3]\[2])-Wpos);\n\n        float nDotView =  dot(normalB,ViewNormal);\n        nDotView = 1.0f-fabs(nDotView); //make sure that the view normal ramps back around when doing backface\n        float4 tempout;\n\n        //Flatshading or regular?\n        if (!_flatshading) \{\n          tempout = text0 * a1 + text1 * a2 + text2 * a3; \n        \}\n        else\{\n          tempout = text3;\n        \}\n\n        //Additional Render Modes\n        if (_vertexMode == 1)\{\n          tempout = float4(a1,a2,a3,1.0f);\n        \}\n        else if (_vertexMode == 2)\{\n          tempout = float4(normalB.x,normalB.y,normalB.z,1.0f);\n        \}\n        else if (_vertexMode == 3)\{\n          tempout = float4(nDotView,nDotView,nDotView,1.0f);\n        \}\n        else if (_vertexMode == 4)\{\n          tempout = float4(uv.x,uv.y,0.0f,1.0f);\n        \}       \n        else if (_vertexMode == 5)\{\n          tempout = float4(st.x,st.y,0.0f,1.0f);\n        \}               \n        else if (_vertexMode == 6)\{\n          tempout = float4(ViewNormal.x,ViewNormal.y,ViewNormal.z,1.0f);\n        \}             \n        else if (_vertexMode == 7)\{\n          tempout = float4(Wpos.x,Wpos.y,Wpos.z,1.0f);\n        \}   \n\n        if (_depthBuffer)\{\n          writepixel(x,y, float4(tempout.x,tempout.y,tempout.z,z),1,1.0f);  \n        \}\n        else \{\n          if (_dof_enable)\{\n            Bokeh(float3(x,y,z),float4(tempout.x,tempout.y,tempout.z,z));\n          \}\n          else \{\n            bilinear_Plot(float2(x,y),float4(tempout.x,tempout.y,tempout.z,z),1);\n          \}\n        \}\n\n      \}  \n\n    \}\n  \}\n\}\n\n//-------------------------------------\n// Wire_Render\n//-------------------------------------\nvoid wire_render(int2 pos) \{\n  float4 temp = float4(0.0f,0.0f,0.0f,FLT_MAX);\n  float4 wire_ref_sample;\n  int2 tempXY = int2(0,0);\n  float4 plexlist\[11] = \{temp,temp,temp,temp,temp,temp,temp,temp,temp,temp,temp\}; \n  int2 plexlistXY\[11] = \{tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY\};\n  int plex_count = 0; //We use this to figure how many points that should connect.\n  float plex_dist;\n  float3 plex_position,plex_position_b;\n  float4 temp_pos, temp_pos_b; //Temporary Position Containers\n  if (_maxPlexType == -1) \{ //Used for random connection types\n    for( int x = 0; x < max_line_connections ; x++)\{ //THIS 80 NUMBER IS THE LIMIT TO AVOID TOO SLOW PROCESSING!\n      for( int y = 0; y < max_line_connections ; y++)\{\n        wire_ref_sample = ppos(x,y);\n        if (wire_ref_sample.w != 0.0f && pos.x!=x && pos.y != y) \{ \n          plex_position = float3(wire_ref_sample.x,wire_ref_sample.y,wire_ref_sample.z)*(zoom);\n          float xd = plex_position.x - vWorld.x;\n          float yd = plex_position.y - vWorld.y;\n          float zd = plex_position.z - vWorld.z;\n          float plex_dist = sqrt(xd*xd + yd*yd + zd*zd);\n          if (plex_dist<_maxPlexDistance)\{\n            plex_count = min(10,plex_count+1); //Add one to the count\n            for( int h = 0; h < plex_count+1 ; h++) \{ //Loop thought all the points. If the distance is shorter then insert it into the array and push the rest of the array down\n              if (plex_dist < plexlist\[h].w) \{                  \n                for( int i = plex_count+1; i > h ; i--) \{\n                  plexlist\[i] = plexlist\[i-1];\n                  plexlistXY\[i] = plexlistXY\[i-1];\n                \}\n                plexlist\[h] = float4(plex_position.x,plex_position.y,plex_position.z,plex_dist);\n                plexlistXY\[h] = int2(x,y);\n                break;        \n              \}\n            \}\n          \} \n        \}\n      \}\n    \}\n  \}\n  else\{ //Used for standard connection types\n    float4 temp_pos;\n    bool insideX = !(Vformat.x < pos.x+1);\n    bool insideY = !(Vformat.y < pos.y+1);\n\n\n    if (!_plexLinedefAUX)\{\n      temp_pos = normals(pos.x,pos.y);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,vWorld+plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    if ( insideX && !_plexLinedefX) \{\n      temp_pos = ppos(pos.x+1,pos.y );\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && !_plexLinedefX) \{\n      temp_pos = ppos(0,pos.y);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    if ( insideY && !_plexLinedefY) \{\n      temp_pos = ppos(pos.x,pos.y+1);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\}                          \n    \}\n    else if ( _plexConnectY  && !_plexLinedefY) \{\n      temp_pos = ppos(pos.x,0);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    //_plexConnect\n    if ( insideX && insideY && !_plexLinedefXY) \{              \n      temp_pos = ppos(pos.x+1,pos.y+1);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && _plexConnectY && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && insideY && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectY && insideX && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n  \}   \n\n  //now that all the connections have been sorted by distance then we connect the dots.\n  for( int x = 0; x < min(_maxPlexConnections,plex_count) ; x++)\{\n    plex_position = float3(plexlist\[x].x,plexlist\[x].y,plexlist\[x].z);\n    plex_dist = plexlist\[x].w;\n\n\n    float plex_distribution = 1.0f-((plexlist\[x].w-plexlist\[0].w)/((plexlist\[min(_maxPlexConnections,plex_count)].w-plexlist\[0].w)+0.00001f)); //Where does it lie between the best and the worst distance?\n    //plexlistXY\n\n    float4 plex_col = float4(pow(1.0f-(plex_dist/_maxPlexDistance),1.0f/_plex_gamma))*float4(plex_distribution); //This one is quite cool aswell, but does leave the center ones a bit too focused \n    float4 plex_colorA = src(pos.x,pos.y);\n    float4 plex_colorB = src( plexlistXY\[x].x,plexlistXY\[x].y);\n    plex_col *= 0.1f;\n\n    computePixelCoordinates(plex_position, pRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1]);\n    if (dst.bounds.inside(int(vRaster.x),int(vRaster.y)) || dst.bounds.inside(int(pRaster.x),int(pRaster.y)))\{\n        DrawLine(vRaster,pRaster,(plex_colorA*plex_col)*_lineInMultiplier,(plex_colorB*plex_col)*_lineOutMultiplier);\n    \}\n  \}\n\}\n\nvoid wire_connection(float3 p_source,float3 p_target, float4 (&p_plexlist)\[11], int2 (&p_plexlistXY)\[11],int &p_plexcount,int2 position) \{\n  float xd = p_target.x - p_source.x;\n  float yd = p_target.y - p_source.y;\n  float zd = p_target.z - p_source.z;\n  float plex_dist = sqrt(xd*xd + yd*yd + zd*zd);\n  if (plex_dist<_maxPlexDistance)\{\n    p_plexcount = min(11,p_plexcount+1); //Add one to the count\n    for( int h = 0; h < p_plexcount+1 ; h++) \{ //Loop thought all the points. If the distance is shorter then insert it into the array and push the rest of the array down\n      if (plex_dist < p_plexlist\[h].w) \{                  \n        for( int i = p_plexcount+1; i > h ; i--) \{\n          p_plexlist\[i] = p_plexlist\[i-1];\n          p_plexlistXY\[i] = p_plexlistXY\[i-1];\n        \}\n        p_plexlist\[h] = float4(p_target.x,p_target.y,p_target.z,plex_dist);\n        p_plexlistXY\[h] = int2(position.x,position.y);\n        break;        \n      \}\n    \}  \n  \}\n\}\n//-------END OF WIRE RENDER FUNCTIONS---------\n\n\n\n\n//-------------------------------\n//-------BOKEH FUNCTIONS---------\n//thanks to: http://devlog-martinsh.blogspot.dk/2011/11/glsl-depth-of-field-with-bokeh-v21.html\nfloat2 rand(float2 coord) //generating noise/pattern texture for dithering\n\{\n  float noiseX = ((Frac(1.0-coord.x*(WHformat\[0]/2.0))*0.25)+(Frac(coord.y*(WHformat\[1]/2.0))*0.75))*2.0-1.0;\n  float noiseY = ((Frac(1.0-coord.x*(WHformat\[0]/2.0))*0.75)+(Frac(coord.y*(WHformat\[1]/2.0))*0.25))*2.0-1.0;\n  noiseX = clamp(Frac(sin(dot(coord ,float2(12.9898f,78.233f))) * 43758.5453f),0.0f,1.0f)*2.0f-1.0f;\n  noiseY = clamp(Frac(sin(dot(coord ,float2(12.9898f,78.233f)*2.0f)) * 43758.5453f),0.0f,1.0f)*2.0-1.0f;\n  return float2(noiseX,noiseY);\n\}\n//-------------------------------------\n// Bokeh\n//-------------------------------------\nvoid Bokeh(float3 pos,float4 color)\{\n  float blur = 0.0;\n  blur = clamp((fabs(pos.z - focalDepth)/_depthOfField)*100.0f,-_maxDofSize,_maxDofSize);\n  \n  float w = (1.0/WHformat.x)*blur;//+noise.x;\n  float h = (1.0/(WHformat.x*dof_aspect))*blur;//+noise.y;\n  float3 v3_col = float3(color.x,color.y,color.z);\n  int ringsamples;\n  float s = 1.0;  \n\n  for (int i = 1; i <= _dof_rings; i += 1)\n  \{   \n    ringsamples = i * _dof_samples; \n    for (int j = 0 ; j < ringsamples ; j += 1)  \n    \{ \n      s += (1.0f*mix(1.0f,(float(i))/(float(_dof_rings)),dof_bias)*1.0f); //No need to do this in the loop\n    \}\n  \}\n\n  for (int i = 1; i <= _dof_rings; i += 1)\n  \{   \n    ringsamples = i * _dof_samples;\n     \n    for (int j = 0 ; j < ringsamples ; j += 1)   \n    \{\n      float step = PI*2.0 / float(ringsamples);\n      float pw = (cos(float(j)*step)*(float(i)/_dof_rings));\n      float ph = (sin(float(j)*step)*(float(i)/_dof_rings));\n      float p = 1.0;\n\n      float posx = pos.x+((pw*w)*blur);\n      float posy = pos.y+((ph*h)*blur);\n\n\n      float3 lumcoeff = float3(0.299,0.587,0.114);\n      float lum = dot(v3_col, lumcoeff);\n      float thresh = max((lum-dof_threshold)*dof_gain, 0.0f);\n      v3_col+mix(float3(0.0),v3_col,thresh*blur);\n\n      float3 col = (v3_col*mix(1.0,(float(i))/(float(_dof_rings)),dof_bias)*p)/s; \n      bilinear_Plot(float2(posx,posy),float4(col.x,col.y,col.z,color.w/(_dof_rings*_dof_rings)),1);\n    \}\n  \}\n\}\n//-------END OF BOKEH FUNCTIONS---------\n\n\n\n//-------------------------------------\n// Process\n//-------------------------------------\n  void process(int2 pos) \{\n    float4 _sample = ppos(pos.x,pos.y); //Get the XYZ Coordinates\n    float2 posf = float2(pos.x,pos.y);\n\n    if (_sample.w != 0.0f) \{  //No need to process if there is no data.\n\n      //Convert worldspace coordinates to screenspcace coordinates.\n      vWorld = float3(_sample.x,_sample.y,_sample.z)*(zoom);\n      int ret = computePixelCoordinates(vWorld, vRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1]);\n      if (ret) \{ //Only create points that are visible on screen\n        if (_pointRender)\{\n          point_render(pos,vRaster);\n        \}\n      \} //Pointrender over\n\n      if (_wireRender && _maxPlexConnections>=1) \{\n        if (max(pos.x,pos.y)<=max_line_connections || (_maxPlexType==0))\{ // Don't process more wires than allowed in nearest mode.\n          wire_render(pos);\n        \}\n      \} //WireRender over\n\n      if (_facetRender) \{\n        facet_render(pos,float3(_sample.x,_sample.y,_sample.z));\n      \}  //FacetRender over\n      \n    \}\n  \} //----> process\n\};\n"
  useGPUIfAvailable false
  rebuild ""
  PointRender3D_cam_Matrix {
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
    }
  PointRender3D_focallength {{parent.Camera1.focal}}
  PointRender3D_hapeture {{parent.Camera1.haperture}}
  PointRender3D_format {{Settings_Format.width} {Settings_Format.height}}
  PointRender3D_vertexformat {{parent.InputFormat.box.r-1} {parent.InputFormat.box.t-1}}
  PointRender3D__alphaMultiplier {{parent.AlphaMultiplier}}
  PointRender3D__pointRender {{parent.RenderMode==0}}
  PointRender3D__wireRender {{parent.RenderMode==1}}
  PointRender3D__facetRender {{parent.RenderMode==2}}
  PointRender3D__maxLDistance {{parent.wire_maxdistance}}
  PointRender3D__maxLConnections {{parent.wire_connections}}
  PointRender3D__maxPlexType {{-parent.wire_type}}
  PointRender3D__plexLinedefXY {{!parent.connect_xy}}
  PointRender3D__plexLinedefX {{!parent.connect_x}}
  PointRender3D__plexLinedefY {{!parent.connect_y}}
  PointRender3D__plexLinedefAUX {{!connect_aux}}
  PointRender3D__plexConnectX {{parent.CloseX}}
  PointRender3D__plexConnectY {{parent.CloseY}}
  PointRender3D__L_gamma {{parent.wire_Threshold}}
  "PointRender3D_Enable Depth of Field" {{parent.dof_enable}}
  PointRender3D_samples {{3*(parent.Dof_Quality*parent.Dof_Quality+1)}}
  PointRender3D_rings {{3*(parent.Dof_Quality*parent.Dof_Quality+1)}}
  PointRender3D_focalDepth {{parent.dof_focaldepth}}
  PointRender3D__depthOfField {{parent.dof_dof}}
  PointRender3D__depthMult {{parent.DofMultiplier}}
  PointRender3D__maxDofSize {{parent.dof_maxSize*400}}
  PointRender3D_dof_aspect {{parent.dof_Aspect}}
  PointRender3D_dof_bias {{parent.dof_bias}}
  PointRender3D__flatshading {{parent.facet_flatShading}}
  PointRender3D__backfacing {{parent.facet_backface}}
  PointRender3D__frontfacing {{parent.facet_front}}
  PointRender3D__vertexMode {{parent.renderMode}}
  PointRender3D__depthBuffer {{parent.facet_depth}}
  PointRender3D__texoffset {-0.5 0.5}
  PointRender3D__pointSize 0
  PointRender3D__depthOcclusion {{parent.UseOcclusionMap}}
  PointRender3D__maxLineSteps {{parent.maxSamples}}
  PointRender3D__lineOffset {{parent.lineoffset}}
  PointRender3D__lineInMultiplier {{parent.inGain}}
  PointRender3D__lineOutMultiplier {{parent.outGain}}
  format "1280 720 0 0 1280 720 1 HD_720"
  rebuild_finalise ""
  name BlinkScript1
  selected true
  xpos -27
  ypos 159
 }
 Reformat {
  format {{{Settings_Format.format}}}
  resize none
  center false
  name Reformat1
  xpos -27
  ypos 343
 }
 Group {
  name SoftLook
  xpos -27
  ypos 460
  disable {{!parent.HighlightCompression}}
  addUserKnob {20 User}
  addUserKnob {26 ""}
  addUserKnob {7 Add R 0 4}
  Add {{parent.HighlightCeiling}}
  addUserKnob {7 Offset R 0 4}
  Offset {{parent.Compression}}
 }
  Input {
   inputs 0
   name Input1
   xpos -248
   ypos 500
  }
set N547102c0 [stack 0]
  Expression {
   expr0 r/(r+parent.Offset)*parent.Add
   expr1 g/(g+parent.Offset)*parent.Add
   expr2 b/(b+parent.Offset)*parent.Add
   expr3 a/(a+parent.Offset)*parent.Add
   name Expression1
   xpos -339
   ypos 576
  }
push $N547102c0
  ShuffleCopy {
   inputs 2
   red red
   green green
   blue blue
   alpha alpha2
   name ShuffleCopy1
   xpos -248
   ypos 576
  }
  Output {
   name Output1
   xpos -248
   ypos 651
  }
 end_group
 TimeBlur {
  divisions {{parent.Samples}}
  shutter {{parent.Shutter}}
  shutteroffset centred
  shuttercustomoffset 0
  name MotionBlur
  xpos -27
  ypos 581
  disable {{1-parent.mb_enable x89 0}}
 }
 ShuffleCopy {
  inputs 2
  in pos
  red red
  green green
  blue blue
  out pos
  name ShuffleCopy1
  xpos -27
  ypos 673
  disable true
 }
 Output {
  name Output1
  xpos -27
  ypos 710
 }
 Input {
  inputs 0
  name InputCamera
  xpos -1129
  ypos 116
  number 1
 }
 Camera2 {
  focal {{parent.FocalLength}}
  haperture {{parent.horizontalApeture}}
  name Camera1
  xpos -1119
  ypos 223
  addUserKnob {20 Ivy}
  addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.toolbox.v1.nodes.docs', fromlist=\['open_docs_name']).open_docs_name('IvyTab')" +STARTLINE}
  addUserKnob {26 divider4 l "" +STARTLINE}
  addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
  _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
  addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
  addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
  addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
  _expressions {{curve}}
  addUserKnob {26 divider0 l "" +STARTLINE}
  addUserKnob {20 dbinfo l "DB Info" n 1}
  dbinfo 0
  addUserKnob {1 twig_dnuuid l "Twig Id"}
  addUserKnob {1 stalk_dnuuid l "Stalk Id"}
  addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
  addUserKnob {1 leaf_dnuuid l "Leaf Id"}
  addUserKnob {26 divider1 l "" +STARTLINE}
  addUserKnob {1 twigtype l "Twig Type"}
  addUserKnob {1 leaf_label l Leaf}
  addUserKnob {1 ivy_version l Version}
  addUserKnob {43 ivy_notes l Notes}
  addUserKnob {26 divider2 l "" +STARTLINE}
  addUserKnob {1 build_label l "Build Label"}
  addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
 }
 Reformat {
  inputs 0
  format "2156 1806 0 0 2156 1806 2 JOYRIDE Working"
  resize none
  center false
  name Settings_Format
  xpos -1404
  ypos 241
 }
push $N57800580
 PositionToPoints2 {
  display textured
  render_mode textured
  P_channel pos
  detail 0.25
  pointSize 0.6
  name PreviewNode
  xpos -22
  ypos 8
  disable {{!parent.Enable3DPreview}}
 }
push $N46df5350
 Reformat {
  type "to box"
  box_width 100
  box_height 100
  box_fixed true
  scale 0.1
  resize none
  filter impulse
  black_outside true
  name Reformat3
  xpos -633
  ypos -1109
  disable {{!wire_type==1}}
 }
push $N68147040
 Crop {
  box {0 0 {width} {height}}
  reformat true
  crop false
  name InputFormat
  xpos -456
  ypos -402
 }
end_group
TimeOffset {
 time_offset -1182
 time ""
 name TimeOffset7
 selected true
 xpos 11114
 ypos 32674
}
Dot {
 name Dot310
 selected true
 xpos 11148
 ypos 32933
}
FileOut {
 name FileOut6
 tile_color 0xbfbf00ff
 label 2DsmokeFX_2
 selected true
 xpos 11114
 ypos 32993
 icon smartgrade.png
 channels rgba
 _destination /jobs
 _stemstatus ""
 file ""
 proxy ""
 fileProxy ""
 views {main}
 first 1001
 last 1400
 pbb true
 smart_grade on
 dw_compression_level 0
 tex_metadata "default metadata and exr/*"
 disable_autolabel_format true
 _defaults "\{'smart_grade': 0, 'compression': 1, 'tile_color': 3216965887, 'pbb': True, 'dw_compression_level': 0, 'label': u'2DsmokeFX_2', 'exr_metadata': 2\}"
 _format ""
 _generator "NukeRenderGenerator dnnuke.core.render.v1"
 _ivyVals "\{'variant': None, 'host': None, 'versionNum': '1', 'twigType': 'spider://query@TwigType.one?TwigType.code==2d', 'twigNameTags': \{'subtask': u'precomp', 'task': u'comp', 'label': u'2DsmokeFX_2', 'out_dir': u'ELEMENT'\}, 'job': 'STONE', 'stalk': None, 'stalkAttrs': \{'framerange': '1017-1053'\}, 'twig': None, 'stem': 'spider://query@Stem.one?Stem.dnuuid==cfb45239-1375-4623-b0a4-12b2a5fba3d0&Stem.stemname==110_fof_0010&Stem.stemtype==shot'\}"
 _old_filetype exr
 _stalkname E_110_fof_0010_comp_precomp_2DsmokeFX_2_v001
 _twigtype 2d
 _wrapper "FileOut dnnuke.nodes.file_out.wrapper"
 beforeRender ""
 beforeFrameRender ""
 afterFrameRender ""
 afterRender ""
 renderProgress ""
 _invert_grade /tools/STONE/ivyasset/110_fof_0010/ivy/grade/GRD_110_fof_0010_neutral_v001/GRD_110_fof_0010_neutral_v001.grade
}
BagAndTagKeep {
 name BagAndTagKeep13
 selected true
 xpos 11114
 ypos 33103
}
Read {
 inputs 0
 file_type exr
 file /jobs/JOYRIDE/hap0850/ELEMENT/E_hap0850_comp_precomp_2DsmokeFX_2_v001/2156x1806/E_hap0850_comp_precomp_2DsmokeFX_2_v001.####.exr
 localizationPolicy off
 format "2156 1806 0 0 2156 1806 2 JOYRIDE Working"
 proxy_format "640 480 0 0 640 480 1 PC_Video"
 first 1001
 last 1400
 origfirst 1001
 origlast 1400
 origset true
 smartGrade true
 name Read270
 selected true
 xpos 11109
 ypos 33156
 postage_stamp_frame 1200
 addUserKnob {20 Ivy}
 addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.toolbox.v1.nodes.docs', fromlist=\['open_docs_name']).open_docs_name('IvyTab')" +STARTLINE}
 addUserKnob {26 divider4 l "" +STARTLINE}
 addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
 _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
 addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
 addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
 _ivyFile /jobs/JOYRIDE/hap0850/ELEMENT/E_hap0850_comp_precomp_2DsmokeFX_2_v001/2156x1806/E_hap0850_comp_precomp_2DsmokeFX_2_v001.####.exr
 addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
 _expressions {{curve}}
 addUserKnob {26 divider0 l "" +STARTLINE}
 addUserKnob {20 dbinfo l "DB Info" n 1}
 dbinfo 0
 addUserKnob {1 twig_dnuuid l "Twig Id"}
 twig_dnuuid b592375e-0cd3-439a-8a47-1c90296c0c62
 addUserKnob {1 stalk_dnuuid l "Stalk Id"}
 stalk_dnuuid 24a3e3d1-e1d8-4399-96d8-ff511b8b5dea
 addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
 twigtype_dnuuid e9f824fa-c932-4c3e-acbd-c612fb5ea846
 addUserKnob {1 leaf_dnuuid l "Leaf Id"}
 leaf_dnuuid 072ea0f3-a0a0-47e2-bd3e-7a17291fd551
 addUserKnob {26 divider1 l "" +STARTLINE}
 addUserKnob {1 twigtype l "Twig Type"}
 twigtype elmr
 addUserKnob {1 leaf_label l Leaf}
 leaf_label main_proxy0
 addUserKnob {1 ivy_version l Version}
 ivy_version 1
 addUserKnob {43 ivy_notes l Notes}
 addUserKnob {26 divider2 l "" +STARTLINE}
 addUserKnob {1 build_label l "Build Label"}
 addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
}
BagAndTagKeep {
 name BagAndTagKeep14
 selected true
 xpos 11109
 ypos 33329
}
push $N4782de30
Group {
 inputs 0
 name Point_Grid6
 tile_color 0x434343ff
 note_font_color 0x7dadf9ff
 selected true
 xpos 12474
 ypos 32137
 addUserKnob {20 User}
 addUserKnob {26 text l "" +STARTLINE T "Point Grid v1.0\n\nThis node generates a grid.\nAs it is defined in a non-euclidian space, \nmost of the shaders and wire or facet rendering won't work. "}
 addUserKnob {26 ""}
 addUserKnob {41 size_x l "Number of Points" T CONTROLER.size_x}
 addUserKnob {41 size_y l "" -STARTLINE T CONTROLER.size_y}
 addUserKnob {41 size_z l "" -STARTLINE T CONTROLER.size_z}
 addUserKnob {18 Position}
 Position {0 0 0}
 addUserKnob {6 Position_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Position_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Position_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {18 Scale}
 Scale {2 4 2}
 addUserKnob {6 Scale_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Scale_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Scale_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
}
 NoOp {
  inputs 0
  name CONTROLER
  xpos 224
  ypos -62
  addUserKnob {20 User}
  addUserKnob {3 VoxelDensity}
  VoxelDensity {{ceil(pow(size_x*size_y*size_z,1/3))}}
  addUserKnob {3 size_x l "Voxel Grid Size"}
  size_x 140
  addUserKnob {3 size_y l "" -STARTLINE}
  size_y 100
  addUserKnob {3 size_z l "" -STARTLINE}
  size_z 130
 }
 Crop {
  inputs 0
  box {0 0 {ceil(sqrt(pow(parent.CONTROLER.VoxelDensity,3)))} {sqrt(pow(parent.CONTROLER.VoxelDensity,3))}}
  reformat true
  crop false
  name Crop3
  xpos 372
  ypos -108
 }
 BlinkScript {
  recompileCount 9
  ProgramGroup 1
  KernelDescription "2 \"InvertKernel\" iterate pixelWise 21048e0522d3524e03cb582229852f2e33dbe569cd86686b92f460148f8700cf 2 \"src\" Read Point \"dst\" Write Point 1 \"Cube Size\" Int 3 IAAAACAAAAAgAAAAAAAAAA== 1 \"cube_size\" 3 1 0"
  kernelSource "kernel InvertKernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;  \n  Image<eWrite> dst;\n\n  param:\n    int3 cube_size;\n\n  local:\n    \n\n  void define() \{\n    defineParam(cube_size, \"Cube Size\", int3(32,32,32));\n  \}\n\n  void init() \{\n    \n  \}\n\n  void process(int2 pos) \{\n    int t_offset = (pos.x+(pos.y*src.bounds.width()));\n    float4 position;\n    float maxSize = max(max(cube_size.x,cube_size.y),cube_size.z);\n\n    position.x = fmod(t_offset,cube_size.x)/float(cube_size.x-1);\n    position.y = fmod(int(t_offset/cube_size.x),cube_size.y)/float(cube_size.y-1);\n    position.z = fmod(int(t_offset/(cube_size.x*cube_size.y)),cube_size.z)/float(cube_size.z-1);\n    position.w = 1-min(fmod(int(t_offset/(cube_size.x*cube_size.y*cube_size.z)),maxSize),1.0f);\n\n    dst() = float4(position.x*position.w,position.y*position.w,position.z*position.w,position.w);\n   \}\n\};\n\n"
  rebuild ""
  "InvertKernel_Cube Size" {{parent.CONTROLER.size_x} {parent.CONTROLER.size_y} {parent.CONTROLER.size_z}}
  rebuild_finalise ""
  name BlinkScript8
  selected true
  xpos 372
  ypos -79
 }
 Grade {
  add -0.5
  black_clamp false
  name Grade1
  xpos 372
  ypos -47
 }
 Grade {
  white {{parent.Scale.r} {parent.Scale.g} {parent.Scale.b} 0.9}
  add {{parent.Position.r} {parent.Position.g} {parent.Position.b} 0}
  black_clamp false
  name Grade2
  xpos 372
  ypos -26
 }
 Shuffle {
  red white
  green white
  blue white
  black red
  white green
  red2 blue
  green2 alpha
  out2 pos
  name Shuffle1
  xpos 372
  ypos -2
 }
 ModifyMetaData {
  metadata {
   {set pointrender/n_points "\[expr \[value parent.size_x]*\[value parent.size_y] *\[value parent.size_z]]"}
   {set pointrender/gen_type 3}
  }
  name SetMetaData
  xpos 372
  ypos 22
 }
 Grade {
  white {{1/((parent.size_x*parent.size_y*parent.size_z)/200000)}}
  black_clamp false
  name Grade9
  xpos 372
  ypos 46
 }
 Crop {
  box {0 0 {ceil(sqrt(pow(parent.CONTROLER.VoxelDensity,3)))} {sqrt(pow(parent.CONTROLER.VoxelDensity,3))}}
  crop false
  name Crop1
  xpos 372
  ypos 70
 }
 Output {
  name Output1
  xpos 372
  ypos 149
 }
end_group
Group {
 name Fractal4
 tile_color 0x434343ff
 note_font_color 0x7dadf9ff
 selected true
 xpos 12474
 ypos 32223
 addUserKnob {20 User t test}
 addUserKnob {26 _1 l "" +STARTLINE T "Point Fractal 1.0\n"}
 addUserKnob {26 devider_noise l "<b><font color=#7DADF9>Noise Settings</font><b>"}
 addUserKnob {6 Noise_Absolute l Absolute t "Negative values in the noise offset is made positive." +STARTLINE}
 addUserKnob {3 Noise_Octaves l Octaves}
 Noise_Octaves 8
 addUserKnob {7 Noise_Gain l Gain}
 Noise_Gain 0.3
 addUserKnob {7 Noise_Lacunarity l Lacunarity R 0 4}
 Noise_Lacunarity 1.18
 addUserKnob {18 Amplitude}
 Amplitude 0.4
 addUserKnob {6 Amplitude_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Amplitude_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Amplitude_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Amplitude_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {3 Itterations}
 Itterations 5
 addUserKnob {26 invis_devider_noise l "" +STARTLINE T " "}
 addUserKnob {26 Devider_Frequency l "<b><font color=#7DADF9>Freq Control</font><b>"}
 addUserKnob {19 Freq_Offset l "General Offset" t "This is like a 3D translation, letting you move the current noise pattern in the X, Y, Z and W (4th dimention)" R 0 10}
 Freq_Offset {0 0 0 0}
 addUserKnob {6 Freq_Offset_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_Offset_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_Offset_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_Offset_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_Offset_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 Freq_GeneralScale l "Genral Scale" t "This lets you control the scale of each individual noise axis."}
 Freq_GeneralScale {1 1 1 1}
 addUserKnob {6 Freq_GeneralScale_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_GeneralScale_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_GeneralScale_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_GeneralScale_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_GeneralScale_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {26 invis_devider_freq l "" +STARTLINE T " "}
 addUserKnob {19 Freq_EvolveLow l "Evolve Low" t "This lets you evolve (auto animate) the noise in a particular direction. The \"Low\" part means that this only affects the low frequencies.\n\nTo avoid a \"scrolling\" effect you can use the 4th dimention to break up the spatial cohearence." R 0 10}
 Freq_EvolveLow {3 0 0 0.5}
 addUserKnob {6 Freq_EvolveLow_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveLow_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveLow_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveLow_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveLow_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleLow_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 Freq_EvolveHigh l "Evolve High" t "This lets you evolve (auto animate) the noise in a particular direction. The \"High\" part means that this only affects the high frequencies.\n\nTo avoid a \"scrolling\" effect you can use the 4th dimention to break up the spatial cohearence."}
 Freq_EvolveHigh {0.9 0 -1 1}
 addUserKnob {6 Freq_EvolveHigh_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveHigh_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveHigh_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveHigh_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveHigh_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {26 invis_devider_freq2 l "" +STARTLINE T " "}
 addUserKnob {19 Freq_ScaleLow l "Scale Low" t "This lets you scale the noise in a particular axis. The \"Low\" part means that this only affects the low frequencies."}
 Freq_ScaleLow {2 2 2 2}
 addUserKnob {6 Freq_ScaleLow_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleLow_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleLow_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleLow_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleLow_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 Freq_ScaleHigh l "Scale High" t "This lets you scale the noise in a particular axis. The \"High\" part means that this only affects the high frequencies."}
 Freq_ScaleHigh {2 2 2 2}
 addUserKnob {6 Freq_ScaleHigh_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleHigh_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleHigh_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleHigh_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleHigh_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {26 invis_devider_freq3 l "" +STARTLINE T " "}
 addUserKnob {26 Curve l "<b><font color=#7DADF9>Curve Noise</font><b>"}
 addUserKnob {6 CurveNoise_Enable l Enable t "Adds a gamma curve to the noise intensity making noise near the \"Offset\" value more flat. This is a experimental feature." +STARTLINE}
 addUserKnob {6 CurveNoise_Invert l Invert t "Inverts the effect of the curved noise." -STARTLINE}
 addUserKnob {7 CurveGain l "Curve Gain" R -10 10}
 CurveGain 3
 addUserKnob {7 CurveOffset R -2 2}
 addUserKnob {26 gabgen l "" +STARTLINE T "\n"}
 addUserKnob {26 info_mask l "<b><font color=#7DADF9>Mask</font><b>"}
 addUserKnob {41 maskChannelMask l "" t "If a node is connected to the mask input, this will let you mask off the effect of the noise.\nIts recommended that you use the Point_Texture node to ensure a correct aspect and size." -STARTLINE T Merge1.maskChannelMask}
 addUserKnob {41 inject -STARTLINE T Merge1.inject}
 addUserKnob {41 invert_mask l invert -STARTLINE T Merge1.invert_mask}
 addUserKnob {41 fringe -STARTLINE T Merge1.fringe}
 addUserKnob {41 mix T Merge1.mix}
}
 Input {
  inputs 0
  name InputMask
  xpos -714
  ypos 207
  number 1
 }
 Reformat {
  type "to box"
  box_width {{parent.InputFormat.box.r}}
  box_height {{parent.InputFormat.box.t}}
  box_fixed true
  resize distort
  name Reformat2
  xpos -714
  ypos 306
 }
 Shuffle {
  name Shuffle3
  xpos -714
  ypos 330
 }
 Input {
  inputs 0
  name InputData
  xpos -582
  ypos 73
 }
 Dot {
  name Dot1
  xpos -548
  ypos 114
 }
set N46741e50 [stack 0]
 Shuffle {
  in pos
  name Shuffle1
  xpos -470
  ypos 110
 }
 BlinkScript {
  kernelSourceFile /Users/madshagbarth/Github/Nuke-Private/Blink/PointRender/Modify/Fractal_v06.cpp
  recompileCount 60
  ProgramGroup 1
  KernelDescription "2 \"Noise4D\" iterate pixelWise d54284af3e5573ad197bef9032773e8653de2cad590694fcc9fd5af993e97da3 2 \"src\" Read Point \"dst\" Write Point 17 \"absNoise\" Bool 1 AA== \"curveNoise\" Bool 1 AA== \"curveInvert\" Bool 1 AA== \"curveGain\" Float 1 AACAPw== \"curveOffset\" Float 1 AACAPw== \"Octaves\" Int 1 CgAAAA== \"Gain\" Float 1 AAAAPw== \"Lacunarity\" Float 1 AAAAQA== \"Gamma\" Float 1 AAAAPw== \"amplitude\" Float 3 AAAAPwAAAD8AAAA/AAAAAA== \"itterations\" Int 1 AQAAAA== \"Offset\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"Scale\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"suboffset\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"topoffset\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"subscale\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"topscale\" Float 4 AACAPwAAgD8AAIA/AACAPw== 17 \"absNoise\" 1 1 \"curveNoise\" 1 1 \"curveInvert\" 1 1 \"curveGain\" 1 1 \"curveOffset\" 1 1 \"octaves\" 1 1 \"gain\" 1 1 \"lacunarity\" 1 1 \"gamma\" 1 1 \"amplitude\" 3 1 \"itterations\" 1 1 \"offset\" 4 1 \"scale\" 4 1 \"suboffset\" 4 1 \"topoffset\" 4 1 \"subscale\" 4 1 \"topscale\" 4 1 0"
  kernelSource "//Based on https://github.com/Draradech/csworldgen/blob/master/simplexnoise.cpp\n//Ported by Mads Hagbarth Lund 2014\n\n/* Copyright (c) 2007-2012 Eliot Eshelman\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n\nint fastfloor( const float x ) \{ return x > 0 ? (int) x : (int) x - 1; \}\ninline float raw_noise_4d( const float x, const float y, const float z, const float w ) \n\{\nint simplex\[64]\[4] = \{\n    \{0,1,2,3\},\{0,1,3,2\},\{0,0,0,0\},\{0,2,3,1\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{1,2,3,0\},\n    \{0,2,1,3\},\{0,0,0,0\},\{0,3,1,2\},\{0,3,2,1\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{1,3,2,0\},\n    \{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\n    \{1,2,0,3\},\{0,0,0,0\},\{1,3,0,2\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{2,3,0,1\},\{2,3,1,0\},\n    \{1,0,2,3\},\{1,0,3,2\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{2,0,3,1\},\{0,0,0,0\},\{2,1,3,0\},\n    \{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\n    \{2,0,1,3\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{3,0,1,2\},\{3,0,2,1\},\{0,0,0,0\},\{3,1,2,0\},\n    \{2,1,0,3\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{3,1,0,2\},\{0,0,0,0\},\{3,2,0,1\},\{3,2,1,0\}\n\};\n    int perm\[512] = \{\n        151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,\n        8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,\n        35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,\n        134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,\n        55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208, 89,\n        18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,\n        250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,\n        189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,\n        172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,\n        228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,\n        107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,\n        138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180,\n\n        151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,\n        8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,\n        35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,\n        134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,\n        55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208, 89,\n        18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,\n        250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,\n        189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,\n        172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,\n        228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,\n        107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,\n        138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180\n    \};\n   int grad4\[32]\[4]= \{\n    \{0,1,1,1\},  \{0,1,1,-1\},  \{0,1,-1,1\},  \{0,1,-1,-1\},\n    \{0,-1,1,1\}, \{0,-1,1,-1\}, \{0,-1,-1,1\}, \{0,-1,-1,-1\},\n    \{1,0,1,1\},  \{1,0,1,-1\},  \{1,0,-1,1\},  \{1,0,-1,-1\},\n    \{-1,0,1,1\}, \{-1,0,1,-1\}, \{-1,0,-1,1\}, \{-1,0,-1,-1\},\n    \{1,1,0,1\},  \{1,1,0,-1\},  \{1,-1,0,1\},  \{1,-1,0,-1\},\n    \{-1,1,0,1\}, \{-1,1,0,-1\}, \{-1,-1,0,1\}, \{-1,-1,0,-1\},\n    \{1,1,1,0\},  \{1,1,-1,0\},  \{1,-1,1,0\},  \{1,-1,-1,0\},\n    \{-1,1,1,0\}, \{-1,1,-1,0\}, \{-1,-1,1,0\}, \{-1,-1,-1,0\}\n   \};\n    float F4 = (sqrt(5.0f)-1.0f)/4.0f;\n    float G4 = (5.0f-sqrt(5.0f))/20.0f;\n    float n0, n1, n2, n3, n4;\n    float s = (x + y + z + w) * F4;\n    int i = fastfloor(x + s);\n    int j = fastfloor(y + s);\n    int k = fastfloor(z + s);\n    int l = fastfloor(w + s);\n    float t = (i + j + k + l) * G4;\n    float X0 = i - t;\n    float Y0 = j - t;\n    float Z0 = k - t;\n    float W0 = l - t;\n\n    float x0 = x - X0;\n    float y0 = y - Y0;\n    float z0 = z - Z0;\n    float w0 = w - W0;\n    int c1 = (x0 > y0) ? 32 : 0;\n    int c2 = (x0 > z0) ? 16 : 0;\n    int c3 = (y0 > z0) ? 8 : 0;\n    int c4 = (x0 > w0) ? 4 : 0;\n    int c5 = (y0 > w0) ? 2 : 0;\n    int c6 = (z0 > w0) ? 1 : 0;\n    int c = c1 + c2 + c3 + c4 + c5 + c6;\n\n    int i1, j1, k1, l1;\n    int i2, j2, k2, l2;\n    int i3, j3, k3, l3;\n    i1 = simplex\[c]\[0]>=3 ? 1 : 0;\n    j1 = simplex\[c]\[1]>=3 ? 1 : 0;\n    k1 = simplex\[c]\[2]>=3 ? 1 : 0;\n    l1 = simplex\[c]\[3]>=3 ? 1 : 0;\n    i2 = simplex\[c]\[0]>=2 ? 1 : 0;\n    j2 = simplex\[c]\[1]>=2 ? 1 : 0;\n    k2 = simplex\[c]\[2]>=2 ? 1 : 0;\n    l2 = simplex\[c]\[3]>=2 ? 1 : 0;\n    i3 = simplex\[c]\[0]>=1 ? 1 : 0;\n    j3 = simplex\[c]\[1]>=1 ? 1 : 0;\n    k3 = simplex\[c]\[2]>=1 ? 1 : 0;\n    l3 = simplex\[c]\[3]>=1 ? 1 : 0;\n    float x1 = x0 - i1 + G4;\n    float y1 = y0 - j1 + G4;\n    float z1 = z0 - k1 + G4;\n    float w1 = w0 - l1 + G4;\n    float x2 = x0 - i2 + 2.0*G4;\n    float y2 = y0 - j2 + 2.0*G4;\n    float z2 = z0 - k2 + 2.0*G4;\n    float w2 = w0 - l2 + 2.0*G4;\n    float x3 = x0 - i3 + 3.0*G4;\n    float y3 = y0 - j3 + 3.0*G4;\n    float z3 = z0 - k3 + 3.0*G4;\n    float w3 = w0 - l3 + 3.0*G4;\n    float x4 = x0 - 1.0 + 4.0*G4;\n    float y4 = y0 - 1.0 + 4.0*G4;\n    float z4 = z0 - 1.0 + 4.0*G4;\n    float w4 = w0 - 1.0 + 4.0*G4;\n    int ii = i & 255;\n    int jj = j & 255;\n    int kk = k & 255;\n    int ll = l & 255;\n    int gi0 = perm\[ii+perm\[jj+perm\[kk+perm\[ll]]]] % 32;\n    int gi1 = perm\[ii+i1+perm\[jj+j1+perm\[kk+k1+perm\[ll+l1]]]] % 32;\n    int gi2 = perm\[ii+i2+perm\[jj+j2+perm\[kk+k2+perm\[ll+l2]]]] % 32;\n    int gi3 = perm\[ii+i3+perm\[jj+j3+perm\[kk+k3+perm\[ll+l3]]]] % 32;\n    int gi4 = perm\[ii+1+perm\[jj+1+perm\[kk+1+perm\[ll+1]]]] % 32;\n    float t0 = 0.6 - x0*x0 - y0*y0 - z0*z0 - w0*w0;\n    if(t0<0) n0 = 0.0;\n    else \{\n        t0 *= t0;\n        n0 = t0 * t0 * dot(float4(grad4\[gi0]\[0],grad4\[gi0]\[2],grad4\[gi0]\[3],grad4\[gi0]\[3]), float4(x0, y0, z0, w0));\n    \}\n    float t1 = 0.6 - x1*x1 - y1*y1 - z1*z1 - w1*w1;\n    if(t1<0) n1 = 0.0;\n    else \{\n        t1 *= t1;\n        n1 = t1 * t1 * dot(float4(grad4\[gi1]\[0],grad4\[gi1]\[2],grad4\[gi1]\[3],grad4\[gi1]\[3]), float4(x1, y1, z1, w1));\n    \}\n    float t2 = 0.6 - x2*x2 - y2*y2 - z2*z2 - w2*w2;\n    if(t2<0) n2 = 0.0;\n    else \{\n        t2 *= t2;\n        n2 = t2 * t2 * dot(float4(grad4\[gi2]\[0],grad4\[gi2]\[2],grad4\[gi2]\[3],grad4\[gi2]\[3]), float4(x2, y2, z2, w2));\n    \}\n    float t3 = 0.6 - x3*x3 - y3*y3 - z3*z3 - w3*w3;\n    if(t3<0) n3 = 0.0;\n    else \{\n        t3 *= t3;\n        n3 = t3 * t3 * dot(float4(grad4\[gi3]\[0],grad4\[gi3]\[2],grad4\[gi3]\[3],grad4\[gi3]\[3]), float4(x3, y3, z3, w3));\n    \}\n    float t4 = 0.6 - x4*x4 - y4*y4 - z4*z4 - w4*w4;\n    if(t4<0) n4 = 0.0;\n    else \{\n        t4 *= t4;\n        n4 = t4 * t4 * dot(float4(grad4\[gi4]\[0],grad4\[gi4]\[2],grad4\[gi4]\[3],grad4\[gi4]\[3]), float4(x4, y4, z4, w4));\n    \}\n    return 27.0 * (n0 + n1 + n2 + n3 + n4);\n\}\n\n\n\n\nkernel Noise4D : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n  Image<eWrite, eAccessPoint> dst;\nparam:\n    bool absNoise;\n    bool curveNoise;\n    bool curveInvert;\n    float curveGain;\n    float curveOffset;\n    int octaves;\n    float gain;\n    float lacunarity;\n    float gamma;\n    float3 amplitude;\n    int itterations;\n    float4 offset;\n    float4 scale;\n    float4 suboffset;\n    float4 topoffset;\n    float4 subscale;\n    float4 topscale;\n\n\n  void define() \{\n        defineParam (absNoise, \"absNoise\", false);    \n        defineParam (curveNoise, \"curveNoise\", false);    \n        defineParam (curveInvert, \"curveInvert\", false);   \n        defineParam (curveGain, \"curveGain\", 1.0f);\n        defineParam (curveOffset, \"curveOffset\", 1.0f);\n        defineParam (octaves, \"Octaves\", 10);\n        defineParam (gain, \"Gain\", 0.5f);\n        defineParam (lacunarity, \"Lacunarity\", 2.0f);\n        defineParam (gamma, \"Gamma\", 0.5f);\n        defineParam (amplitude, \"amplitude\", float3(0.5f));\n        defineParam (itterations, \"itterations\", 1);\n        defineParam(offset, \"Offset\", float4(0.0f, 0.0f, 0.0f,0.0f));\n        defineParam(scale, \"Scale\", float4(1.0f, 1.0f, 1.0f,1.0f));\n        defineParam(suboffset, \"suboffset\", float4(1.0f, 1.0f, 1.0f,1.0f));\n        defineParam(topoffset, \"topoffset\", float4(1.0f, 1.0f, 1.0f,1.0f));\n        defineParam(subscale, \"subscale\", float4(1.0f, 1.0f, 1.0f,1.0f));\n        defineParam(topscale, \"topscale\", float4(1.0f, 1.0f, 1.0f,1.0f));        \n  \}\n\nfloat octave_noise_4d( const float octaves, const float persistence, const float scale, const float x, const float y, const float z, const float w ) \n\{\n    float total = 0.0f;\n    float current;\n    float last = 1.0f;\n    float frequency = scale;\n    float amplitude = 1.0f;\n    float maxAmplitude = 0.0f;\n    float4 Tempoffset;\n    float4 Tempscale;\n\n\n    for( int i=0; i < octaves; i++ ) \{\n\n        /*\n        if (i == 0) \{\n            total += (float)raw_noise_4d( (x+suboffset.x) * frequency, (y+suboffset.y) * frequency, (z+suboffset.z) * frequency, (w+suboffset.w) * frequency ) * amplitude;\n        \}\n        else if (i == octaves-1) \{\n            total += (float)raw_noise_4d( (x+topoffset.x) * frequency, (y+topoffset.y) * frequency, (z+topoffset.z) * frequency, (w+topoffset.w) * frequency ) * amplitude;\n        \}\n        else \{\n            total += (float)raw_noise_4d( x * frequency, y * frequency, z * frequency, w * frequency ) * amplitude;\n        \}\n        */\n\n\n        Tempscale = (topscale * (i/(octaves-1.0f)))+(subscale * (1-(i/(octaves-1.0f))));       \n        Tempoffset = (topoffset * (i/(octaves-1.0f)))+(suboffset * (1-(i/(octaves-1.0f))));\n        current = (float)raw_noise_4d(   ((x*Tempscale.x)+Tempoffset.x) * frequency, \n                                        ((y*Tempscale.y)+Tempoffset.y) * frequency, \n                                        ((z*Tempscale.z)+Tempoffset.z) * frequency, \n                                        ((w*Tempscale.w)+Tempoffset.w) * frequency \n                                        ) * amplitude;\n        if (i == 0 && curveNoise)\{\n            if (curveInvert)\{\n                last = 0.5f-current;  \n            \}\n            else\{\n                last = current;  \n            \}\n               \n        \}\n        current = curveNoise?current*((last+curveOffset)*curveGain):current;\n        total += absNoise?fabs(current):current;\n        frequency *= 2.0f;\n        maxAmplitude += amplitude;\n        amplitude *= persistence;\n\n    \}\n    return float(total / maxAmplitude);\n\}\n\n\n\n\n  void process() \{\n    float4 srcSample = float4(src(0),src(1),src(2),src(3));\n    float sampleR,sampleG,sampleB;\n    for( int i=0; i < itterations; i++ ) \{\n        sampleR = (float)octave_noise_4d(float(octaves), gain, lacunarity, ( srcSample.x * scale.x ) + offset.x, ( srcSample.y * scale.y ) + offset.y,  ( srcSample.z * scale.z ) + offset.z, ( srcSample.w * scale.w ) + offset.w) * amplitude.x;\n        sampleG = (float)octave_noise_4d(float(octaves), gain, lacunarity, ( srcSample.x * scale.x ) + offset.x, ( srcSample.y * scale.y ) + offset.y,  ( srcSample.z * scale.z ) + offset.z, ( srcSample.w * scale.w ) + offset.w - 100.0f) * amplitude.y;\n        sampleB = (float)octave_noise_4d(float(octaves), gain, lacunarity, ( srcSample.x * scale.x ) + offset.x, ( srcSample.y * scale.y ) + offset.y,  ( srcSample.z * scale.z ) + offset.z, ( srcSample.w * scale.w ) + offset.w + 200.0f) * amplitude.z;\n        srcSample = float4(srcSample.x+sampleR,srcSample.y+sampleG,srcSample.z+sampleB,srcSample.w);\n    \}\n    dst() = float4(srcSample.x,srcSample.y,srcSample.z,1.0f);\n\}\n\};"
  rebuild ""
  Noise4D_curveNoise {{parent.CurveNoise_Enable}}
  Noise4D_curveInvert {{parent.CurveNoise_Invert}}
  Noise4D_curveGain {{parent.CurveGain}}
  Noise4D_curveOffset {{parent.CurveOffset}}
  Noise4D_Octaves {{parent.Noise_Octaves}}
  Noise4D_Gain {{parent.Noise_Gain}}
  Noise4D_Lacunarity {{parent.Noise_Lacunarity}}
  Noise4D_Gamma 0.79
  Noise4D_amplitude {{parent.Amplitude.r} {parent.Amplitude.g} {parent.Amplitude.b}}
  Noise4D_itterations {{parent.Itterations}}
  Noise4D_Offset {{parent.Freq_Offset} {parent.Freq_Offset} {parent.Freq_Offset} {parent.Freq_Offset}}
  Noise4D_Scale {{parent.Freq_GeneralScale} {parent.Freq_GeneralScale} {parent.Freq_GeneralScale} {parent.Freq_GeneralScale}}
  Noise4D_suboffset {{(frame*parent.Freq_EvolveLow.r)/50} {(frame*parent.Freq_EvolveLow.g)/50} {(frame*parent.Freq_EvolveLow.b)/50} {(frame*parent.Freq_EvolveLow.a)/50}}
  Noise4D_topoffset {{(frame*parent.Freq_EvolveHigh.r)/10} {(frame*parent.Freq_EvolveHigh.g)/10} {(frame*parent.Freq_EvolveHigh.b)/10} {(frame*parent.Freq_EvolveHigh.a)/10}}
  Noise4D_subscale {{parent.Freq_ScaleLow} {parent.Freq_ScaleLow} {parent.Freq_ScaleLow} {parent.Freq_ScaleLow}}
  Noise4D_topscale {{parent.Freq_ScaleHigh} {parent.Freq_ScaleHigh} {parent.Freq_ScaleHigh} {parent.Freq_ScaleHigh}}
  rebuild_finalise ""
  name Noise4D1
  selected true
  xpos -470
  ypos 177
 }
 Expression {
  expr0 abs(r)
  expr1 abs(g)
  expr2 abs(b)
  name Expression2
  xpos -470
  ypos 259
  disable {{!parent.Noise_Absolute}}
 }
 Shuffle {
  out pos
  name Shuffle2
  xpos -470
  ypos 330
 }
push $N46741e50
 Merge2 {
  inputs 2+1
  operation copy
  bbox B
  Achannels {pos.red pos.green pos.blue -pos.alpha}
  Bchannels {pos.red pos.green pos.blue -pos.alpha}
  output {pos.red pos.green pos.blue -pos.alpha}
  maskChannelMask -rgba.alpha
  name Merge1
  xpos -582
  ypos 326
 }
 Output {
  name Output1
  xpos -582
  ypos 497
 }
push $N46741e50
 Crop {
  box {0 0 {width} {height}}
  reformat true
  crop false
  name InputFormat
  xpos -713
  ypos 111
 }
end_group
set N466f8cb0 [stack 0]
Dot {
 name Dot311
 selected true
 xpos 12381
 ypos 32227
}
push $N466f8cb0
Dot {
 name Dot312
 selected true
 xpos 12508
 ypos 32404
}
Group {
 inputs 2
 name Point_OffsetShader6
 tile_color 0x434343ff
 note_font_color 0x55ffffff
 selected true
 xpos 12347
 ypos 32400
 addUserKnob {20 User}
 addUserKnob {26 info l "" +STARTLINE T "Point Offset Shader v1.0\n\nCalcualtes the distance between 2 point sets.\nThis can for example be used to see the difference between the original generator\nand the modified one."}
 addUserKnob {26 devider_general l "<b><font color=#70EE70>General</font><b>"}
 addUserKnob {7 Gain}
 Gain 3
 addUserKnob {7 Offset R -0.5 0.5}
 Offset -0.1
 addUserKnob {6 Absolute +STARTLINE}
 Absolute true
 addUserKnob {6 Reverse +STARTLINE}
}
 BackdropNode {
  inputs 0
  name BackdropNode1
  tile_color 0x388e8e00
  label Offset
  note_font_size 42
  xpos -591
  ypos 304
  bdwidth 224
  bdheight 161
 }
 Input {
  inputs 0
  name Input2
  xpos -438
  ypos 40
  number 1
 }
 Shuffle {
  in pos
  name Shuffle1
  xpos -438
  ypos 120
 }
 Dot {
  name Dot4
  xpos -404
  ypos 285
 }
 Dot {
  name Dot1
  xpos -404
  ypos 392
 }
 Input {
  inputs 0
  name Input1
  xpos -580
  ypos 50
 }
 Shuffle {
  in pos
  name Shuffle5
  xpos -580
  ypos 120
 }
 Dot {
  name Dot3
  xpos -546
  ypos 256
 }
 MergeExpression {
  inputs 2
  temp_name0 xd
  temp_expr0 A.red-B.red
  temp_name1 yd
  temp_expr1 A.green-B.green
  temp_name2 zd
  temp_expr2 A.blue-B.blue
  temp_name3 Distance
  temp_expr3 "sqrt(xd*xd + yd*yd + zd*zd)"
  expr0 Distance
  expr1 Distance
  expr2 Distance
  name Distance
  xpos -584
  ypos 388
 }
 Grade {
  add {{parent.Offset}}
  black_clamp false
  name Grade3
  xpos -584
  ypos 412
 }
 Grade {
  white {{parent.Gain}}
  black_clamp {{!parent.Absolute}}
  name Grade1
  xpos -584
  ypos 436
 }
 Expression {
  expr0 abs(r)
  expr1 abs(g)
  expr2 abs(b)
  name Expression1
  xpos -584
  ypos 459
  disable {{!parent.Absolute}}
 }
 Expression {
  expr0 max(0,1-r)
  expr1 max(0,1-r)
  expr2 max(0,1-r)
  name Expression2
  selected true
  xpos -584
  ypos 483
  disable {{!parent.Reverse}}
 }
 Group {
  name SoftLook_NF1
  xpos -584
  ypos 650
  disable true
  addUserKnob {20 User}
  addUserKnob {26 Info l "" +STARTLINE T "SoftLook\nby Mads Hagbarth Lund - 2016"}
  addUserKnob {26 ""}
  addUserKnob {7 Add R 0 4}
  Add 1.14
  addUserKnob {7 Offset R 0 4}
  Offset 0.86
 }
  Input {
   inputs 0
   name Input1
   xpos -248
   ypos 500
  }
set N46472560 [stack 0]
  Expression {
   expr0 r/(r+parent.Offset)*parent.Add
   expr1 g/(g+parent.Offset)*parent.Add
   expr2 b/(b+parent.Offset)*parent.Add
   expr3 a/(a+parent.Offset)*parent.Add
   name Expression1
   selected true
   xpos -339
   ypos 576
  }
push $N46472560
  ShuffleCopy {
   inputs 2
   red red
   green green
   blue blue
   alpha alpha2
   name ShuffleCopy1
   xpos -248
   ypos 576
  }
  Output {
   name Output1
   xpos -248
   ypos 651
  }
 end_group
 Output {
  name Output1
  xpos -584
  ypos 686
 }
end_group
Grade {
 white 1.3
 multiply {0.6887242198 0.9288096428 1 1}
 gamma {0.2101119161 0.3576882482 1 1}
 name Grade24
 selected true
 xpos 12347
 ypos 32480
}
Group {
 inputs 2
 name Point_Render7
 tile_color 0x434343ff
 note_font_color 0x7dadf9ff
 selected true
 xpos 12347
 ypos 32638
 addUserKnob {20 User l "Point Render" t dd}
 addUserKnob {26 info_header l "" +STARTLINE T "Point Render v1.0"}
 addUserKnob {26 devider_general l "<b><font color=#7DADF9>General</font><b>"}
 addUserKnob {4 RenderMode l "Render Mode" t "Some generators support multiple render modes other than just point rendering. This should be considered a experimental feature, but can be used to great effect.\n\nIn the Render Settings tab you can find more controls relating to Wire and Facet rendering modes.\n\nNote that Facet Render can be slow when really close to a object. " M {"Point Render" "Wire Render" "Facet Render (experimental)" "" "" ""}}
 addUserKnob {7 FocalLength l "Focal Length" t "The point render does not take the focal length from the input camera, so if you want to match it to a camera you should link the focal length from the camera to this." R 0 200}
 FocalLength 20
 addUserKnob {7 horizontalApeture l "Horiz Apeture" R 0 100}
 horizontalApeture 24.576
 addUserKnob {7 AlphaMultiplier l Exposure t "This is a general exposure modifier that lets you adjust the overall brightness of the render." R 0 2}
 AlphaMultiplier 0.15
 addUserKnob {6 UseOcclusionMap l "Use Occlusion Map" t "Enable the Occlusion map input. This lets you use a depth map as a holdout.\n\nNote:\nThe Red channal should contain the depth (absolute distance, not 1/depth)\nThe Alpha channal must be 1 for the areas that you want to holdout." +STARTLINE}
 addUserKnob {26 devider_cc l "<b><font color=#7DADF9>Preview</font><b>"}
 addUserKnob {6 FastPreview l "Fast Preview" t "Reduce the number of points for a quick preview of the final render." +STARTLINE}
 addUserKnob {6 HighlightCompression l "Hilight Compression" t "Compresses the highlights to make it easier to see bright details." +STARTLINE}
 addUserKnob {7 HighlightCeiling l "Highlight Ceiling" t "Adjust the cealing for the highlight compression." R 1 10}
 HighlightCeiling 1.15
 addUserKnob {7 Compression t "The compression amount." -STARTLINE R 0 5}
 Compression 1
 addUserKnob {26 devider_format l "<b><font color=#7DADF9>Format</font><b>"}
 addUserKnob {41 format l "output format" T Settings_Format.format}
 addUserKnob {20 WireRender l "Render Settings"}
 addUserKnob {26 devider_wirerender l "<b><font color=#7DADF9>Wire Rendering</font><b>"}
 addUserKnob {4 wire_type l "Connection Mode" t "*Normal\nConnect lines between the local neigbours of the 2d position map\n\n*Nearest\nConnect lines to the nearest points (in 3D space). This mode is limited to 100x100 points for performence reasons!" M {Normal Nearest "" "" "" "" "" "" "" ""}}
 addUserKnob {26 text l "Normal Mode Wires" T " "}
 addUserKnob {6 connect_x l x t "Connect wires in the (uv) X axis." -STARTLINE}
 connect_x true
 addUserKnob {6 connect_xy l xy t "Connect wires in the (uv) XY axis." -STARTLINE}
 connect_xy true
 addUserKnob {6 connect_y l y t "Connect wires in the (uv) Y axis." -STARTLINE}
 connect_y true
 addUserKnob {6 connect_aux l aux t "If you input a vector map into the Aux input for this node, and enable this option, you will get a wire from each point along that vector." -STARTLINE}
 addUserKnob {7 wire_maxdistance l "Max Distance" t "The maximum distance that the wires connect." R 0 10}
 wire_maxdistance 6
 addUserKnob {7 wire_Threshold l "Distance Threshold" t "Control the max distance threshold" R 0 2}
 wire_Threshold 0.5
 addUserKnob {3 wire_connections l "Max Connections" t "The maximum number of connections (Not Yet Implemented)"}
 wire_connections 4
 addUserKnob {7 maxSamples l "Max Line Samples" t "The maximum length of a line. Once a line is longer than this, it will start break up. \nThis can also be used as a creative effect if you set it low, try setting it to 10 in wire mode to get dotted lines" R 0 10000}
 maxSamples 10000
 addUserKnob {7 lineoffset l "Line Offset" t "Expand or contract the lines."}
 lineoffset 1
 addUserKnob {7 inGain l "In Gain" t "Gain the brightness of the in-point of the lines"}
 inGain 1
 addUserKnob {7 outGain l "Out Gain" t "Gain the brightness of the out-point of the lines" -STARTLINE}
 outGain 1
 addUserKnob {26 devider_facet l "<b><font color=#7DADF9>Facet Rendering</font><b>"}
 addUserKnob {4 renderMode l "Render Mode" t "Pick the desidered render mode." M {Diffuse "Local ST" Normal "Facing Ratio" UV ST "View Normal" "World Position" "" ""}}
 addUserKnob {6 facet_flatShading l "Flat Shading" t "Flat shading" +STARTLINE}
 addUserKnob {6 facet_depth l "Depth Buffer" t "Enable depth sorting to avoid additive surfaces." -STARTLINE}
 addUserKnob {6 facet_front l "Front Face" t "Render front facing facets" +STARTLINE}
 facet_front true
 addUserKnob {6 facet_backface l "Back Face" t "Render backfacing faces" -STARTLINE}
 facet_backface true
 addUserKnob {26 _1 l "<b><font color=#7DADF9>Other</font><b>"}
 addUserKnob {6 CloseX l "Close X" t "On spheres or round objects this closes the loop" +STARTLINE}
 addUserKnob {6 CloseY l "Close Y" t "On spheres or round objects this closes the loop" -STARTLINE}
 addUserKnob {20 Fog_1 l Fog}
 addUserKnob {26 Devider_Fog l "<b><font color=#7DADF9>Fog</font><b>"}
 addUserKnob {6 Fog t "Fog reduces the brightness of poins far from the camera." +STARTLINE}
 addUserKnob {7 FogNear l "Fog Near" R 0 200}
 FogNear 3
 addUserKnob {7 FogFar l "Fog Far" R 0 200}
 FogFar 10
 addUserKnob {7 FogExponent l "Fog Exponent" R 0 8}
 FogExponent 8
 addUserKnob {20 DepthOfField l "Depth of Field"}
 addUserKnob {26 devider_dof l "<b><font color=#7DADF9>Depth Of Field</font><b>"}
 addUserKnob {6 dof_enable l Enable +STARTLINE}
 addUserKnob {7 dof_focaldepth l "Focal Depth" R 0 40}
 dof_focaldepth 5
 addUserKnob {7 dof_dof l "Depth of Field" R 0 10}
 dof_dof 2
 addUserKnob {7 dof_maxSize l "Max Size"}
 dof_maxSize 0.5
 addUserKnob {7 dof_Aspect l "Aspect Ratio"}
 dof_Aspect 1
 addUserKnob {7 dof_bias l Bias R -3 3}
 dof_bias -0.2
 addUserKnob {4 Dof_Quality l Quality M {Low Medium High Extreme}}
 addUserKnob {20 MotionBlur}
 addUserKnob {26 devider_MotionBlur l "<b><font color=#7DADF9>Motion Blur</font><b>"}
 addUserKnob {6 mb_enable l Enable +STARTLINE}
 mb_enable true
 addUserKnob {6 Fast l "Fast (Interpolated)" -STARTLINE}
 Fast true
 addUserKnob {3 Samples}
 Samples 4
 addUserKnob {7 Shutter R 0 2}
 Shutter 0.5
 addUserKnob {4 pulldown l "Shutter Offset" M {Centered Start End ""}}
 addUserKnob {20 preview_3d l "3D Preview"}
 addUserKnob {6 Enable3DPreview l "Enable 3D Preview" t "Display a preview of the points in the Nuke 3D view." +STARTLINE}
 addUserKnob {41 pointSize l "point size" T PreviewNode.pointSize}
 addUserKnob {41 detail l "point detail" T PreviewNode.detail}
}
 BackdropNode {
  inputs 0
  name BackdropNode1
  tile_color 0x388e8e00
  label "Output Format Manager"
  note_font_size 22
  xpos -1491
  ypos 149
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode10
  tile_color 0x388e8e00
  label "AUX Input"
  note_font_size 22
  xpos -385
  ypos 178
  bdwidth 207
  bdheight 178
 }
 BackdropNode {
  inputs 0
  name BackdropNode11
  tile_color 0x388e8e00
  label "Point Render"
  note_font_size 22
  xpos -96
  ypos 99
  bdwidth 198
  bdheight 135
 }
 BackdropNode {
  inputs 0
  name BackdropNode12
  tile_color 0x388e8e00
  label "Normal Generator\nFor Vertex Normals"
  note_font_size 22
  xpos -616
  ypos 243
  bdwidth 191
  bdheight 122
 }
 BackdropNode {
  inputs 0
  name BackdropNode13
  tile_color 0x388e8e00
  label "Ensure output format"
  note_font_size 22
  xpos -622
  ypos -41
  bdwidth 198
  bdheight 135
 }
 BackdropNode {
  inputs 0
  name BackdropNode14
  tile_color 0x388e8e00
  label "Motion Blur"
  note_font_size 22
  xpos -85
  ypos 526
  bdwidth 193
  bdheight 91
 }
 BackdropNode {
  inputs 0
  name BackdropNode15
  tile_color 0x388e8e00
  label "Soft Preview"
  note_font_size 22
  xpos -83
  ypos 414
  bdwidth 191
  bdheight 94
 }
 BackdropNode {
  inputs 0
  name BackdropNode16
  tile_color 0x388e8e00
  label "Final format"
  note_font_size 22
  xpos -84
  ypos 295
  bdwidth 192
  bdheight 95
 }
 BackdropNode {
  inputs 0
  name BackdropNode17
  tile_color 0x388e8e00
  label "No Clue =)"
  note_font_size 22
  xpos -385
  ypos -41
  bdwidth 160
  bdheight 87
 }
 BackdropNode {
  inputs 0
  name BackdropNode2
  tile_color 0x388e8e00
  label Motionblur
  note_font_size 22
  xpos -672
  ypos -781
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode3
  tile_color 0x388e8e00
  label "Fast Preview"
  note_font_size 22
  xpos -669
  ypos -971
  bdwidth 254
  bdheight 138
 }
 BackdropNode {
  inputs 0
  name BackdropNode4
  tile_color 0x388e8e00
  label "Nearest Wire Mode Clamp"
  note_font_size 22
  xpos -666
  ypos -1184
  bdwidth 253
  bdheight 111
 }
 BackdropNode {
  inputs 0
  name BackdropNode5
  tile_color 0x388e8e00
  label Occlution
  note_font_size 22
  xpos 208
  ypos 27
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode6
  tile_color 0x388e8e00
  label "Input Camera Container"
  note_font_size 22
  xpos -1215
  ypos 148
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode7
  tile_color 0x388e8e00
  label "3D Preview"
  note_font_size 22
  xpos -88
  ypos -45
  bdwidth 207
  bdheight 102
 }
 BackdropNode {
  inputs 0
  name BackdropNode8
  tile_color 0x388e8e00
  label "Input Format Manager"
  note_font_size 22
  xpos -526
  ypos -459
  bdwidth 208
  bdheight 97
 }
 BackdropNode {
  inputs 0
  name BackdropNode9
  tile_color 0x388e8e00
  label FOG
  note_font_size 22
  xpos -602
  ypos -253
  bdwidth 370
  bdheight 152
 }
 Input {
  inputs 0
  name InputPointData
  xpos -584
  ypos -1321
 }
 Dot {
  name Dot4
  xpos -550
  ypos -1234
 }
set N4653c780 [stack 0]
 Reformat {
  type "to box"
  box_width 100
  box_height 100
  box_fixed true
  scale 0.1
  resize fill
  filter impulse
  black_outside true
  name Reformat5
  xpos -584
  ypos -906
  disable {{!parent.FastPreview==1}}
 }
 Grade {
  white 10
  name Grade2
  xpos -584
  ypos -874
  disable {{!parent.FastPreview}}
 }
 Dot {
  name Dot2
  xpos -550
  ypos -712
 }
set N46361c00 [stack 0]
 Group {
  name FrameHold3
  tile_color 0xb0a45dff
  label "(frame \[value first_frames])"
  xpos -501
  ypos -719
  disable {{1-parent.mb_enable}}
  addUserKnob {20 User}
  addUserKnob {3 first_frames l "first frame"}
  first_frames {{frame+1}}
  addUserKnob {41 increment T FrameHold2.increment}
  addUserKnob {22 SetCurrentFrame l "Set This Frame" T "nuke.thisNode()\[\"first_frames\"].setValue(nuke.frame())" +STARTLINE}
 }
  Input {
   inputs 0
   name Input1
   xpos -7
   ypos -154
  }
  FrameHold {
   first_frame {{parent.knob.first_frames}}
   name FrameHold2
   xpos -7
   ypos -114
  }
  Output {
   name Output1
   xpos -7
   ypos -14
  }
 end_group
 Dot {
  name Dot6
  xpos -467
  ypos -659
 }
push $N46361c00
 Group {
  name FrameHold2
  tile_color 0xb0a45dff
  label "(frame \[value first_frames])"
  xpos -660
  ypos -719
  disable {{1-parent.mb_enable}}
  addUserKnob {20 User}
  addUserKnob {3 first_frames l "first frame"}
  first_frames {{frame}}
  addUserKnob {41 increment T FrameHold2.increment}
  addUserKnob {22 SetCurrentFrame l "Set This Frame" T "nuke.thisNode()\[\"first_frames\"].setValue(nuke.frame())" +STARTLINE}
 }
  Input {
   inputs 0
   name Input1
   xpos -7
   ypos -154
  }
  FrameHold {
   first_frame {{parent.knob.first_frames}}
   name FrameHold2
   xpos -7
   ypos -114
  }
  Output {
   name Output1
   xpos -7
   ypos -14
  }
 end_group
 Dot {
  name Dot5
  xpos -626
  ypos -659
 }
 Dissolve {
  inputs 2
  which {{frame-floor(frame)}}
  name Dissolve1
  xpos -582
  ypos -666
  disable {{1-parent.mb_enable}}
 }
push $N46361c00
 Switch {
  inputs 2
  which {{parent.Fast}}
  name Switch2
  xpos -582
  ypos -619
 }
 Dot {
  name DataFetch
  label "data fetch\t"
  note_font_color 0xff21ff
  xpos -550
  ypos -513
  addUserKnob {20 User}
  addUserKnob {3 n_particles l "Number of Particles"}
  n_particles {{"\[metadata pointrender/n_points]"}}
  addUserKnob {3 gentype l "Type Of Generator"}
  gentype {{"\[metadata pointrender/gen_type]"}}
  addUserKnob {26 info l "" -STARTLINE T "0 = unknown, 1 = Card, 2 = Sphere, 3 = Grid"}
 }
set N463bd8a0 [stack 0]
 Dot {
  name Dot3
  xpos -635
  ypos -513
 }
 Dot {
  name Dot1
  xpos -635
  ypos 676
 }
 Input {
  inputs 0
  name InputOcclution
  xpos 238
  ypos 75
  number 2
 }
 Constant {
  inputs 0
  channels rgb
  color 1
  name Empty
  xpos 371
  ypos 139
 }
 Switch {
  inputs 2
  which {{parent.UseOcclusionMap}}
  name Switch1
  xpos 238
  ypos 163
 }
 Input {
  inputs 0
  name Aux
  xpos -324
  ypos 214
  number 3
 }
 Reformat {
  type "to box"
  format "1280 720 0 0 1280 720 1 HD_720"
  box_width {{input.width>Settings_Format.format.width?input.width:Settings_Format.format.width}}
  box_height {{input.height>Settings_Format.format.height?input.height:Settings_Format.format.height}}
  box_fixed true
  resize none
  center false
  filter impulse
  black_outside true
  name Reformat2
  xpos -324
  ypos 238
 }
 Crop {
  box {0 0 {input.width} {input.height}}
  name Crop1
  xpos -324
  ypos 275
 }
push $N463bd8a0
 Shuffle {
  in pos
  name Shuffle1
  xpos -584
  ypos -192
 }
set N464029c0 [stack 0]
 Reformat {
  type "to box"
  format "1280 720 0 0 1280 720 1 HD_720"
  box_width {{input.width>Settings_Format.format.width?input.width:Settings_Format.format.width}}
  box_height {{input.height>Settings_Format.format.height?input.height:Settings_Format.format.height}}
  box_fixed true
  resize none
  center false
  filter impulse
  black_outside true
  name Reformat4
  xpos -584
  ypos 18
 }
 Crop {
  box {0 0 {input.width} {input.height}}
  name Crop2
  xpos -584
  ypos 48
 }
 Dot {
  name Dot8
  xpos -550
  ypos 166
 }
set N4642d8e0 [stack 0]
 Group {
  name Point_Normal2
  tile_color 0x434343ff
  note_font_color 0x55ffffff
  xpos -584
  ypos 311
  disable {{!(renderMode==2&&RenderMode==2)}}
  addUserKnob {20 User}
  addUserKnob {26 info l "" +STARTLINE T "Point Normal v1.0"}
  addUserKnob {26 devider_general l "<b><font color=#7DADF9>General</font><b>"}
  addUserKnob {26 info_1 l "" +STARTLINE T "well, not much to do here =)"}
 }
  Input {
   inputs 0
   name Input1
   xpos 389
   ypos 207
  }
  Shuffle {
   in pos
   name Shuffle1
   xpos 389
   ypos 294
  }
  BlinkScript {
   kernelSourceFile /Users/madshagbarth/Github/Nuke-Private/Blink/PointRender/Modify/BasicLight.cpp
   recompileCount 69
   ProgramGroup 1
   KernelDescription "2 \"PointRender3D\" iterate pixelWise d5452fe7b684561fcfa5182d0c789025a037cc4fe4474c24e065e3fa53fcd8ce 2 \"ppos\" Read Random \"dst\" Write Point 9 \"cam_Matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== \"focallength\" Float 1 AAA4QQ== \"hapeture\" Float 1 ppvEQQ== \"format\" Int 2 AAgAAAAIAAA= \"Zoom\" Float 1 AACAPw== \"half Lambert\" Bool 1 AQ== \"light Mode\" Int 1 AAAAAA== \"light_position\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"light_color\" Float 3 AACAPwAAgD8AAIA/AAAAAA== 9 \"cam_Matrix\" 16 1 \"cam_Focal\" 1 1 \"cam_Hapeture\" 1 1 \"WHformat\" 2 1 \"zoom\" 1 1 \"halfLambert\" 1 1 \"lightMode\" 1 1 \"lightPos\" 3 1 \"lightcolor\" 3 1 10 \"vRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"pRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"tRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"vWorld\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"canvasWidth\" Float 1 1 AAAAAA== \"canvasHeight\" Float 1 1 AAAAAA== \"matrixData\" Float 1 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cameraToWorld\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"worldToCamera\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"namount\" Float 1 1 AAAAAA=="
   kernelSource "inline float Frac(float a_X)\n\{\n    return a_X-floor(a_X);\n\}\n\ninline float Fmax(float a_X,float b_X,float c_X)\n\{\n    return max(c_X,max(a_X,b_X));\n\}\ninline float Fmin(float a_X,float b_X,float c_X)\n\{\n    return min(c_X,min(a_X,b_X));\n\}\n\ninline float saturate(float _in)\n\{\n    return max(0.0f,min(1.0f,_in));\n\}\n\ninline float3 reflect(float3 incidence,float3 normal)\n\{\n  return incidence - 2.f * dot(incidence, normal) * normal;\n\}\n\n//This function is used to multiply a float3 by a matrix4x4\ninline float3 multVecMatrix( float3 src, float4x4 matrix)\n\{\n    float   x,y,z,w;\n    \n    x = src\[0]*matrix\[0]\[0] + src\[1]*matrix\[1]\[0] +\n    src\[2]*matrix\[2]\[0] + matrix\[3]\[0];\n    y = src\[0]*matrix\[0]\[1] + src\[1]*matrix\[1]\[1] +\n    src\[2]*matrix\[2]\[1] + matrix\[3]\[1];\n    z = src\[0]*matrix\[0]\[2] + src\[1]*matrix\[1]\[2] +\n    src\[2]*matrix\[2]\[2] + matrix\[3]\[2];\n    w = src\[0]*matrix\[0]\[3] + src\[1]*matrix\[1]\[3] +\n    src\[2]*matrix\[2]\[3] + matrix\[3]\[3];\n    \n    return float3(x/w, y/w, z/w);\n\}\n\n//This function is used to calculate the screenspace coordinates.\ninline bool computePixelCoordinates( \n    const float3 pWorld, \n    float3 &pRaster, \n    const float4x4 &worldToCamera, \n    const float &canvasWidth, \n    const float &canvasHeight, \n    const int &imageWidth, \n    const int &imageHeight\n) \n\{ \n    float3 pCamera; \n    pCamera = multVecMatrix(pWorld, worldToCamera); \n    float2 pScreen; \n    pScreen.x = pCamera.x / -pCamera.z; \n    pScreen.y = pCamera.y / -pCamera.z; \n    if (fabs(pScreen.x) > canvasWidth || fabs(pScreen.y) > canvasHeight) \n         return false; \n    float2 pNDC; \n    pNDC.x = (pScreen.x + canvasWidth * 0.5f) / canvasWidth; \n    pNDC.y = (pScreen.y + canvasHeight * 0.5f) / canvasHeight; \n    pRaster.x = (pNDC.x * imageWidth); \n    pRaster.y = ((pNDC.y) * imageHeight); \n    pRaster.z = -pCamera.z; \n    if (pRaster.x < 0.0f || pRaster.x > imageWidth || \n       pRaster.y < 0.0f || pRaster.y > imageHeight) \{\n       return false;  \n    \}\n    return true;\n\} \n\n\n\nkernel PointRender3D : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessRandom, eEdgeClamped> ppos;    //The point position map\n  Image<eWrite> dst;                 //the output image\n\n  param: //Parameters available to the user\n    float4x4 cam_Matrix;    //The world matrix of the camera\n    float cam_Focal;        //The focal length of the camera\n    float cam_Hapeture;     //The horizontal apeture of the camera\n    int2 WHformat;          //The format of the output image\n    float zoom;             //A \"post\" zoom function\n    bool halfLambert;\n    int lightMode;\n    float3 lightPos;\n    float3 lightcolor;\n\n\n  local: //Local variables\n    float3 vRaster;\n    float3 pRaster;\n    float3 tRaster;    \n    float3 vWorld;\n    float canvasWidth;\n    float canvasHeight; \n    float matrixData\[4]\[4];\n    float4x4 cameraToWorld;\n    float4x4 worldToCamera;\n    float namount; //dither amount\n\n\n  void define() \{\n    defineParam(cam_Matrix, \"cam_Matrix\", float4x4( 1.0f,0.0f,0.0f,0.0f,\n                                                    0.0f,1.0f,0.0f,0.0f,\n                                                    0.0f,0.0f,1.0f,0.0f,\n                                                    0.0f,0.0f,0.0f,1.0f));\n    defineParam(cam_Focal,      \"focallength\", 11.5f);\n    defineParam(cam_Hapeture,      \"hapeture\", 24.576f);\n    defineParam(WHformat,      \"format\", int2(2048,2048));\n    defineParam(zoom, \"Zoom\", 1.0f);\n    defineParam(halfLambert, \"half Lambert\", true);\n    defineParam(lightMode, \"light Mode\", 0);\n    defineParam(lightPos,      \"light_position\", float3(0,0,0));  \n    defineParam(lightcolor,      \"light_color\", float3(1.0,1.0,1.0)); \n  \}\n\n\n  //The init() function is run before any calls to process().\n  void init() \{\n    canvasWidth = ((cam_Hapeture)/cam_Focal);\n    canvasHeight = ((cam_Hapeture)/cam_Focal)*float(float(WHformat.y)/float(WHformat.x)); \n    float matrixData\[] = \{cam_Matrix\[0]\[0], cam_Matrix\[1]\[0], cam_Matrix\[2]\[0], cam_Matrix\[3]\[0], \n                          cam_Matrix\[0]\[1], cam_Matrix\[1]\[1], cam_Matrix\[2]\[1], cam_Matrix\[3]\[1], \n                          cam_Matrix\[0]\[2], cam_Matrix\[1]\[2], cam_Matrix\[2]\[2], cam_Matrix\[3]\[2], \n                          cam_Matrix\[0]\[3], cam_Matrix\[1]\[3], cam_Matrix\[2]\[3], cam_Matrix\[3]\[3]\};\n    cameraToWorld.setArray(matrixData); //This is a workaround. Due to the buggy matrix implementation, we pass the matrix on from another structure.\n    worldToCamera = cameraToWorld.invert();\n    namount = 0.0001; //dither amount\n  \}\n\n\n\nfloat3 Reconsile3D(float3 _PointPos)\{\n    vWorld = float3(_PointPos.x,_PointPos.y,_PointPos.z)*(zoom);\n    int ret = computePixelCoordinates(vWorld, tRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1]);\n    return tRaster;\n\}\n\n\n\n//-------------------------------------\n// Facet_Render\n//-------------------------------------\n//This function is used to calculate what triangels to draw\nfloat3 facet_render(int2 pos, float3 _vWorld)\{\n\n    float3 screen_pos = Reconsile3D(_vWorld);\n    bool insideX = ppos.bounds.inside(pos.x+1,pos.y );\n    bool insideY = ppos.bounds.inside(pos.x,pos.y-1 );\n    bool insideYtop = ppos.bounds.inside(pos.x,pos.y+1);\n    float2 fpos = float2(pos.x,pos.y);\n    float3 V1_Pos,V2_Pos,V1_wPos,V2_wPos;\n    float4 V0_Sample,V1_Sample,V2_Sample;\n    float3 normal0,normal1,normal2;\n\n    //for area calculation\n    float area;\n    float3 V0,V1,V2;\n    float3 output = float3(0.0f);\n  if (insideX) \{\n    V2_Sample = ppos(pos.x+1,pos.y);\n    V2_wPos = float3(V2_Sample.x,V2_Sample.y,V2_Sample.z);\n    V2_Pos = Reconsile3D(V2_wPos);\n    if (V2_Sample.w != 0.0f) \{ \n\n      if (insideY) \{\n        V1_Sample = ppos(pos.x+1,pos.y-1);\n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (V1_Sample.w != 0.0f) \{ \n            float3 Normal = CalculateVertexNormals(_vWorld,V2_wPos,V1_wPos);\n\n            //Calculate Area for density:\n            V0 = screen_pos;\n            V1 = V1_Pos;\n            V2 = V2_Pos;\n            V0.z = 1.0f / V0.z, V1.z = 1.0f / V1.z, V2.z = 1.0f / V2.z; \n            area = length(V0-V1)+length(V0-V2)+length(V1-V2);\n\n          //write output\n          output +=  float3(Normal.x,Normal.y,Normal.z);\n        \}\n      \}\n      if (insideYtop) \{\n        V1_Sample = ppos(pos.x,pos.y+1);\n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (V1_Sample.w != 0.0f) \{ \n          float3 Normal = CalculateVertexNormals(_vWorld,V1_wPos,V2_wPos);\n\n            //Calculate Area for density:\n            V0 = screen_pos;\n            V1 = V1_Pos;\n            V2 = V2_Pos;\n            V0.z = 1.0f / V0.z, V1.z = 1.0f / V1.z, V2.z = 1.0f / V2.z; \n            area = length(V0-V1)+length(V0-V2)+length(V1-V2);\n\n          output += float3(Normal.x,Normal.y,Normal.z);\n\n        \}\n      \}\n    \}\n  \}\n  return output;\n\}\n\n\n\nfloat3 CalculateSurfaceNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat3 CalculateVertexNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 hitNormal = cross((V1 - V0),(V2 - V0)); \n        return hitNormal;\n\}\n\n\n\n//-------------------------------------\n// Process\n//-------------------------------------\n  void process(int2 pos) \{\n    float3 output = float3(0.0f);\n    float4 _sample = ppos(pos.x,pos.y); //Get the XYZ Coordinates\n    float3 point_pos = float3(_sample.x,_sample.y,_sample.z);\n    if (_sample.w != 0.0f) \{  //No need to process if there is no data.\n      dst() = float4(0.0f);\n      output+=facet_render(pos,float3(_sample.x,_sample.y,_sample.z))*2.0f;\n      _sample = ppos(pos.x-1,pos.y); //Get the XYZ Coordinates\n      output+=facet_render(int2(pos.x-1,pos.y),float3(_sample.x,_sample.y,_sample.z));\n\n      _sample = ppos(pos.x-1,pos.y+1); //Get the XYZ Coordinates\n      output+=facet_render(int2(pos.x-1,pos.y+1),float3(_sample.x,_sample.y,_sample.z));\n\n      _sample = ppos(pos.x,pos.y-1); //Get the XYZ Coordinates\n      output+=facet_render(int2(pos.x,pos.y-1),float3(_sample.x,_sample.y,_sample.z));\n\n      output = normalize(output);\n      float3 normal = -output;\n\n      \n\n\n      dst() = float4(normal.x,normal.y,normal.z,1.0f);\n    \}\n  \} //----> process\n\};\n"
   rebuild ""
   "PointRender3D_half Lambert" false
   "PointRender3D_light Mode" {{parent.LightFalloff}}
   PointRender3D_light_position {{parent.Axis1.translate} {parent.Axis1.translate} {parent.Axis1.translate}}
   PointRender3D_light_color {{parent.LightColor} {parent.LightColor} {parent.LightColor}}
   rebuild_finalise ""
   name BlinkScript1
   xpos 389
   ypos 344
  }
  Grade {
   multiply 0.5
   add 0.5
   black_clamp false
   name Grade1
   xpos 389
   ypos 376
   disable true
  }
  Output {
   name Output1
   xpos 389
   ypos 459
  }
  Axis2 {
   inputs 0
   translate {0.5 0.5 0.5}
   name Axis1
   xpos 661
   ypos 318
   addUserKnob {20 Ivy}
   addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.toolbox.v1.nodes.docs', fromlist=\['open_docs_name']).open_docs_name('IvyTab')" +STARTLINE}
   addUserKnob {26 divider4 l "" +STARTLINE}
   addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
   _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
   addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
   addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
   addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
   _expressions {{curve}}
   addUserKnob {26 divider0 l "" +STARTLINE}
   addUserKnob {20 dbinfo l "DB Info" n 1}
   dbinfo 0
   addUserKnob {1 twig_dnuuid l "Twig Id"}
   addUserKnob {1 stalk_dnuuid l "Stalk Id"}
   addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
   addUserKnob {1 leaf_dnuuid l "Leaf Id"}
   addUserKnob {26 divider1 l "" +STARTLINE}
   addUserKnob {1 twigtype l "Twig Type"}
   addUserKnob {1 leaf_label l Leaf}
   addUserKnob {1 ivy_version l Version}
   addUserKnob {43 ivy_notes l Notes}
   addUserKnob {26 divider2 l "" +STARTLINE}
   addUserKnob {1 build_label l "Build Label"}
   addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
  }
 end_group
 Switch {
  inputs 2
  which {{parent.connect_aux}}
  name Switch3
  xpos -324
  ypos 311
 }
push $N464029c0
 Expression {
  temp_name0 xd
  temp_expr0 red-Camera1.world_matrix.3
  temp_name1 yd
  temp_expr1 green-Camera1.world_matrix.7
  temp_name2 zd
  temp_expr2 blue-Camera1.world_matrix.11
  temp_name3 Distance
  temp_expr3 "sqrt(xd*xd + yd*yd + zd*zd)"
  expr0 Distance
  expr1 Distance
  expr2 Distance
  expr3 Distance
  name Expression1
  xpos -456
  ypos -192
 }
 Grade {
  channels rgba
  blackpoint {{parent.FogFar}}
  whitepoint {{parent.FogNear}}
  gamma {{1/(parent.FogExponent+0.000000001)}}
  white_clamp true
  name Grade1
  xpos -456
  ypos -168
 }
push $N463bd8a0
 Dot {
  name Dot7
  xpos -307
  ypos -513
 }
 Merge2 {
  inputs 2
  operation multiply
  name Merge1
  xpos -341
  ypos -168
  disable {{!parent.Fog}}
 }
 Shuffle {
  name Shuffle3
  xpos -341
  ypos 8
 }
set N462e3ce0 [stack 0]
push $N4642d8e0
 BlinkScript {
  inputs 4
  kernelSourceFile /Users/madshagbarth/Github/Nuke-Private/Blink/PointRender/Render/3D_PointRender_v15.cpp
  recompileCount 792
  ProgramGroup 1
  KernelDescription "2 \"PointRender3D\" iterate pixelWise e0ecbbf4cba39730471d23bc9f9ec846fcae1bbb869971a11b15641cf6fd5620 5 \"ppos\" Read Random \"src\" Read Random \"normals\" Read Random \"occlusion\" Read Random \"dst\" Write Random 48 \"cam_Matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== \"focallength\" Float 1 AAA4QQ== \"hapeture\" Float 1 ppvEQQ== \"format\" Int 2 AAgAAAAIAAA= \"vertexformat\" Int 2 CgAAAAoAAAA= \"Zoom\" Float 1 AACAPw== \"Filtering Method\" Int 1 AQAAAA== \"_alphaMultiplier\" Float 1 AACAPw== \"_pointRender\" Bool 1 AQ== \"_wireRender\" Bool 1 AQ== \"_facetRender\" Bool 1 AQ== \"_maxLDistance\" Float 1 AACAPw== \"_maxLConnections\" Int 1 AQAAAA== \"_maxPlexType\" Int 1 AAAAAA== \"_plexLinedefXY\" Bool 1 AA== \"_plexLinedefX\" Bool 1 AA== \"_plexLinedefY\" Bool 1 AA== \"_plexLinedefXtoY\" Bool 1 AA== \"_plexLinedefAUX\" Bool 1 AA== \"_plexConnectX\" Bool 1 AA== \"_plexConnectY\" Bool 1 AA== \"_L_gamma\" Float 1 AACAPw== \"Enable Depth of Field\" Bool 1 AA== \"samples\" Int 1 AwAAAA== \"rings\" Int 1 BQAAAA== \"focalDepth\" Float 1 AACAPw== \"_depthOfField\" Float 1 AACAQA== \"_depthMult\" Float 1 zczMPQ== \"_maxDofSize\" Float 1 AAAAQQ== \"dof_aspect\" Float 1 AACAPw== \"dof_threshold\" Float 1 AACAPw== \"dof_gain\" Float 1 AAAAAA== \"dof_bias\" Float 1 AAAAwA== \"dof_fringe\" Float 1 AAAAAA== \"_flatshading\" Bool 1 AQ== \"_backfacing\" Bool 1 AQ== \"_frontfacing\" Bool 1 AQ== \"_vertexMode\" Int 1 AAAAAA== \"_depthBuffer\" Bool 1 AQ== \"_texoffset\" Float 2 AAAAPwAAAD8= \"_pointSize\" Int 1 AQAAAA== \"_gaussigma\" Float 1 AACAPw== \"_depthOcclusion\" Bool 1 AQ== \"depthMultiplier\" Float 1 AACAPw== \"_maxLineSteps\" Float 1 AAB6RQ== \"_lineOffset\" Float 1 AACAPw== \"_lineInMultiplier\" Float 1 AACAPw== \"_lineOutMultiplier\" Float 1 AACAPw== 48 \"cam_Matrix\" 16 1 \"cam_Focal\" 1 1 \"cam_Hapeture\" 1 1 \"WHformat\" 2 1 \"Vformat\" 2 1 \"zoom\" 1 1 \"_filtering\" 1 1 \"_alphaMultiplier\" 1 1 \"_pointRender\" 1 1 \"_wireRender\" 1 1 \"_facetRender\" 1 1 \"_maxPlexDistance\" 1 1 \"_maxPlexConnections\" 1 1 \"_maxPlexType\" 1 1 \"_plexLinedefXY\" 1 1 \"_plexLinedefX\" 1 1 \"_plexLinedefY\" 1 1 \"_plexLinedefXtoY\" 1 1 \"_plexLinedefAUX\" 1 1 \"_plexConnectX\" 1 1 \"_plexConnectY\" 1 1 \"_plex_gamma\" 1 1 \"_dof_enable\" 1 1 \"_dof_samples\" 1 1 \"_dof_rings\" 1 1 \"focalDepth\" 1 1 \"_depthOfField\" 1 1 \"_depthMult\" 1 1 \"_maxDofSize\" 1 1 \"dof_aspect\" 1 1 \"dof_threshold\" 1 1 \"dof_gain\" 1 1 \"dof_bias\" 1 1 \"dof_fringe\" 1 1 \"_flatshading\" 1 1 \"_backfacing\" 1 1 \"_frontfacing\" 1 1 \"_vertexMode\" 1 1 \"_depthBuffer\" 1 1 \"_texoffset\" 2 1 \"_pointSize\" 1 1 \"_gaussigma\" 1 1 \"_depthOcclusion\" 1 1 \"depthMultiplier\" 1 1 \"_maxLineSteps\" 1 1 \"_lineOffset\" 1 1 \"_lineInMultiplier\" 1 1 \"_lineOutMultiplier\" 1 1 10 \"max_line_connections\" Int 1 1 AAAAAA== \"vRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"pRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"tRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"vWorld\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"canvasWidth\" Float 1 1 AAAAAA== \"canvasHeight\" Float 1 1 AAAAAA== \"matrixData\" Float 1 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cameraToWorld\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"worldToCamera\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "//Some basic generic functions.\ninline float Frac(float a_X)\n\{\n    return a_X-floor(a_X);\n\}\n\ninline float3 Cross(float3 A,float3 B)\n\{\n    return float3(A.y*B.z - A.z*B.y,A.z*B.x - A.x*B.z,A.x*B.y - A.y*B.x);\n\}\n\ninline float Fmax(float a_X,float b_X,float c_X)\n\{\n    return max(c_X,max(a_X,b_X));\n\}\ninline float Fmin(float a_X,float b_X,float c_X)\n\{\n    return min(c_X,min(a_X,b_X));\n\}     \n\ninline float3 mix(float3 _X,float3 _Y,float _A)\{\n  return _X*(1.0f-_A)+_Y*_A;\n\}\ninline float mix(float _X,float _Y,float _A)\{\n  return _X*(1.0f-_A)+_Y*_A;\n\}                                                                                              \n\n//This function is used to multiply a float3 by a matrix4x4\ninline float3 multVecMatrix( float3 src, float4x4 matrix)\n\{\n    float   x,y,z,w;\n\n    x = src\[0]*matrix\[0]\[0] + src\[1]*matrix\[1]\[0] +\n    src\[2]*matrix\[2]\[0] + matrix\[3]\[0];\n    y = src\[0]*matrix\[0]\[1] + src\[1]*matrix\[1]\[1] +\n    src\[2]*matrix\[2]\[1] + matrix\[3]\[1];\n    z = src\[0]*matrix\[0]\[2] + src\[1]*matrix\[1]\[2] +\n    src\[2]*matrix\[2]\[2] + matrix\[3]\[2];\n    w = src\[0]*matrix\[0]\[3] + src\[1]*matrix\[1]\[3] +\n    src\[2]*matrix\[2]\[3] + matrix\[3]\[3];\n    \n    return float3(x/w, y/w, z/w);\n\}\n\n//This function is used to calculate the screenspace coordinates.\ninline bool computePixelCoordinates( \n    const float3 pWorld, \n    float3 &pRaster, \n    const float4x4 &worldToCamera, \n    const float &canvasWidth, \n    const float &canvasHeight, \n    const int &imageWidth, \n    const int &imageHeight\n) \n\{ \n    float3 pCamera; \n    pCamera = multVecMatrix(pWorld, worldToCamera); \n    float2 pScreen; \n    pScreen.x = pCamera.x / -pCamera.z; \n    pScreen.y = pCamera.y / -pCamera.z; \n    float2 pNDC; \n    pNDC.x = (pScreen.x + canvasWidth * 0.5f) / canvasWidth; \n    pNDC.y = (pScreen.y + canvasHeight * 0.5f) / canvasHeight; \n    pRaster.x = (pNDC.x * imageWidth); \n    pRaster.y = ((pNDC.y) * imageHeight); \n    pRaster.z = -pCamera.z; \n    if (pRaster.x < 0.0f || pRaster.x > imageWidth || \n       pRaster.y < 0.0f || pRaster.y > imageHeight || pRaster.z < 0.0f) \{\n       return false;  \n    \}\n    return true;\n\} \n\n\nkernel PointRender3D : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessRandom, eEdgeClamped> ppos;    //The point position map\n  Image<eRead, eAccessRandom, eEdgeClamped> src;     //The texture map\n  Image<eRead, eAccessRandom, eEdgeClamped> normals;     //The texture map  \n  Image<eRead, eAccessRandom, eEdgeClamped> occlusion;     //The texture map \n  Image<eWrite, eAccessRandom> dst;                 //the output image\n\n  param: //Parameters available to the user\n    float4x4 cam_Matrix;    //The world matrix of the camera\n    float cam_Focal;        //The focal length of the camera\n    float cam_Hapeture;     //The horizontal apeture of the camera\n    int2 WHformat,Vformat;          //The format of the output image\n    float zoom;             //A \"post\" zoom function\n    int _filtering;        //Filter method\n    float _alphaMultiplier; //Additive multiplier\n    bool _pointRender,_wireRender,_facetRender;\n    float _maxPlexDistance; //Additive multiplier\n    int _maxPlexConnections;\n    int _maxPlexType; // 0==Grid, -1==Nearest\n    bool _plexLinedefXY,_plexLinedefX,_plexLinedefY,_plexLinedefXtoY,_plexLinedefAUX; // Define what connections NOT to include\n    bool _plexConnectX,_plexConnectY; //Connect from the edge of x to 0, or edge of y to 0, usually for spheres\n    float _plex_gamma; //The threshold making shorter paths bright and longer paths dark\n    bool _dof_enable; // Enable DOF\n    int _dof_samples; // How many samples per DOF ring\n    int _dof_rings; // How many rings \n    float focalDepth,_depthOfField,_depthMult,_maxDofSize; //DOF Settings\n    float dof_aspect; //Pixel aspect ratio\n    float dof_threshold;\n    float dof_gain;\n    float dof_bias; //bokeh edge bias\n    float dof_fringe; //bokeh chromatic aberration/fringing\n    bool _flatshading,_backfacing,_frontfacing; //Vertex rendering settings\n    int _vertexMode;  //The rendering output mode, (think AOV)\n    bool _depthBuffer; //Non-additive, only render front most pixel\n    float2 _texoffset;\n    int _pointSize;\n    float _gaussigma;\n    bool _depthOcclusion;\n    float depthMultiplier;\n    float _maxLineSteps; //cap the line length to avoid process lock\n    float _lineOffset; //Alow you to shrink or extend the lines\n    float _lineInMultiplier,_lineOutMultiplier; //Control the brightness of the wires at the tips.\n\n  local: //Local variables\n    int max_line_connections;\n    float3 vRaster;\n    float3 pRaster;\n    float3 tRaster;    \n    float3 vWorld;\n    float canvasWidth;\n    float canvasHeight; \n    float matrixData\[4]\[4];\n    float4x4 cameraToWorld;\n    float4x4 worldToCamera;\n\n  void define() \{\n    defineParam(cam_Matrix, \"cam_Matrix\", float4x4( 1.0f,0.0f,0.0f,0.0f,\n                                                    0.0f,1.0f,0.0f,0.0f,\n                                                    0.0f,0.0f,1.0f,0.0f,\n                                                    0.0f,0.0f,0.0f,1.0f));\n    defineParam(cam_Focal,      \"focallength\", 11.5f);\n    defineParam(cam_Hapeture,      \"hapeture\", 24.576f);\n    defineParam(WHformat,      \"format\", int2(2048,2048));\n    defineParam(Vformat,      \"vertexformat\", int2(10,10));\n    defineParam(zoom, \"Zoom\", 1.0f);\n    defineParam(_filtering, \"Filtering Method\", 1); \n    defineParam(_alphaMultiplier, \"_alphaMultiplier\", 1.0f);     \n    defineParam(_pointRender, \"_pointRender\", true);  \n    defineParam(_wireRender, \"_wireRender\", true);\n    defineParam(_facetRender, \"_facetRender\", true);\n    defineParam(_maxPlexDistance, \"_maxLDistance\", 1.0f);    \n    defineParam(_maxPlexConnections, \"_maxLConnections\", 1);    \n    defineParam(_maxPlexType, \"_maxPlexType\", 0); \n    defineParam(_plexLinedefXY, \"_plexLinedefXY\", false);      \n    defineParam(_plexLinedefXtoY, \"_plexLinedefXtoY\", false); //NYI\n    defineParam(_plexLinedefAUX, \"_plexLinedefAUX\", false); \n    defineParam(_plexLinedefX, \"_plexLinedefX\", false);  \n    defineParam(_plexLinedefY, \"_plexLinedefY\", false);  \n    defineParam(_plexConnectX, \"_plexConnectX\", false);      \n    defineParam(_plexConnectY, \"_plexConnectY\", false);   \n    defineParam(_plex_gamma, \"_L_gamma\", 1.0f);\n    //DOF SETTINGS   \n    defineParam(_dof_enable, \"Enable Depth of Field\", false);   \n    defineParam(_dof_samples, \"samples\", 3);    \n    defineParam(_dof_rings, \"rings\", 5);   \n    defineParam(focalDepth, \"focalDepth\", 1.0f);  \n    defineParam(_depthOfField, \"_depthOfField\", 4.0f);  \n    defineParam(_depthMult, \"_depthMult\", 0.1f);  \n    defineParam(_maxDofSize, \"_maxDofSize\", 8.0f);  \n    defineParam(dof_aspect, \"dof_aspect\", 1.0f);  \n    defineParam(dof_threshold, \"dof_threshold\", 1.0f);  \n    defineParam(dof_gain, \"dof_gain\", 0.0f);  \n    defineParam(dof_bias, \"dof_bias\", -2.0f);  \n    defineParam(dof_fringe, \"dof_fringe\", 0.0f); \n    //SHADING SETTINGS \n    defineParam(_flatshading, \"_flatshading\", true);  \n    defineParam(_vertexMode, \"_vertexMode\", 0);  \n    defineParam(_backfacing, \"_backfacing\", true);    \n    defineParam(_frontfacing, \"_frontfacing\", true);        \n    defineParam(_depthBuffer, \"_depthBuffer\", true);  \n    defineParam(_texoffset, \"_texoffset\", float2(0.5f,0.5f)); \n    defineParam(_pointSize, \"_pointSize\", 1); \n    defineParam(_gaussigma, \"_gaussigma\", 1.0f); \n    defineParam(_depthOcclusion, \"_depthOcclusion\", true); \n    defineParam(depthMultiplier, \"depthMultiplier\", 1.0f); \n    defineParam(_maxLineSteps, \"_maxLineSteps\", 4000.0f); \n    defineParam(_lineOffset, \"_lineOffset\", 1.0f); \n    defineParam(_lineInMultiplier, \"_lineInMultiplier\", 1.0f);   \n    defineParam(_lineOutMultiplier, \"_lineOutMultiplier\", 1.0f);     \n\n  \}\n\n  //The init() function is run before any calls to process().\n  void init() \{\n    max_line_connections = 80;\n    canvasWidth = ((cam_Hapeture)/cam_Focal);\n    canvasHeight = ((cam_Hapeture)/cam_Focal)*float(float(WHformat.y)/float(WHformat.x)); \n    float matrixData\[] = \{cam_Matrix\[0]\[0], cam_Matrix\[1]\[0], cam_Matrix\[2]\[0], cam_Matrix\[3]\[0], \n                          cam_Matrix\[0]\[1], cam_Matrix\[1]\[1], cam_Matrix\[2]\[1], cam_Matrix\[3]\[1], \n                          cam_Matrix\[0]\[2], cam_Matrix\[1]\[2], cam_Matrix\[2]\[2], cam_Matrix\[3]\[2], \n                          cam_Matrix\[0]\[3], cam_Matrix\[1]\[3], cam_Matrix\[2]\[3], cam_Matrix\[3]\[3]\};\n    cameraToWorld.setArray(matrixData); //This is a workaround. Due to the buggy matrix implementation, we pass the matrix on from another structure.\n    worldToCamera = cameraToWorld.invert();\n  \}\n\n  //Convert a 3d point position into a 2d raster position.\n  float3 Reconsile3D(float3 _PointPos)\{\n      vWorld = float3(_PointPos.x,_PointPos.y,_PointPos.z)*(zoom);\n      int ret = computePixelCoordinates(vWorld, tRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1]);\n      return tRaster;\n  \}\n\n//------------------------------\n//-------DRAW FUNCTIONS---------\n//------------------------------\n  //Write pixels to output.\n  void writepixel(float posx,float posy, float4 color,int index,float weight=1.0f)\n  \{ \n      if (_depthOcclusion)\{\n        float4 depthSample = occlusion(posx,posy);\n        if (depthSample.x<=vRaster.z && depthSample.w>0.0f)\{\n\n          float depth = (vRaster.z-depthSample.x);\n          color = color*(1.0f-depthSample.w);\n          color = color / (((depth*depth)*depthMultiplier)+1.0f);\n          //return;\n        \}\n      \}\n      float4 finalOutput; //This is used to store the final output\n      float4 dstSample; //This is used to store a sample of the destination\n      if ( dst.bounds.inside( posx, posy ) ) \{ //Test if the pixel written to is inside the output image. \n        if (_depthBuffer) \{\n          dstSample = (float4)dst(posx,posy); //Sample the destination image\n          if ((dstSample.w>color.w)||dstSample.w==0.0f) \{\n            dst(posx,posy) = color;\n          \}\n        \}\n        else \{\n          dstSample = (float4)dst(posx,posy); //Sample the destination image\n          finalOutput = dstSample + (color*_alphaMultiplier*weight);\n          finalOutput.w = dstSample.w + ((color.w*_alphaMultiplier*weight));\n\n          finalOutput.w = (dstSample.w + ((color.w*_alphaMultiplier*weight)))-(dstSample.w * ((color.w*_alphaMultiplier*weight)));\n\n          dst(posx,posy) = finalOutput;\n        \}\n      \} \n  \}\n\n  //Calculate a Bilinear Plot\n  void bilinear_Plot(float2 temppos,float4 color,int index)\n  \{\n    float2 p;\n    p.x=Frac(temppos.x);\n    p.y=Frac(temppos.y);\n    float weights\[] = \{(1.0f-p.x)*(1.0f-p.y), p.x*(1.0f-p.y), (1.0f-p.x)*p.y, p.x*p.y\};\n    int2 _position = int2(floor(temppos.x)-0,floor(temppos.y)-0); \n    writepixel(_position.x,_position.y,color,index,weights\[0]);\n    writepixel(_position.x+1,_position.y,color,index,weights\[1]);\n    writepixel(_position.x,_position.y+1,color,index,weights\[2]);\n    writepixel(_position.x+1,_position.y+1,color,index,weights\[3]);\n  \}\n\n  //NYI, unused!\n  void gaussian(float2 temppos,float4 color,int index)\{\n    float in_x = temppos.x;\n    float in_y = temppos.y;\n    int kernelSize = (_pointSize+1)*2;\n    int subsize = (kernelSize /2)-1;\n    float gKernel\[64]\[64];\n    float sigma = _gaussigma;\n    float intSigma = float(_pointSize);\n    float r, s = intSigma * sigma * sigma;\n\n    float sum = 0.0f;\n\n    // generate 5x5 kernel\n    for (int x = -subsize; x <= subsize; x++)\n    \{\n        for(int y = -subsize; y <= subsize; y++)\n        \{\n            r = float(sqrt(x*x + y*y));\n            gKernel\[x + subsize]\[y + subsize] = (exp(-(r*r)/s))/(3.141592654f * s);\n            sum += gKernel\[x + subsize]\[y + subsize];\n        \}\n    \}\n\n    // normalize the Kernel\n    for (int x = -subsize; x <= subsize; x++)\n    \{\n        for(int y = -subsize; y <= subsize; y++)\n        \{\n            gKernel\[x + subsize]\[y + subsize] /= sum;\n            writepixel(in_x+x,in_y+y,color,index,gKernel\[x + subsize]\[y + subsize]);\n        \}\n    \}\n  \}\n\n//-------------------------------------\n// DrawLine\n// ----------\n// Draw a line between two points, \n// x,y being 2d screenspace pos and z being depth.\n//-------------------------------------\n  void DrawLine(float3 origin, float3 endpoint,float4 _colorA,float4 _colorB) \{\n    float4 _color;\n    float3 delta = origin-endpoint;\n    float3 curPoint = origin;\n    float mag = sqrt(delta.x*delta.x+delta.y*delta.y);\n    mag = min(mag,_maxLineSteps); //Lets not go crazy, we cap it at 10.000 to avoid insane unwated processing time \n    for( float a = 0; a < mag*_lineOffset; a = a + 1.0f )\{\n      curPoint -= (delta/mag);\n      _color = (_colorA*(1.0f-(a/mag*1.0f)))+(_colorB*(a/mag*1.00f));\n      if (_dof_enable)\{\n        Bokeh(curPoint,_color);\n      \}\n      else \{\n        bilinear_Plot(float2(curPoint.x,curPoint.y),_color,1);\n      \}\n      \n    \}\n  \}\n\n//-------------------------------------\n// Point_Render\n//-------------------------------------\nvoid point_render(int2 pos, float3 screen_pos)\{\n  float4 color = src(pos.x,pos.y);\n\n  if (_filtering == 1)\{\n      if (_dof_enable)\{\n        Bokeh(screen_pos,color);\n      \}\n      else \{\n        bilinear_Plot(float2(screen_pos.x,screen_pos.y),color,1);\n      \}\n  \}\n  /*\n  //THIS PART NEEDS TO BE RE-WRITTEN.\n  else if (_filtering == 2)\{ \n      if (_dof_enable)\{\n        Bokeh(screen_pos,color);\n      \}\n      else \{\n        gaussian(float2(screen_pos.x,screen_pos.y),color,1);\n      \}\n  \}\n  */\n  else \{\n      int2 _position = int2(floor(screen_pos.x),floor(screen_pos.y)); \n      if (_depthBuffer) \{color.w = screen_pos.z;\}\n      writepixel(_position.x,_position.y, color,1,1.0f); //OutputSample\n  \}\n\n\}\n\n//-------------------------------------\n// Facet_Render\n//-------------------------------------\n//This function is used to calculate what triangels to draw\nvoid facet_render(int2 pos, float3 _vWorld)\{\n\n    float3 screen_pos = Reconsile3D(_vWorld);\n\n    bool insideX = ppos.bounds.inside(pos.x+1,pos.y );\n    bool insideY = ppos.bounds.inside(pos.x+1,pos.y-1 );\n    bool insideYtop = ppos.bounds.inside(pos.x,pos.y+1);\n    float2 fpos = float2(pos.x,pos.y);\n    float3 V1_Pos,V2_Pos,V1_wPos,V2_wPos,V0_N,V1_N,V2_N;\n    float2 V0_ST,V1_ST,V2_ST;\n    float4 V1_Sample,V2_Sample;\n    float4 _tn;\n    float3 normal0,normal1,normal2;\n    float2 UV_Format = float2(Vformat.x,Vformat.y);\n\n\n    int2 P0 = int2(pos.x-1,pos.y-1);\n    int2 P1 = int2(pos.x+1,pos.y+1);\n    if (_plexConnectX && pos.x == int(Vformat.x))\{\n      insideX == true;\n      P1 = int2(0.0f,pos.y+1);\n    \}\n    if (_plexConnectY && pos.y == int(Vformat.y))\{\n      insideYtop == true;\n      P1 = int2(pos.x+1,0);\n    \} \n\n    if (_plexConnectY && pos.y == 0)\{\n      insideY == true;\n      P0 = int2(pos.x-1,int(UV_Format.y));\n    \} \n\n    if (!_flatshading) \{\n      _tn = normals(pos.x,pos.y);\n      V0_N =float3(_tn.x,_tn.y,_tn.z);\n    \}\n    V0_ST = float2(pos.x,pos.y)/UV_Format;\n\n  if (insideX) \{\n    V2_Sample = ppos(P1.x,pos.y);\n    V2_ST = float2(P1.x,pos.y)/UV_Format;\n    V2_wPos = float3(V2_Sample.x,V2_Sample.y,V2_Sample.z);\n    V2_Pos = Reconsile3D(V2_wPos);\n    if (!_flatshading) \{\n      _tn = normals(P1.x,pos.y);\n      V2_N =float3(_tn.x,_tn.y,_tn.z);\n    \}\n        \n\n    if (V2_Sample.w != 0.0f) \{ \n\n      if (insideY) \{\n        V1_Sample = ppos(P1.x,P0.y);\n        V1_ST = float2(P1.x,P0.y)/UV_Format;\n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (!_flatshading) \{\n          _tn = normals(P1.x,P0.y);\n          V1_N =float3(_tn.x,_tn.y,_tn.z);\n        \}\n        if (V1_Sample.w != 0.0f) \{ \n          DrawTriangle(screen_pos,V2_Pos,V1_Pos,_vWorld,V2_wPos,V1_wPos,V0_N,V2_N,V1_N,V0_ST,V2_ST,V1_ST);\n        \}\n      \}\n      if (insideYtop) \{\n        V1_Sample = ppos(pos.x,P1.y);\n        V1_ST = float2(pos.x,P1.y)/UV_Format;        \n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (!_flatshading) \{\n          _tn = normals(pos.x,P1.y);\n          V1_N =float3(_tn.x,_tn.y,_tn.z);\n        \}        \n        if (V1_Sample.w != 0.0f) \{ \n          DrawTriangle(screen_pos,V1_Pos,V2_Pos,_vWorld,V1_wPos,V2_wPos,V0_N,V1_N,V2_N,V0_ST,V1_ST,V2_ST);\n        \}\n      \}\n    \}\n  \}\n\}\n\n\n\n//This function will calculate if pixel C is inside the triangle\nfloat edgeFunction(float3 a, float3 b, float3 c) \n\{ \n    return ((c.x - a.x) * (b.y - a.y) - (c.y - a.y) * (b.x - a.x)); \n\} \n\nfloat3 CalculateSurfaceNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat3 CalculateVertexNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat Distance(float3 _a,float3 _b)\n\{\n          float xd = _a.x - _b.x;\n          float yd = _a.y - _b.y;\n          float zd = _a.z - _b.z;\n          return sqrt(xd*xd + yd*yd + zd*zd);\n\}\n\nvoid DrawTriangle(float3 V0, float3 V1, float3 V2,float3 WP0, float3 WP1, float3 WP2,float3 N0, float3 N1, float3 N2, float2 st0,float2 st1,float2 st2) \{\n\n  // Precompute reciprocal of vertex z-coordinate \n  V0.z = 1.0f / V0.z, V1.z = 1.0f / V1.z, V2.z = 1.0f / V2.z; \n\n  float2 st0n = st0 * V0.z;\n  float2 st1n = st1 * V1.z; \n  float2 st2n = st2 * V2.z; //Normal version of ST\n\n  bool inside; \n  float X0 = Fmin(V0.x,V1.x,V2.x)-1.0f;\n  float X1 = Fmax(V0.x,V1.x,V2.x)+1.0f;\n  float Y0 = Fmin(V0.y,V1.y,V2.y)-1.0f;\n  float Y1 = Fmax(V0.y,V1.y,V2.y)+1.0f;\n  float area = edgeFunction(V2, V1, V0);\n\n\n  float2 sampos = float2(st0.x*float(Vformat.x),st0.y*float(Vformat.y));\n  float4 text0 = src(sampos.x,sampos.y);\n  sampos = float2(st1.x*float(Vformat.x),st1.y*float(Vformat.y));\n  float4 text1 = src(sampos.x,sampos.y);\n  sampos = float2(st2.x*float(Vformat.x),st2.y*float(Vformat.y));  //Why do we have to do this? =(\n  float4 text2 = src(sampos.x,sampos.y);\n  sampos = float2(min(min(st0.x,st1.x),st2.x)*float(Vformat.x),min(min(st0.y,st1.y),st2.y)*float(Vformat.y));\n  float4 text3 = src(sampos.x,sampos.y);\n\n\n  for( int x = X0; x < X1 ; x++) \{\n    for( int y = Y0; y < Y1 ; y++) \{\n      float3 pixelSample(x + _texoffset.x, y + _texoffset.y,0.0f); \n\n      //This is the part where we test if the current pixel is inside the triangle\n      //We check both for front facing and back faing options\n      float w0 = edgeFunction(V1, V0, pixelSample); //Front Facing\n      float w1 = edgeFunction(V2, V1, pixelSample); \n      float w2 = edgeFunction(V0, V2, pixelSample); \n      float w3 = edgeFunction(V0, V1, pixelSample); //Back Facing\n      float w4 = edgeFunction(V1, V2, pixelSample); \n      float w5 = edgeFunction(V2, V0, pixelSample);\n\n      //writepixel(x,y, float4(w1),1,1.0f);\n      if ((w0 >= 0 && w1 >= 0 && w2 >= 0 && _frontfacing) || (w3 >= 0 && w4 >= 0 && w5 >= 0 && _backfacing)) \{ //The curent pixel is inside the triangle\n\n       // calculate vectors from point f to vertices p1, p2 and p3:\n       float3 f1 = V0-pixelSample;\n       float3 f2 = V1-pixelSample;\n       float3 f3 = V2-pixelSample;\n       // calculate the areas and factors (order of parameters doesn't matter):\n       float a = length(cross(V0-V1,V0-V2 )); // main triangle area a\n       area = length(V0-V1)+length(V0-V2)+length(V1-V2);\n\n        w0 /= area; \n        w1 /= area; \n        w2 /= area; \n\n        w3 /= area; \n        w4 /= area; \n        w5 /= area; \n\n       float a1 = length(cross(f2, f3)) / a; // p1's triangle area / a\n       float a2 = length(cross(f3, f1)) / a; // p2's triangle area / a \n       float a3 = length(cross(f1, f2)) / a; // p3's triangle area / a\n       float a_magnitude = a1+a2+a3;\n       a1 = a1/a_magnitude;\n       a2 = a2/a_magnitude;\n       a3 = a3/a_magnitude;\n       float z = 1.0f / (V0.z * a1 + V1.z * a2 + V2.z * a3); \n\n\n        // find the uv corresponding to point f (uv1/uv2/uv3 are associated to p1/p2/p3):\n        float2 uv = st0 * a1 + st1 * a2 + st2 * a3;\n        float2 st = st0 * w0 + st1 * w1 + st2 * w2; \n        st *= z;      \n\n\n        //Calculate normals. Eighter we have flat shading, else we calculate a normal per pixel\n        float3 normalB;\n        if (_flatshading) \{\n          normalB = CalculateSurfaceNormals(WP0,WP1,WP2);\n\n        \}\n        else \{\n          float3 c0 = N2/float3(V0.z); \n          float3 c1 = N0/float3(V1.z); \n          float3 c2 = N1/float3(V2.z);  \n\n          normalB.x = w0 * c0.x + w1 * c1.x + w2 * c2.x; \n          normalB.y = w0 * c0.y + w1 * c1.y + w2 * c2.y; \n          normalB.z = w0 * c0.z + w1 * c1.z + w2 * c2.z; \n\n          normalB.x *= z, normalB.y *= z, normalB.z *= z; \n        \}\n        normalB = normalize(normalB);\n\n        //CALCULATE THE OBJECT TEXTURE COORDINATES\n        float zn = 1.0f / (V0.z * w0 + V1.z * w1 + V2.z * w2); \n        st = st0n * w0 + st1n * w1 + st2n * w2; \n        st *= zn;   \n        //--END \n\n        float3 Wpos = WP0*a1 + WP1*a2 + WP2*a3; //World Position.\n        float3 ViewNormal = normalize(float3(cameraToWorld\[3]\[0],cameraToWorld\[3]\[1],cameraToWorld\[3]\[2])-Wpos);\n\n        float nDotView =  dot(normalB,ViewNormal);\n        nDotView = 1.0f-fabs(nDotView); //make sure that the view normal ramps back around when doing backface\n        float4 tempout;\n\n        //Flatshading or regular?\n        if (!_flatshading) \{\n          tempout = text0 * a1 + text1 * a2 + text2 * a3; \n        \}\n        else\{\n          tempout = text3;\n        \}\n\n        //Additional Render Modes\n        if (_vertexMode == 1)\{\n          tempout = float4(a1,a2,a3,1.0f);\n        \}\n        else if (_vertexMode == 2)\{\n          tempout = float4(normalB.x,normalB.y,normalB.z,1.0f);\n        \}\n        else if (_vertexMode == 3)\{\n          tempout = float4(nDotView,nDotView,nDotView,1.0f);\n        \}\n        else if (_vertexMode == 4)\{\n          tempout = float4(uv.x,uv.y,0.0f,1.0f);\n        \}       \n        else if (_vertexMode == 5)\{\n          tempout = float4(st.x,st.y,0.0f,1.0f);\n        \}               \n        else if (_vertexMode == 6)\{\n          tempout = float4(ViewNormal.x,ViewNormal.y,ViewNormal.z,1.0f);\n        \}             \n        else if (_vertexMode == 7)\{\n          tempout = float4(Wpos.x,Wpos.y,Wpos.z,1.0f);\n        \}   \n\n        if (_depthBuffer)\{\n          writepixel(x,y, float4(tempout.x,tempout.y,tempout.z,z),1,1.0f);  \n        \}\n        else \{\n          if (_dof_enable)\{\n            Bokeh(float3(x,y,z),float4(tempout.x,tempout.y,tempout.z,z));\n          \}\n          else \{\n            bilinear_Plot(float2(x,y),float4(tempout.x,tempout.y,tempout.z,z),1);\n          \}\n        \}\n\n      \}  \n\n    \}\n  \}\n\}\n\n//-------------------------------------\n// Wire_Render\n//-------------------------------------\nvoid wire_render(int2 pos) \{\n  float4 temp = float4(0.0f,0.0f,0.0f,FLT_MAX);\n  float4 wire_ref_sample;\n  int2 tempXY = int2(0,0);\n  float4 plexlist\[11] = \{temp,temp,temp,temp,temp,temp,temp,temp,temp,temp,temp\}; \n  int2 plexlistXY\[11] = \{tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY\};\n  int plex_count = 0; //We use this to figure how many points that should connect.\n  float plex_dist;\n  float3 plex_position,plex_position_b;\n  float4 temp_pos, temp_pos_b; //Temporary Position Containers\n  if (_maxPlexType == -1) \{ //Used for random connection types\n    for( int x = 0; x < max_line_connections ; x++)\{ //THIS 80 NUMBER IS THE LIMIT TO AVOID TOO SLOW PROCESSING!\n      for( int y = 0; y < max_line_connections ; y++)\{\n        wire_ref_sample = ppos(x,y);\n        if (wire_ref_sample.w != 0.0f && pos.x!=x && pos.y != y) \{ \n          plex_position = float3(wire_ref_sample.x,wire_ref_sample.y,wire_ref_sample.z)*(zoom);\n          float xd = plex_position.x - vWorld.x;\n          float yd = plex_position.y - vWorld.y;\n          float zd = plex_position.z - vWorld.z;\n          float plex_dist = sqrt(xd*xd + yd*yd + zd*zd);\n          if (plex_dist<_maxPlexDistance)\{\n            plex_count = min(10,plex_count+1); //Add one to the count\n            for( int h = 0; h < plex_count+1 ; h++) \{ //Loop thought all the points. If the distance is shorter then insert it into the array and push the rest of the array down\n              if (plex_dist < plexlist\[h].w) \{                  \n                for( int i = plex_count+1; i > h ; i--) \{\n                  plexlist\[i] = plexlist\[i-1];\n                  plexlistXY\[i] = plexlistXY\[i-1];\n                \}\n                plexlist\[h] = float4(plex_position.x,plex_position.y,plex_position.z,plex_dist);\n                plexlistXY\[h] = int2(x,y);\n                break;        \n              \}\n            \}\n          \} \n        \}\n      \}\n    \}\n  \}\n  else\{ //Used for standard connection types\n    float4 temp_pos;\n    bool insideX = !(Vformat.x < pos.x+1);\n    bool insideY = !(Vformat.y < pos.y+1);\n\n\n    if (!_plexLinedefAUX)\{\n      temp_pos = normals(pos.x,pos.y);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,vWorld+plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    if ( insideX && !_plexLinedefX) \{\n      temp_pos = ppos(pos.x+1,pos.y );\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && !_plexLinedefX) \{\n      temp_pos = ppos(0,pos.y);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    if ( insideY && !_plexLinedefY) \{\n      temp_pos = ppos(pos.x,pos.y+1);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\}                          \n    \}\n    else if ( _plexConnectY  && !_plexLinedefY) \{\n      temp_pos = ppos(pos.x,0);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    //_plexConnect\n    if ( insideX && insideY && !_plexLinedefXY) \{              \n      temp_pos = ppos(pos.x+1,pos.y+1);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && _plexConnectY && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && insideY && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectY && insideX && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n  \}   \n\n  //now that all the connections have been sorted by distance then we connect the dots.\n  for( int x = 0; x < min(_maxPlexConnections,plex_count) ; x++)\{\n    plex_position = float3(plexlist\[x].x,plexlist\[x].y,plexlist\[x].z);\n    plex_dist = plexlist\[x].w;\n\n\n    float plex_distribution = 1.0f-((plexlist\[x].w-plexlist\[0].w)/((plexlist\[min(_maxPlexConnections,plex_count)].w-plexlist\[0].w)+0.00001f)); //Where does it lie between the best and the worst distance?\n    //plexlistXY\n\n    float4 plex_col = float4(pow(1.0f-(plex_dist/_maxPlexDistance),1.0f/_plex_gamma))*float4(plex_distribution); //This one is quite cool aswell, but does leave the center ones a bit too focused \n    float4 plex_colorA = src(pos.x,pos.y);\n    float4 plex_colorB = src( plexlistXY\[x].x,plexlistXY\[x].y);\n    plex_col *= 0.1f;\n\n    computePixelCoordinates(plex_position, pRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1]);\n    if (dst.bounds.inside(int(vRaster.x),int(vRaster.y)) || dst.bounds.inside(int(pRaster.x),int(pRaster.y)))\{\n        DrawLine(vRaster,pRaster,(plex_colorA*plex_col)*_lineInMultiplier,(plex_colorB*plex_col)*_lineOutMultiplier);\n    \}\n  \}\n\}\n\nvoid wire_connection(float3 p_source,float3 p_target, float4 (&p_plexlist)\[11], int2 (&p_plexlistXY)\[11],int &p_plexcount,int2 position) \{\n  float xd = p_target.x - p_source.x;\n  float yd = p_target.y - p_source.y;\n  float zd = p_target.z - p_source.z;\n  float plex_dist = sqrt(xd*xd + yd*yd + zd*zd);\n  if (plex_dist<_maxPlexDistance)\{\n    p_plexcount = min(11,p_plexcount+1); //Add one to the count\n    for( int h = 0; h < p_plexcount+1 ; h++) \{ //Loop thought all the points. If the distance is shorter then insert it into the array and push the rest of the array down\n      if (plex_dist < p_plexlist\[h].w) \{                  \n        for( int i = p_plexcount+1; i > h ; i--) \{\n          p_plexlist\[i] = p_plexlist\[i-1];\n          p_plexlistXY\[i] = p_plexlistXY\[i-1];\n        \}\n        p_plexlist\[h] = float4(p_target.x,p_target.y,p_target.z,plex_dist);\n        p_plexlistXY\[h] = int2(position.x,position.y);\n        break;        \n      \}\n    \}  \n  \}\n\}\n//-------END OF WIRE RENDER FUNCTIONS---------\n\n\n\n\n//-------------------------------\n//-------BOKEH FUNCTIONS---------\n//thanks to: http://devlog-martinsh.blogspot.dk/2011/11/glsl-depth-of-field-with-bokeh-v21.html\nfloat2 rand(float2 coord) //generating noise/pattern texture for dithering\n\{\n  float noiseX = ((Frac(1.0-coord.x*(WHformat\[0]/2.0))*0.25)+(Frac(coord.y*(WHformat\[1]/2.0))*0.75))*2.0-1.0;\n  float noiseY = ((Frac(1.0-coord.x*(WHformat\[0]/2.0))*0.75)+(Frac(coord.y*(WHformat\[1]/2.0))*0.25))*2.0-1.0;\n  noiseX = clamp(Frac(sin(dot(coord ,float2(12.9898f,78.233f))) * 43758.5453f),0.0f,1.0f)*2.0f-1.0f;\n  noiseY = clamp(Frac(sin(dot(coord ,float2(12.9898f,78.233f)*2.0f)) * 43758.5453f),0.0f,1.0f)*2.0-1.0f;\n  return float2(noiseX,noiseY);\n\}\n//-------------------------------------\n// Bokeh\n//-------------------------------------\nvoid Bokeh(float3 pos,float4 color)\{\n  float blur = 0.0;\n  blur = clamp((fabs(pos.z - focalDepth)/_depthOfField)*100.0f,-_maxDofSize,_maxDofSize);\n  \n  float w = (1.0/WHformat.x)*blur;//+noise.x;\n  float h = (1.0/(WHformat.x*dof_aspect))*blur;//+noise.y;\n  float3 v3_col = float3(color.x,color.y,color.z);\n  int ringsamples;\n  float s = 1.0;  \n\n  for (int i = 1; i <= _dof_rings; i += 1)\n  \{   \n    ringsamples = i * _dof_samples; \n    for (int j = 0 ; j < ringsamples ; j += 1)  \n    \{ \n      s += (1.0f*mix(1.0f,(float(i))/(float(_dof_rings)),dof_bias)*1.0f); //No need to do this in the loop\n    \}\n  \}\n\n  for (int i = 1; i <= _dof_rings; i += 1)\n  \{   \n    ringsamples = i * _dof_samples;\n     \n    for (int j = 0 ; j < ringsamples ; j += 1)   \n    \{\n      float step = PI*2.0 / float(ringsamples);\n      float pw = (cos(float(j)*step)*(float(i)/_dof_rings));\n      float ph = (sin(float(j)*step)*(float(i)/_dof_rings));\n      float p = 1.0;\n\n      float posx = pos.x+((pw*w)*blur);\n      float posy = pos.y+((ph*h)*blur);\n\n\n      float3 lumcoeff = float3(0.299,0.587,0.114);\n      float lum = dot(v3_col, lumcoeff);\n      float thresh = max((lum-dof_threshold)*dof_gain, 0.0f);\n      v3_col+mix(float3(0.0),v3_col,thresh*blur);\n\n      float3 col = (v3_col*mix(1.0,(float(i))/(float(_dof_rings)),dof_bias)*p)/s; \n      bilinear_Plot(float2(posx,posy),float4(col.x,col.y,col.z,color.w/(_dof_rings*_dof_rings)),1);\n    \}\n  \}\n\}\n//-------END OF BOKEH FUNCTIONS---------\n\n\n\n//-------------------------------------\n// Process\n//-------------------------------------\n  void process(int2 pos) \{\n    float4 _sample = ppos(pos.x,pos.y); //Get the XYZ Coordinates\n    float2 posf = float2(pos.x,pos.y);\n\n    if (_sample.w != 0.0f) \{  //No need to process if there is no data.\n\n      //Convert worldspace coordinates to screenspcace coordinates.\n      vWorld = float3(_sample.x,_sample.y,_sample.z)*(zoom);\n      int ret = computePixelCoordinates(vWorld, vRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1]);\n      if (ret) \{ //Only create points that are visible on screen\n        if (_pointRender)\{\n          point_render(pos,vRaster);\n        \}\n      \} //Pointrender over\n\n      if (_wireRender && _maxPlexConnections>=1) \{\n        if (max(pos.x,pos.y)<=max_line_connections || (_maxPlexType==0))\{ // Don't process more wires than allowed in nearest mode.\n          wire_render(pos);\n        \}\n      \} //WireRender over\n\n      if (_facetRender) \{\n        facet_render(pos,float3(_sample.x,_sample.y,_sample.z));\n      \}  //FacetRender over\n      \n    \}\n  \} //----> process\n\};\n"
  useGPUIfAvailable false
  rebuild ""
  PointRender3D_cam_Matrix {
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
    }
  PointRender3D_focallength {{parent.Camera1.focal}}
  PointRender3D_hapeture {{parent.Camera1.haperture}}
  PointRender3D_format {{Settings_Format.width} {Settings_Format.height}}
  PointRender3D_vertexformat {{parent.InputFormat.box.r-1} {parent.InputFormat.box.t-1}}
  PointRender3D__alphaMultiplier {{parent.AlphaMultiplier}}
  PointRender3D__pointRender {{parent.RenderMode==0}}
  PointRender3D__wireRender {{parent.RenderMode==1}}
  PointRender3D__facetRender {{parent.RenderMode==2}}
  PointRender3D__maxLDistance {{parent.wire_maxdistance}}
  PointRender3D__maxLConnections {{parent.wire_connections}}
  PointRender3D__maxPlexType {{-parent.wire_type}}
  PointRender3D__plexLinedefXY {{!parent.connect_xy}}
  PointRender3D__plexLinedefX {{!parent.connect_x}}
  PointRender3D__plexLinedefY {{!parent.connect_y}}
  PointRender3D__plexLinedefAUX {{!connect_aux}}
  PointRender3D__plexConnectX {{parent.CloseX}}
  PointRender3D__plexConnectY {{parent.CloseY}}
  PointRender3D__L_gamma {{parent.wire_Threshold}}
  "PointRender3D_Enable Depth of Field" {{parent.dof_enable}}
  PointRender3D_samples {{3*(parent.Dof_Quality*parent.Dof_Quality+1)}}
  PointRender3D_rings {{3*(parent.Dof_Quality*parent.Dof_Quality+1)}}
  PointRender3D_focalDepth {{parent.dof_focaldepth}}
  PointRender3D__depthOfField {{parent.dof_dof}}
  PointRender3D__depthMult {{parent.DofMultiplier}}
  PointRender3D__maxDofSize {{parent.dof_maxSize*400}}
  PointRender3D_dof_aspect {{parent.dof_Aspect}}
  PointRender3D_dof_bias {{parent.dof_bias}}
  PointRender3D__flatshading {{parent.facet_flatShading}}
  PointRender3D__backfacing {{parent.facet_backface}}
  PointRender3D__frontfacing {{parent.facet_front}}
  PointRender3D__vertexMode {{parent.renderMode}}
  PointRender3D__depthBuffer {{parent.facet_depth}}
  PointRender3D__texoffset {-0.5 0.5}
  PointRender3D__pointSize 0
  PointRender3D__depthOcclusion {{parent.UseOcclusionMap}}
  PointRender3D__maxLineSteps {{parent.maxSamples}}
  PointRender3D__lineOffset {{parent.lineoffset}}
  PointRender3D__lineInMultiplier {{parent.inGain}}
  PointRender3D__lineOutMultiplier {{parent.outGain}}
  format "1280 720 0 0 1280 720 1 HD_720"
  rebuild_finalise ""
  name BlinkScript1
  selected true
  xpos -27
  ypos 159
 }
 Reformat {
  format {{{Settings_Format.format}}}
  resize none
  center false
  name Reformat1
  xpos -27
  ypos 343
 }
 Group {
  name SoftLook
  xpos -27
  ypos 460
  disable {{!parent.HighlightCompression}}
  addUserKnob {20 User}
  addUserKnob {26 ""}
  addUserKnob {7 Add R 0 4}
  Add {{parent.HighlightCeiling}}
  addUserKnob {7 Offset R 0 4}
  Offset {{parent.Compression}}
 }
  Input {
   inputs 0
   name Input1
   xpos -248
   ypos 500
  }
set N4631e370 [stack 0]
  Expression {
   expr0 r/(r+parent.Offset)*parent.Add
   expr1 g/(g+parent.Offset)*parent.Add
   expr2 b/(b+parent.Offset)*parent.Add
   expr3 a/(a+parent.Offset)*parent.Add
   name Expression1
   xpos -339
   ypos 576
  }
push $N4631e370
  ShuffleCopy {
   inputs 2
   red red
   green green
   blue blue
   alpha alpha2
   name ShuffleCopy1
   xpos -248
   ypos 576
  }
  Output {
   name Output1
   xpos -248
   ypos 651
  }
 end_group
 TimeBlur {
  divisions {{parent.Samples}}
  shutter {{parent.Shutter}}
  shutteroffset centred
  shuttercustomoffset 0
  name MotionBlur
  xpos -27
  ypos 581
  disable {{1-parent.mb_enable x89 0}}
 }
 ShuffleCopy {
  inputs 2
  in pos
  red red
  green green
  blue blue
  out pos
  name ShuffleCopy1
  xpos -27
  ypos 673
  disable true
 }
 Output {
  name Output1
  xpos -27
  ypos 710
 }
 Input {
  inputs 0
  name InputCamera
  xpos -1129
  ypos 116
  number 1
 }
 Camera2 {
  focal {{parent.FocalLength}}
  haperture {{parent.horizontalApeture}}
  name Camera1
  xpos -1119
  ypos 223
  addUserKnob {20 Ivy}
  addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.toolbox.v1.nodes.docs', fromlist=\['open_docs_name']).open_docs_name('IvyTab')" +STARTLINE}
  addUserKnob {26 divider4 l "" +STARTLINE}
  addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
  _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
  addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
  addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
  addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
  _expressions {{curve}}
  addUserKnob {26 divider0 l "" +STARTLINE}
  addUserKnob {20 dbinfo l "DB Info" n 1}
  dbinfo 0
  addUserKnob {1 twig_dnuuid l "Twig Id"}
  addUserKnob {1 stalk_dnuuid l "Stalk Id"}
  addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
  addUserKnob {1 leaf_dnuuid l "Leaf Id"}
  addUserKnob {26 divider1 l "" +STARTLINE}
  addUserKnob {1 twigtype l "Twig Type"}
  addUserKnob {1 leaf_label l Leaf}
  addUserKnob {1 ivy_version l Version}
  addUserKnob {43 ivy_notes l Notes}
  addUserKnob {26 divider2 l "" +STARTLINE}
  addUserKnob {1 build_label l "Build Label"}
  addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
 }
 Reformat {
  inputs 0
  format "2156 1806 0 0 2156 1806 2 JOYRIDE Working"
  resize none
  center false
  name Settings_Format
  xpos -1404
  ypos 241
 }
push $N462e3ce0
 PositionToPoints2 {
  display textured
  render_mode textured
  P_channel pos
  detail 0.25
  pointSize 0.6
  name PreviewNode
  xpos -22
  ypos 8
  disable {{!parent.Enable3DPreview}}
 }
push $N4653c780
 Reformat {
  type "to box"
  box_width 100
  box_height 100
  box_fixed true
  scale 0.1
  resize none
  filter impulse
  black_outside true
  name Reformat3
  xpos -633
  ypos -1109
  disable {{!wire_type==1}}
 }
push $N463bd8a0
 Crop {
  box {0 0 {width} {height}}
  reformat true
  crop false
  name InputFormat
  xpos -456
  ypos -402
 }
end_group
TimeOffset {
 time_offset -1182
 time ""
 name TimeOffset8
 selected true
 xpos 12347
 ypos 32690
}
Dot {
 name Dot313
 selected true
 xpos 12381
 ypos 32963
}
FileOut {
 name FileOut7
 tile_color 0xbfbf00ff
 label 2DparticleFX_2
 selected true
 xpos 12347
 ypos 33029
 icon smartgrade.png
 channels rgba
 _destination /jobs
 _stemstatus ""
 file ""
 proxy ""
 fileProxy ""
 views {main}
 first 1001
 last 1400
 pbb true
 smart_grade on
 dw_compression_level 0
 tex_metadata "default metadata and exr/*"
 disable_autolabel_format true
 _defaults "\{'smart_grade': 0, 'compression': 1, 'tile_color': 3216965887, 'pbb': True, 'dw_compression_level': 0, 'label': u'2DparticleFX_2', 'exr_metadata': 2\}"
 _format ""
 _generator "NukeRenderGenerator dnnuke.core.render.v1"
 _ivyVals "\{'variant': None, 'host': None, 'versionNum': '5', 'twigType': 'spider://query@TwigType.one?TwigType.code==2d', 'twigNameTags': \{'subtask': u'precomp', 'task': u'comp', 'label': u'2DparticleFX_2', 'out_dir': u'ELEMENT'\}, 'job': 'STONE', 'stalk': None, 'stalkAttrs': \{'framerange': '1017-1053'\}, 'twig': None, 'stem': 'spider://query@Stem.one?Stem.dnuuid==cfb45239-1375-4623-b0a4-12b2a5fba3d0&Stem.stemname==110_fof_0010&Stem.stemtype==shot'\}"
 _old_filetype exr
 _stalkname E_110_fof_0010_comp_precomp_2DparticleFX_2_v005
 _twigtype 2d
 _wrapper "FileOut dnnuke.nodes.file_out.wrapper"
 beforeRender ""
 beforeFrameRender ""
 afterFrameRender ""
 afterRender ""
 renderProgress ""
 _invert_grade /tools/STONE/ivyasset/110_fof_0010/ivy/grade/GRD_110_fof_0010_neutral_v001/GRD_110_fof_0010_neutral_v001.grade
}
BagAndTagKeep {
 name BagAndTagKeep15
 selected true
 xpos 12347
 ypos 33121
}
Read {
 inputs 0
 file_type exr
 file /jobs/JOYRIDE/hap0850/ELEMENT/E_hap0850_comp_precomp_2DparticleFX_2_v005/2156x1806/E_hap0850_comp_precomp_2DparticleFX_2_v005.####.exr
 localizationPolicy off
 format "2156 1806 0 0 2156 1806 2 JOYRIDE Working"
 proxy_format "640 480 0 0 640 480 1 PC_Video"
 first 1001
 last 1400
 origfirst 1001
 origlast 1400
 origset true
 smartGrade true
 name Read271
 selected true
 xpos 12343
 ypos 33167
 postage_stamp_frame 1200
 addUserKnob {20 Ivy}
 addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.toolbox.v1.nodes.docs', fromlist=\['open_docs_name']).open_docs_name('IvyTab')" +STARTLINE}
 addUserKnob {26 divider4 l "" +STARTLINE}
 addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
 _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
 addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
 addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
 _ivyFile /jobs/JOYRIDE/hap0850/ELEMENT/E_hap0850_comp_precomp_2DparticleFX_2_v005/2156x1806/E_hap0850_comp_precomp_2DparticleFX_2_v005.####.exr
 addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
 _expressions {{curve}}
 addUserKnob {26 divider0 l "" +STARTLINE}
 addUserKnob {20 dbinfo l "DB Info" n 1}
 dbinfo 0
 addUserKnob {1 twig_dnuuid l "Twig Id"}
 twig_dnuuid 776d86dd-5bde-4453-9885-d4e475541d96
 addUserKnob {1 stalk_dnuuid l "Stalk Id"}
 stalk_dnuuid 06d748d8-333e-4634-ac16-0e3ec60b2b7c
 addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
 twigtype_dnuuid e9f824fa-c932-4c3e-acbd-c612fb5ea846
 addUserKnob {1 leaf_dnuuid l "Leaf Id"}
 leaf_dnuuid c6abf93f-61a6-4a6e-aa5c-34247257d065
 addUserKnob {26 divider1 l "" +STARTLINE}
 addUserKnob {1 twigtype l "Twig Type"}
 twigtype elmr
 addUserKnob {1 leaf_label l Leaf}
 leaf_label main_proxy0
 addUserKnob {1 ivy_version l Version}
 ivy_version 5
 addUserKnob {43 ivy_notes l Notes}
 addUserKnob {26 divider2 l "" +STARTLINE}
 addUserKnob {1 build_label l "Build Label"}
 addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
}
BagAndTagKeep {
 name BagAndTagKeep16
 selected true
 xpos 12343
 ypos 33305
}
StickyNote {
 inputs 0
 name StickyNote30
 label "part E"
 note_font_size 50
 selected true
 xpos 15273
 ypos 31665
 addUserKnob {20 BagAndTag}
 addUserKnob {6 partOfRebuildScript l "This node is part of the rebuild script DO NOT DELETE" -STARTLINE +DISABLED}
 partOfRebuildScript true
}
Camera2 {
 inputs 0
 translate {5 0.1 0.07756583}
 rotate {0 87.69209641 0}
 name Camera49
 selected true
 xpos 15199
 ypos 32670
 addUserKnob {20 Ivy}
 addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.toolbox.v1.nodes.docs', fromlist=\['open_docs_name']).open_docs_name('IvyTab')" +STARTLINE}
 addUserKnob {26 divider4 l "" +STARTLINE}
 addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
 _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
 addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
 addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
 addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
 _expressions {{curve}}
 addUserKnob {26 divider0 l "" +STARTLINE}
 addUserKnob {20 dbinfo l "DB Info" n 1}
 dbinfo 0
 addUserKnob {1 twig_dnuuid l "Twig Id"}
 addUserKnob {1 stalk_dnuuid l "Stalk Id"}
 addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
 addUserKnob {1 leaf_dnuuid l "Leaf Id"}
 addUserKnob {26 divider1 l "" +STARTLINE}
 addUserKnob {1 twigtype l "Twig Type"}
 addUserKnob {1 leaf_label l Leaf}
 addUserKnob {1 ivy_version l Version}
 addUserKnob {43 ivy_notes l Notes}
 addUserKnob {26 divider2 l "" +STARTLINE}
 addUserKnob {1 build_label l "Build Label"}
 addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
}
set N4585a990 [stack 0]
push $N4585a990
push $N4585a990
Read {
 inputs 0
 file_type exr
 file /jobs/JOYRIDE/hap0850/ELEMENT/E_hap0850_roto_id_bg01_s01_00_L060_v001/4448x3096/e_hap0850_roto_id_bg01_s01_00_L060_v001.####.exr
 localizationPolicy off
 format "4448 3096 0 0 4448 3096 2 Alexa LF 4.5k OpenGate Ana"
 proxy_format "640 480 0 0 640 480 1 PC_Video"
 first 977
 last 1077
 origfirst 977
 origlast 1077
 origset true
 smartGrade true
 name Read372
 selected true
 xpos 14975
 ypos 31873
 postage_stamp_frame 1027
 addUserKnob {20 Ivy}
 addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.toolbox.v1.nodes.docs', fromlist=\['open_docs_name']).open_docs_name('IvyTab')" +STARTLINE}
 addUserKnob {26 divider4 l "" +STARTLINE}
 addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
 _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
 addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
 addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
 _ivyFile /jobs/JOYRIDE/hap0850/ELEMENT/E_hap0850_roto_id_bg01_s01_00_L060_v001/4448x3096/e_hap0850_roto_id_bg01_s01_00_L060_v001.####.exr
 addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
 _expressions {{curve}}
 addUserKnob {26 divider0 l "" +STARTLINE}
 addUserKnob {20 dbinfo l "DB Info" n 1}
 dbinfo 0
 addUserKnob {1 twig_dnuuid l "Twig Id"}
 twig_dnuuid cc61ea3e-7a60-46a4-93ab-42ec17917f72
 addUserKnob {1 stalk_dnuuid l "Stalk Id"}
 stalk_dnuuid ed31a171-4057-4209-9afe-e34122cfb5a6
 addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
 twigtype_dnuuid e9f824fa-c932-4c3e-acbd-c612fb5ea846
 addUserKnob {1 leaf_dnuuid l "Leaf Id"}
 leaf_dnuuid 88e88d5b-4069-43c9-ad17-0ef716c55824
 addUserKnob {26 divider1 l "" +STARTLINE}
 addUserKnob {1 twigtype l "Twig Type"}
 twigtype elmr
 addUserKnob {1 leaf_label l Leaf}
 leaf_label main_proxy0
 addUserKnob {1 ivy_version l Version}
 ivy_version 1
 addUserKnob {43 ivy_notes l Notes}
 ivy_notes "Roto Done"
 addUserKnob {26 divider2 l "" +STARTLINE}
 addUserKnob {1 build_label l "Build Label"}
 addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
}
Read {
 inputs 0
 file_type exr
 file /jobs/JOYRIDE/hap0850/ELEMENT/E_hap0850_roto_id_bg01_s01_00_L070_v001/4448x3096/e_hap0850_roto_id_bg01_s01_00_L070_v001.####.exr
 localizationPolicy off
 format "4448 3096 0 0 4448 3096 2 Alexa LF 4.5k OpenGate Ana"
 proxy_format "640 480 0 0 640 480 1 PC_Video"
 first 977
 last 1077
 origfirst 977
 origlast 1077
 origset true
 smartGrade true
 name Read373
 selected true
 xpos 15119
 ypos 31875
 postage_stamp_frame 1027
 addUserKnob {20 Ivy}
 addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.toolbox.v1.nodes.docs', fromlist=\['open_docs_name']).open_docs_name('IvyTab')" +STARTLINE}
 addUserKnob {26 divider4 l "" +STARTLINE}
 addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
 _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
 addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
 addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
 _ivyFile /jobs/JOYRIDE/hap0850/ELEMENT/E_hap0850_roto_id_bg01_s01_00_L070_v001/4448x3096/e_hap0850_roto_id_bg01_s01_00_L070_v001.####.exr
 addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
 _expressions {{curve}}
 addUserKnob {26 divider0 l "" +STARTLINE}
 addUserKnob {20 dbinfo l "DB Info" n 1}
 dbinfo 0
 addUserKnob {1 twig_dnuuid l "Twig Id"}
 twig_dnuuid 9572c24c-134b-4677-861d-0e30aa0ef0e0
 addUserKnob {1 stalk_dnuuid l "Stalk Id"}
 stalk_dnuuid d0c2fb1a-f52d-4da1-9a3f-2ca6b90528ef
 addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
 twigtype_dnuuid e9f824fa-c932-4c3e-acbd-c612fb5ea846
 addUserKnob {1 leaf_dnuuid l "Leaf Id"}
 leaf_dnuuid 04504e46-89f9-4b79-baec-f529abb055b3
 addUserKnob {26 divider1 l "" +STARTLINE}
 addUserKnob {1 twigtype l "Twig Type"}
 twigtype elmr
 addUserKnob {1 leaf_label l Leaf}
 leaf_label main_proxy0
 addUserKnob {1 ivy_version l Version}
 ivy_version 1
 addUserKnob {43 ivy_notes l Notes}
 ivy_notes "Roto Done"
 addUserKnob {26 divider2 l "" +STARTLINE}
 addUserKnob {1 build_label l "Build Label"}
 addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
}
Merge2 {
 inputs 2
 operation max
 name Merge320
 label "\[if \{ \[value mix] != 1 \} \{ return \"mix: \[value mix]\" \} else \{ return \" \"\}]"
 selected true
 xpos 15028
 ypos 32011
}
Reformat {
 resize height
 pbb true
 name Reformat19
 selected true
 xpos 15028
 ypos 32130
}
push $cut_paste_input
PostageStamp {
 name PostageStamp2
 selected true
 xpos 14744
 ypos 31875
 hide_input true
 postage_stamp true
}
Group {
 inputs 2
 name FMu_switchMatte11
 help "FMu SwitchMatte v1.0\n\nThis node will duplicate what the Switch Matte node does in Shake. \n\nYou can enable or disable a external Matte input as well as RGB premultiplication.\n@i;\nCreated by:\nFarhad Mohasseb (c) 2009"
 tile_color 0xa53962ff
 selected true
 xpos 14744
 ypos 32130
 addUserKnob {20 User}
 addUserKnob {41 from0 l "Matte Channel" T Copy2.from0}
 addUserKnob {6 disInv l Invert -STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {41 disable_1 l "Disable RGB Premult" T Premult1.disable}
 addUserKnob {6 sInput l "Disable The Matte Input" +STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {26 Credits l "@b;Created by: " T "<i>Farhad Mohasseb || .: www.FMutilities.com :.</i>"}
 addUserKnob {26 credit_hidden l "" +STARTLINE +INVISIBLE T "### Created by Farhad Mohasseb.  FMutilities © 2009 - All Rights Reserved ###"}
}
 Input {
  inputs 0
  name Input
  xpos -814
  ypos -623
 }
set N45742970 [stack 0]
 Input {
  inputs 0
  name InputMatte
  xpos -693
  ypos -679
  number 1
 }
 Switch {
  inputs 2
  which {{parent.sInput i}}
  name Switch1
  xpos -693
  ypos -623
 }
push $N45742970
 Copy {
  inputs 2
  from0 rgba.alpha
  to0 rgba.alpha
  name Copy2
  selected true
  xpos -756
  ypos -551
 }
 Invert {
  channels alpha
  name Invert1
  xpos -756
  ypos -509
  disable {{"disInv > 0 ? 0:1" i}}
 }
 Premult {
  name Premult1
  xpos -756
  ypos -467
 }
 Output {
  name Output1
  xpos -756
  ypos -428
 }
end_group
Project3D2 {
 inputs 2
 crop false
 name Project3D40
 selected true
 xpos 14744
 ypos 32314
}
Card2 {
 translate {-4.211792946 1.379999995 -4.244827271}
 rotate {0 90 0}
 uniform_scale 30
 control_points {3 3 3 6 

1 {-0.5 -0.5 0} 0 {0.1666666865 0 0} 0 {0 0 0} 0 {0 0.1666666865 0} 0 {0 0 0} 0 {0 0 0} 
1 {0 -0.5 0} 0 {0.1666666716 0 0} 0 {-0.1666666716 0 0} 0 {0 0.1666666865 0} 0 {0 0 0} 0 {0.5 0 0} 
1 {0.5 -0.5 0} 0 {0 0 0} 0 {-0.1666666865 0 0} 0 {0 0.1666666865 0} 0 {0 0 0} 0 {1 0 0} 
1 {-0.5 0 0} 0 {0.1666666865 0 0} 0 {0 0 0} 0 {0 0.1666666716 0} 0 {0 -0.1666666716 0} 0 {0 0.5 0} 
1 {0 0 0} 0 {0.1666666716 0 0} 0 {-0.1666666716 0 0} 0 {0 0.1666666716 0} 0 {0 -0.1666666716 0} 0 {0.5 0.5 0} 
1 {0.5 0 0} 0 {0 0 0} 0 {-0.1666666865 0 0} 0 {0 0.1666666716 0} 0 {0 -0.1666666716 0} 0 {1 0.5 0} 
1 {-0.5 0.5 0} 0 {0.1666666865 0 0} 0 {0 0 0} 0 {0 0 0} 0 {0 -0.1666666865 0} 0 {0 1 0} 
1 {0 0.5 0} 0 {0.1666666716 0 0} 0 {-0.1666666716 0 0} 0 {0 0 0} 0 {0 -0.1666666865 0} 0 {0.5 1 0} 
1 {0.5 0.5 0} 0 {0 0 0} 0 {-0.1666666865 0 0} 0 {0 0 0} 0 {0 -0.1666666865 0} 0 {1 1 0} }
 name Card1_arm
 selected true
 xpos 14753
 ypos 32530
}
push 0
add_layer {P P.red P.green P.blue P.alpha}
add_layer {normal normal.red normal.green normal.blue normal.alpha}
ScanlineRender {
 inputs 3
 conservative_shader_sampling false
 samples {{"\$gui?guiSamples:renderSamples"}}
 shutteroffset centred
 motion_vectors_type distance
 output_shader_vectors true
 P_channel P
 N_channel normal
 name ScanlineRender45
 label "\[value projection_mode]"
 selected true
 xpos 14749
 ypos 32684
 addUserKnob {20 User}
 addUserKnob {7 guiSamples l "GUI Samples"}
 guiSamples 1
 addUserKnob {7 renderSamples l "Render Samples"}
 renderSamples 1
}
Reformat {
 format "3840 2160 0 0 3840 2160 1 Alexa LF UHD"
 pbb true
 name Reformat20
 selected true
 xpos 14744
 ypos 32748
}
Crop {
 box {0 0 3840 2160}
 name Crop4
 selected true
 xpos 14744
 ypos 32808
}
Shuffle {
 in P
 out pos
 name Shuffle17
 label "in : \[value in] \n \[if \{ \[value red]==\"red\"\} \{return \"r\"\} elseif \{ \[value red]==\"green\"\} \{return \"g\"\} elseif \{ \[value red]==\"blue\"\} \{return \"b\"\} elseif \{ \[value red]==\"alpha\"\} \{return \"a\"\} elseif \{ \[value red]==\"white\" \} \{ return \"1\"\} elseif \{ \[value red]==\"black\" \} \{ return \"0\"\}]\[if \{ \[value green]==\"red\"\} \{return \"r\"\} elseif \{ \[value green]==\"green\"\} \{return \"g\"\} elseif \{ \[value green]==\"blue\"\} \{return \"b\"\} elseif \{ \[value green]==\"alpha\"\} \{return \"a\"\} elseif \{ \[value green]==\"white\" \} \{ return \"1\"\} elseif \{ \[value green]==\"black\" \} \{ return \"0\"\}]\[if \{ \[value blue]==\"red\"\} \{return \"r\"\} elseif \{ \[value blue]==\"green\"\} \{return \"g\"\} elseif \{ \[value blue]==\"blue\"\} \{return \"b\"\} elseif \{ \[value blue]==\"alpha\"\} \{return \"a\"\} elseif \{ \[value blue]==\"white\" \} \{ return \"1\"\} elseif \{ \[value blue]==\"black\" \} \{ return \"0\"\}]\[if \{ \[value alpha]==\"red\"\} \{return \"r\"\} elseif \{ \[value alpha]==\"green\"\} \{return \"g\"\} elseif \{ \[value alpha]==\"blue\"\} \{return \"b\"\} elseif \{ \[value alpha]==\"alpha\"\} \{return \"a\"\} elseif \{ \[value alpha]==\"white\" \} \{ return \"1\"\} elseif \{ \[value alpha]==\"black\" \} \{ return \"0\"\}]"
 selected true
 xpos 14744
 ypos 32885
}
Shuffle {
 in pos
 in2 rgba
 alpha alpha2
 out pos
 name Shuffle12_alpha_to_pos2
 label "in : \[value in] \n \[if \{ \[value red]==\"red\"\} \{return \"r\"\} elseif \{ \[value red]==\"green\"\} \{return \"g\"\} elseif \{ \[value red]==\"blue\"\} \{return \"b\"\} elseif \{ \[value red]==\"alpha\"\} \{return \"a\"\} elseif \{ \[value red]==\"white\" \} \{ return \"1\"\} elseif \{ \[value red]==\"black\" \} \{ return \"0\"\}]\[if \{ \[value green]==\"red\"\} \{return \"r\"\} elseif \{ \[value green]==\"green\"\} \{return \"g\"\} elseif \{ \[value green]==\"blue\"\} \{return \"b\"\} elseif \{ \[value green]==\"alpha\"\} \{return \"a\"\} elseif \{ \[value green]==\"white\" \} \{ return \"1\"\} elseif \{ \[value green]==\"black\" \} \{ return \"0\"\}]\[if \{ \[value blue]==\"red\"\} \{return \"r\"\} elseif \{ \[value blue]==\"green\"\} \{return \"g\"\} elseif \{ \[value blue]==\"blue\"\} \{return \"b\"\} elseif \{ \[value blue]==\"alpha\"\} \{return \"a\"\} elseif \{ \[value blue]==\"white\" \} \{ return \"1\"\} elseif \{ \[value blue]==\"black\" \} \{ return \"0\"\}]\[if \{ \[value alpha]==\"red\"\} \{return \"r\"\} elseif \{ \[value alpha]==\"green\"\} \{return \"g\"\} elseif \{ \[value alpha]==\"blue\"\} \{return \"b\"\} elseif \{ \[value alpha]==\"alpha\"\} \{return \"a\"\} elseif \{ \[value alpha]==\"white\" \} \{ return \"1\"\} elseif \{ \[value alpha]==\"black\" \} \{ return \"0\"\}]"
 selected true
 xpos 14744
 ypos 32989
}
Group {
 name PointFractal3
 tile_color 0x434343ff
 note_font_color 0x7dadf9ff
 selected true
 xpos 14744
 ypos 33103
 addUserKnob {20 User t test}
 addUserKnob {26 info l "" +STARTLINE T "Point Fractal 1.11\n"}
 addUserKnob {26 devider_noise l "<b><font color=#7DADF9>Noise Settings</font><b>"}
 addUserKnob {6 EnableOffset l "Enable Offset Input" t "Put a map into the \"Offset\" input of this node to modulate the noise based on the luminance of the map.\n\nThe red channal controls the low frequencies while the green channel controls the high frequencies.\n\nYou can for example use this to create a radially shaped noise." +STARTLINE}
 addUserKnob {6 Noise_Absolute l "Absolute Noise" t "Negative values in the noise offset is made positive." -STARTLINE}
 addUserKnob {3 Noise_Octaves l Octaves}
 Noise_Octaves 8
 addUserKnob {7 Noise_Gain l Gain}
 Noise_Gain 0.5
 addUserKnob {7 Noise_Lacunarity l Lacunarity R 0 4}
 Noise_Lacunarity 0.5
 addUserKnob {18 Amplitude}
 Amplitude 0.5
 addUserKnob {6 Amplitude_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {3 Itterations l Iterations}
 Itterations 4
 addUserKnob {26 invis_devider_noise l "" +STARTLINE T " "}
 addUserKnob {26 Devider_Frequency l "<b><font color=#7DADF9>Freq Control</font><b>"}
 addUserKnob {19 Freq_Offset l "General Offset" t "This is like a 3D translation, letting you move the current noise pattern in the X, Y, Z and W (4th dimention)" R 0 10}
 Freq_Offset {0 0 0 0}
 addUserKnob {6 Freq_Offset_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 Freq_GeneralScale l "Genral Scale" t "This lets you control the scale of each individual noise axis."}
 Freq_GeneralScale 1
 addUserKnob {6 Freq_GeneralScale_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {26 invis_devider_freq l "" +STARTLINE T " "}
 addUserKnob {19 Freq_EvolveLow l "Evolve Low" t "This lets you evolve (auto animate) the noise in a particular direction. The \"Low\" part means that this only affects the low frequencies.\n\nTo avoid a \"scrolling\" effect you can use the 4th dimention to break up the spatial cohearence." R 0 10}
 Freq_EvolveLow {0.5 0.5 0 0.5}
 addUserKnob {6 Freq_EvolveLow_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleLow_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 Freq_EvolveHigh l "Evolve High" t "This lets you evolve (auto animate) the noise in a particular direction. The \"High\" part means that this only affects the high frequencies.\n\nTo avoid a \"scrolling\" effect you can use the 4th dimention to break up the spatial cohearence."}
 Freq_EvolveHigh {0 0.5 0 0}
 addUserKnob {6 Freq_EvolveHigh_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {26 invis_devider_freq2 l "" +STARTLINE T " "}
 addUserKnob {19 Freq_ScaleLow l "Scale Low" t "This lets you scale the noise in a particular axis. The \"Low\" part means that this only affects the low frequencies."}
 Freq_ScaleLow {1 1 1 1}
 addUserKnob {6 Freq_ScaleLow_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 Freq_ScaleHigh l "Scale High" t "This lets you scale the noise in a particular axis. The \"High\" part means that this only affects the high frequencies."}
 Freq_ScaleHigh {1 1 1 1}
 addUserKnob {6 Freq_ScaleHigh_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {26 invis_devider_freq3 l "" +STARTLINE T " "}
 addUserKnob {26 Curve l "<b><font color=#7DADF9>Curve Noise</font><b>"}
 addUserKnob {6 CurveNoise_Enable l Enable t "Adds a gamma curve to the noise intensity making noise near the \"Offset\" value more flat. This is a experimental feature." +STARTLINE}
 addUserKnob {6 CurveNoise_Invert l Invert t "Inverts the effect of the curved noise." -STARTLINE}
 addUserKnob {7 CurveGain l "Curve Gain" R -10 10}
 CurveGain 3
 addUserKnob {7 CurveOffset l "Curve Offset" R -2 2}
 addUserKnob {26 gabgen l "" +STARTLINE T "\n"}
 addUserKnob {26 info_mask l "<b><font color=#7DADF9>Mask</font><b>"}
 addUserKnob {41 maskChannelMask l "" t "If a node is connected to the mask input, this will let you mask off the effect of the noise.\nIts recommended that you use the Point_Texture node to ensure a correct aspect and size." -STARTLINE T Merge1.maskChannelMask}
 addUserKnob {41 inject -STARTLINE T Merge1.inject}
 addUserKnob {41 invert_mask l invert -STARTLINE T Merge1.invert_mask}
 addUserKnob {41 fringe -STARTLINE T Merge1.fringe}
 addUserKnob {41 mix T Merge1.mix}
}
 Input {
  inputs 0
  name InputMask
  xpos -714
  ypos 297
  number 1
 }
 Reformat {
  type "to box"
  box_width {{parent.InputFormat.box.r}}
  box_height {{parent.InputFormat.box.t}}
  box_fixed true
  resize distort
  name Reformat2
  xpos -714
  ypos 396
 }
 Shuffle {
  name Shuffle3
  xpos -714
  ypos 420
 }
 Input {
  inputs 0
  name InputOffset
  xpos -208
  ypos 61
  number 2
 }
 Dot {
  name Dot2
  xpos -174
  ypos 153
 }
 Input {
  inputs 0
  name InputData
  xpos -582
  ypos 73
 }
 Dot {
  name Dot1
  xpos -548
  ypos 114
 }
set N455dbb50 [stack 0]
 Shuffle {
  in pos
  name Shuffle1
  xpos -470
  ypos 110
 }
set N455e0960 [stack 0]
 Multiply {
  value 0
  name Multiply1
  xpos -338
  ypos 106
 }
 Merge2 {
  inputs 2
  operation copy
  name Merge2
  xpos -338
  ypos 150
 }
push $N455e0960
 BlinkScript {
  inputs 2
  kernelSourceFile /Users/madshagbarth/Github/Nuke-Private/Blink/PointRender/Modify/Fractal_v08.cpp
  recompileCount 64
  ProgramGroup 1
  KernelDescription "2 \"Noise4D\" iterate pixelWise be1f493003df1b115acb2d181bf4caa997e214937eb46d4cd65a56edf3425cad 3 \"src\" Read Point \"modix\" Read Point \"dst\" Write Point 19 \"absNoise\" Bool 1 AA== \"curveNoise\" Bool 1 AA== \"curveInvert\" Bool 1 AA== \"radialNoise\" Bool 1 AA== \"curveGain\" Float 1 AACAPw== \"curveOffset\" Float 1 AACAPw== \"Octaves\" Int 1 CgAAAA== \"Gain\" Float 1 AAAAPw== \"Lacunarity\" Float 1 AAAAQA== \"Gamma\" Float 1 AAAAPw== \"amplitude\" Float 3 AAAAPwAAAD8AAAA/AAAAAA== \"itterations\" Int 1 AQAAAA== \"Offset\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"Scale\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"suboffset\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"topoffset\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"subscale\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"topscale\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"center\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== 19 \"absNoise\" 1 1 \"curveNoise\" 1 1 \"curveInvert\" 1 1 \"radialNoise\" 1 1 \"curveGain\" 1 1 \"curveOffset\" 1 1 \"octaves\" 1 1 \"gain\" 1 1 \"lacunarity\" 1 1 \"gamma\" 1 1 \"amplitude\" 3 1 \"itterations\" 1 1 \"offset\" 4 1 \"scale\" 4 1 \"suboffset\" 4 1 \"topoffset\" 4 1 \"subscale\" 4 1 \"topscale\" 4 1 \"center\" 3 1 0"
  kernelSource "//Based on https://github.com/Draradech/csworldgen/blob/master/simplexnoise.cpp\n//Ported by Mads Hagbarth Lund 2014\n\n/* Copyright (c) 2007-2012 Eliot Eshelman\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n\nint fastfloor( const float x ) \{ return x > 0 ? (int) x : (int) x - 1; \}\ninline float raw_noise_4d( const float x, const float y, const float z, const float w ) \n\{\nint simplex\[64]\[4] = \{\n    \{0,1,2,3\},\{0,1,3,2\},\{0,0,0,0\},\{0,2,3,1\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{1,2,3,0\},\n    \{0,2,1,3\},\{0,0,0,0\},\{0,3,1,2\},\{0,3,2,1\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{1,3,2,0\},\n    \{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\n    \{1,2,0,3\},\{0,0,0,0\},\{1,3,0,2\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{2,3,0,1\},\{2,3,1,0\},\n    \{1,0,2,3\},\{1,0,3,2\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{2,0,3,1\},\{0,0,0,0\},\{2,1,3,0\},\n    \{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\n    \{2,0,1,3\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{3,0,1,2\},\{3,0,2,1\},\{0,0,0,0\},\{3,1,2,0\},\n    \{2,1,0,3\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{3,1,0,2\},\{0,0,0,0\},\{3,2,0,1\},\{3,2,1,0\}\n\};\n    int perm\[512] = \{\n        151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,\n        8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,\n        35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,\n        134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,\n        55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208, 89,\n        18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,\n        250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,\n        189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,\n        172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,\n        228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,\n        107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,\n        138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180,\n\n        151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,\n        8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,\n        35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,\n        134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,\n        55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208, 89,\n        18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,\n        250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,\n        189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,\n        172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,\n        228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,\n        107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,\n        138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180\n    \};\n   int grad4\[32]\[4]= \{\n    \{0,1,1,1\},  \{0,1,1,-1\},  \{0,1,-1,1\},  \{0,1,-1,-1\},\n    \{0,-1,1,1\}, \{0,-1,1,-1\}, \{0,-1,-1,1\}, \{0,-1,-1,-1\},\n    \{1,0,1,1\},  \{1,0,1,-1\},  \{1,0,-1,1\},  \{1,0,-1,-1\},\n    \{-1,0,1,1\}, \{-1,0,1,-1\}, \{-1,0,-1,1\}, \{-1,0,-1,-1\},\n    \{1,1,0,1\},  \{1,1,0,-1\},  \{1,-1,0,1\},  \{1,-1,0,-1\},\n    \{-1,1,0,1\}, \{-1,1,0,-1\}, \{-1,-1,0,1\}, \{-1,-1,0,-1\},\n    \{1,1,1,0\},  \{1,1,-1,0\},  \{1,-1,1,0\},  \{1,-1,-1,0\},\n    \{-1,1,1,0\}, \{-1,1,-1,0\}, \{-1,-1,1,0\}, \{-1,-1,-1,0\}\n   \};\n    float F4 = (sqrt(5.0f)-1.0f)/4.0f;\n    float G4 = (5.0f-sqrt(5.0f))/20.0f;\n    float n0, n1, n2, n3, n4;\n    float s = (x + y + z + w) * F4;\n    int i = fastfloor(x + s);\n    int j = fastfloor(y + s);\n    int k = fastfloor(z + s);\n    int l = fastfloor(w + s);\n    float t = (i + j + k + l) * G4;\n    float X0 = i - t;\n    float Y0 = j - t;\n    float Z0 = k - t;\n    float W0 = l - t;\n\n    float x0 = x - X0;\n    float y0 = y - Y0;\n    float z0 = z - Z0;\n    float w0 = w - W0;\n    int c1 = (x0 > y0) ? 32 : 0;\n    int c2 = (x0 > z0) ? 16 : 0;\n    int c3 = (y0 > z0) ? 8 : 0;\n    int c4 = (x0 > w0) ? 4 : 0;\n    int c5 = (y0 > w0) ? 2 : 0;\n    int c6 = (z0 > w0) ? 1 : 0;\n    int c = c1 + c2 + c3 + c4 + c5 + c6;\n\n    int i1, j1, k1, l1;\n    int i2, j2, k2, l2;\n    int i3, j3, k3, l3;\n    i1 = simplex\[c]\[0]>=3 ? 1 : 0;\n    j1 = simplex\[c]\[1]>=3 ? 1 : 0;\n    k1 = simplex\[c]\[2]>=3 ? 1 : 0;\n    l1 = simplex\[c]\[3]>=3 ? 1 : 0;\n    i2 = simplex\[c]\[0]>=2 ? 1 : 0;\n    j2 = simplex\[c]\[1]>=2 ? 1 : 0;\n    k2 = simplex\[c]\[2]>=2 ? 1 : 0;\n    l2 = simplex\[c]\[3]>=2 ? 1 : 0;\n    i3 = simplex\[c]\[0]>=1 ? 1 : 0;\n    j3 = simplex\[c]\[1]>=1 ? 1 : 0;\n    k3 = simplex\[c]\[2]>=1 ? 1 : 0;\n    l3 = simplex\[c]\[3]>=1 ? 1 : 0;\n    float x1 = x0 - i1 + G4;\n    float y1 = y0 - j1 + G4;\n    float z1 = z0 - k1 + G4;\n    float w1 = w0 - l1 + G4;\n    float x2 = x0 - i2 + 2.0*G4;\n    float y2 = y0 - j2 + 2.0*G4;\n    float z2 = z0 - k2 + 2.0*G4;\n    float w2 = w0 - l2 + 2.0*G4;\n    float x3 = x0 - i3 + 3.0*G4;\n    float y3 = y0 - j3 + 3.0*G4;\n    float z3 = z0 - k3 + 3.0*G4;\n    float w3 = w0 - l3 + 3.0*G4;\n    float x4 = x0 - 1.0 + 4.0*G4;\n    float y4 = y0 - 1.0 + 4.0*G4;\n    float z4 = z0 - 1.0 + 4.0*G4;\n    float w4 = w0 - 1.0 + 4.0*G4;\n    int ii = i & 255;\n    int jj = j & 255;\n    int kk = k & 255;\n    int ll = l & 255;\n    int gi0 = perm\[ii+perm\[jj+perm\[kk+perm\[ll]]]] % 32;\n    int gi1 = perm\[ii+i1+perm\[jj+j1+perm\[kk+k1+perm\[ll+l1]]]] % 32;\n    int gi2 = perm\[ii+i2+perm\[jj+j2+perm\[kk+k2+perm\[ll+l2]]]] % 32;\n    int gi3 = perm\[ii+i3+perm\[jj+j3+perm\[kk+k3+perm\[ll+l3]]]] % 32;\n    int gi4 = perm\[ii+1+perm\[jj+1+perm\[kk+1+perm\[ll+1]]]] % 32;\n    float t0 = 0.6 - x0*x0 - y0*y0 - z0*z0 - w0*w0;\n    if(t0<0) n0 = 0.0;\n    else \{\n        t0 *= t0;\n        n0 = t0 * t0 * dot(float4(grad4\[gi0]\[0],grad4\[gi0]\[2],grad4\[gi0]\[3],grad4\[gi0]\[3]), float4(x0, y0, z0, w0));\n    \}\n    float t1 = 0.6 - x1*x1 - y1*y1 - z1*z1 - w1*w1;\n    if(t1<0) n1 = 0.0;\n    else \{\n        t1 *= t1;\n        n1 = t1 * t1 * dot(float4(grad4\[gi1]\[0],grad4\[gi1]\[2],grad4\[gi1]\[3],grad4\[gi1]\[3]), float4(x1, y1, z1, w1));\n    \}\n    float t2 = 0.6 - x2*x2 - y2*y2 - z2*z2 - w2*w2;\n    if(t2<0) n2 = 0.0;\n    else \{\n        t2 *= t2;\n        n2 = t2 * t2 * dot(float4(grad4\[gi2]\[0],grad4\[gi2]\[2],grad4\[gi2]\[3],grad4\[gi2]\[3]), float4(x2, y2, z2, w2));\n    \}\n    float t3 = 0.6 - x3*x3 - y3*y3 - z3*z3 - w3*w3;\n    if(t3<0) n3 = 0.0;\n    else \{\n        t3 *= t3;\n        n3 = t3 * t3 * dot(float4(grad4\[gi3]\[0],grad4\[gi3]\[2],grad4\[gi3]\[3],grad4\[gi3]\[3]), float4(x3, y3, z3, w3));\n    \}\n    float t4 = 0.6 - x4*x4 - y4*y4 - z4*z4 - w4*w4;\n    if(t4<0) n4 = 0.0;\n    else \{\n        t4 *= t4;\n        n4 = t4 * t4 * dot(float4(grad4\[gi4]\[0],grad4\[gi4]\[2],grad4\[gi4]\[3],grad4\[gi4]\[3]), float4(x4, y4, z4, w4));\n    \}\n    return 27.0 * (n0 + n1 + n2 + n3 + n4);\n\}\n\n\n\n\nkernel Noise4D : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n    Image<eRead, eAccessPoint, eEdgeClamped> modix;\n  Image<eWrite, eAccessPoint> dst;\nparam:\n    bool absNoise;\n    bool curveNoise;\n    bool curveInvert;\n    bool radialNoise;\n    float curveGain;\n    float curveOffset;\n    int octaves;\n    float gain;\n    float lacunarity;\n    float gamma;\n    float3 amplitude;\n    int itterations;\n    float4 offset;\n    float4 scale;\n    float4 suboffset;\n    float4 topoffset;\n    float4 subscale;\n    float4 topscale;\n    float3 center;\n\n\n  void define() \{\n        defineParam (absNoise, \"absNoise\", false);    \n        defineParam (curveNoise, \"curveNoise\", false);    \n        defineParam (curveInvert, \"curveInvert\", false);   \n        defineParam (radialNoise, \"radialNoise\", false);   //Used for radial noise\n        defineParam (curveGain, \"curveGain\", 1.0f);\n        defineParam (curveOffset, \"curveOffset\", 1.0f);\n        defineParam (octaves, \"Octaves\", 10);\n        defineParam (gain, \"Gain\", 0.5f);\n        defineParam (lacunarity, \"Lacunarity\", 2.0f);\n        defineParam (gamma, \"Gamma\", 0.5f);\n        defineParam (amplitude, \"amplitude\", float3(0.5f));\n        defineParam (itterations, \"itterations\", 1);\n        defineParam(offset, \"Offset\", float4(0.0f, 0.0f, 0.0f,0.0f));\n        defineParam(scale, \"Scale\", float4(1.0f, 1.0f, 1.0f,1.0f));\n        defineParam(suboffset, \"suboffset\", float4(1.0f, 1.0f, 1.0f,1.0f));\n        defineParam(topoffset, \"topoffset\", float4(1.0f, 1.0f, 1.0f,1.0f));\n        defineParam(subscale, \"subscale\", float4(1.0f, 1.0f, 1.0f,1.0f));\n        defineParam(topscale, \"topscale\", float4(1.0f, 1.0f, 1.0f,1.0f));   \n        defineParam(center, \"center\", float3(0.0f,0.0f,0.0f));   //Center for the radial noise      \n  \}\n\nfloat4 sphericalTransform( const float4 cartesian) \n\{\n    return float4(\n(atan2(cartesian.x-center.x,cartesian.y-center.y)+ PI)/+ (PI*2.0f),\n(atan2(cartesian.x-center.x,cartesian.z-center.z)+ PI)/+ (PI*2.0f),\n(atan2(cartesian.z-center.z,cartesian.y-center.y)+ PI)/+ (PI*2.0f),\ncartesian.w\n);\n\}\n\nfloat octave_noise_4d( float4 modulix, const float octaves, const float persistence, const float scale, const float x, const float y, const float z, const float w ) \n\{\n    float total = 0.0f;\n    float current;\n    float last = 1.0f;\n    float frequency = scale;\n    float amplitude = 1.0f;\n    float maxAmplitude = 0.0f;\n    float4 Tempoffset;\n    float4 Tempscale;\n\n\n    for( int i=0; i < octaves; i++ ) \{\n\n        /*\n        if (i == 0) \{\n            total += (float)raw_noise_4d( (x+suboffset.x) * frequency, (y+suboffset.y) * frequency, (z+suboffset.z) * frequency, (w+suboffset.w) * frequency ) * amplitude;\n        \}\n        else if (i == octaves-1) \{\n            total += (float)raw_noise_4d( (x+topoffset.x) * frequency, (y+topoffset.y) * frequency, (z+topoffset.z) * frequency, (w+topoffset.w) * frequency ) * amplitude;\n        \}\n        else \{\n            total += (float)raw_noise_4d( x * frequency, y * frequency, z * frequency, w * frequency ) * amplitude;\n        \}\n        */\n\n\n        Tempscale = (topscale * (i/(octaves-1.0f)))+(subscale * (1-(i/(octaves-1.0f))));       \n        Tempoffset = ((topoffset+modulix.y) * (i/(octaves-1.0f)))+((suboffset+modulix.x) * (1-(i/(octaves-1.0f))));\n        current = (float)raw_noise_4d(   ((x*Tempscale.x)+Tempoffset.x) * frequency, \n                                        ((y*Tempscale.y)+Tempoffset.y) * frequency, \n                                        ((z*Tempscale.z)+Tempoffset.z) * frequency, \n                                        ((w*Tempscale.w)+Tempoffset.w) * frequency \n                                        ) * amplitude;\n        if (i == 0 && curveNoise)\{\n            if (curveInvert)\{\n                last = 0.5f-current;  \n            \}\n            else\{\n                last = current;  \n            \}\n               \n        \}\n        current = curveNoise?current*((last+curveOffset)*curveGain):current;\n        total += absNoise?fabs(current):current;\n        frequency *= 2.0f;\n        maxAmplitude += amplitude;\n        amplitude *= persistence;\n\n    \}\n    return float(total / maxAmplitude);\n\}\n\n\n\n\n  void process() \{\n    float4 srcSample = float4(src(0),src(1),src(2),src(3));\n    float4 srcSampleModix = modix();\n    float sampleR,sampleG,sampleB;\n    if (radialNoise)\{\n        srcSample = sphericalTransform(srcSample);\n    \}\n\n    for( int i=0; i < itterations; i++ ) \{\n        sampleR = (float)octave_noise_4d(srcSampleModix,float(octaves), gain, lacunarity, ( srcSample.x * scale.x ) + offset.x, ( srcSample.y * scale.y ) + offset.y,  ( srcSample.z * scale.z ) + offset.z, ( srcSample.w * scale.w ) + offset.w) * amplitude.x;\n        sampleG = (float)octave_noise_4d(srcSampleModix,float(octaves), gain, lacunarity, ( srcSample.x * scale.x ) + offset.x, ( srcSample.y * scale.y ) + offset.y,  ( srcSample.z * scale.z ) + offset.z, ( srcSample.w * scale.w ) + offset.w - 100.0f) * amplitude.y;\n        sampleB = (float)octave_noise_4d(srcSampleModix,float(octaves), gain, lacunarity, ( srcSample.x * scale.x ) + offset.x, ( srcSample.y * scale.y ) + offset.y,  ( srcSample.z * scale.z ) + offset.z, ( srcSample.w * scale.w ) + offset.w + 200.0f) * amplitude.z;\n        srcSample = float4(srcSample.x+sampleR,srcSample.y+sampleG,srcSample.z+sampleB,srcSample.w);\n    \}\n    dst() = float4(srcSample.x,srcSample.y,srcSample.z,1.0f);\n\}\n\};"
  rebuild ""
  Noise4D_curveNoise {{parent.CurveNoise_Enable}}
  Noise4D_curveInvert {{parent.CurveNoise_Invert}}
  Noise4D_curveGain {{parent.CurveGain}}
  Noise4D_curveOffset {{parent.CurveOffset}}
  Noise4D_Octaves {{parent.Noise_Octaves}}
  Noise4D_Gain {{parent.Noise_Gain}}
  Noise4D_Lacunarity {{parent.Noise_Lacunarity}}
  Noise4D_Gamma 0.79
  Noise4D_amplitude {{parent.Amplitude.r} {parent.Amplitude.g} {parent.Amplitude.b}}
  Noise4D_itterations {{parent.Itterations}}
  Noise4D_Offset {{parent.Freq_Offset} {parent.Freq_Offset} {parent.Freq_Offset} {parent.Freq_Offset}}
  Noise4D_Scale {{parent.Freq_GeneralScale} {parent.Freq_GeneralScale} {parent.Freq_GeneralScale} {parent.Freq_GeneralScale}}
  Noise4D_suboffset {{(frame*parent.Freq_EvolveLow.r)/50} {(frame*parent.Freq_EvolveLow.g)/50} {(frame*parent.Freq_EvolveLow.b)/50} {(frame*parent.Freq_EvolveLow.a)/50}}
  Noise4D_topoffset {{(frame*parent.Freq_EvolveHigh.r)/10} {(frame*parent.Freq_EvolveHigh.g)/10} {(frame*parent.Freq_EvolveHigh.b)/10} {(frame*parent.Freq_EvolveHigh.a)/10}}
  Noise4D_subscale {{parent.Freq_ScaleLow} {parent.Freq_ScaleLow} {parent.Freq_ScaleLow} {parent.Freq_ScaleLow}}
  Noise4D_topscale {{parent.Freq_ScaleHigh} {parent.Freq_ScaleHigh} {parent.Freq_ScaleHigh} {parent.Freq_ScaleHigh}}
  rebuild_finalise ""
  name Noise4D2
  xpos -338
  ypos 321
 }
push $N455e0960
 BlinkScript {
  kernelSourceFile /Users/madshagbarth/Github/Nuke-Private/Blink/PointRender/Modify/Fractal_v06.cpp
  recompileCount 60
  ProgramGroup 1
  KernelDescription "2 \"Noise4D\" iterate pixelWise d54284af3e5573ad197bef9032773e8653de2cad590694fcc9fd5af993e97da3 2 \"src\" Read Point \"dst\" Write Point 17 \"absNoise\" Bool 1 AA== \"curveNoise\" Bool 1 AA== \"curveInvert\" Bool 1 AA== \"curveGain\" Float 1 AACAPw== \"curveOffset\" Float 1 AACAPw== \"Octaves\" Int 1 CgAAAA== \"Gain\" Float 1 AAAAPw== \"Lacunarity\" Float 1 AAAAQA== \"Gamma\" Float 1 AAAAPw== \"amplitude\" Float 3 AAAAPwAAAD8AAAA/AAAAAA== \"itterations\" Int 1 AQAAAA== \"Offset\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"Scale\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"suboffset\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"topoffset\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"subscale\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"topscale\" Float 4 AACAPwAAgD8AAIA/AACAPw== 17 \"absNoise\" 1 1 \"curveNoise\" 1 1 \"curveInvert\" 1 1 \"curveGain\" 1 1 \"curveOffset\" 1 1 \"octaves\" 1 1 \"gain\" 1 1 \"lacunarity\" 1 1 \"gamma\" 1 1 \"amplitude\" 3 1 \"itterations\" 1 1 \"offset\" 4 1 \"scale\" 4 1 \"suboffset\" 4 1 \"topoffset\" 4 1 \"subscale\" 4 1 \"topscale\" 4 1 0"
  kernelSource "//Based on https://github.com/Draradech/csworldgen/blob/master/simplexnoise.cpp\n//Ported by Mads Hagbarth Lund 2014\n\n/* Copyright (c) 2007-2012 Eliot Eshelman\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n\nint fastfloor( const float x ) \{ return x > 0 ? (int) x : (int) x - 1; \}\ninline float raw_noise_4d( const float x, const float y, const float z, const float w ) \n\{\nint simplex\[64]\[4] = \{\n    \{0,1,2,3\},\{0,1,3,2\},\{0,0,0,0\},\{0,2,3,1\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{1,2,3,0\},\n    \{0,2,1,3\},\{0,0,0,0\},\{0,3,1,2\},\{0,3,2,1\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{1,3,2,0\},\n    \{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\n    \{1,2,0,3\},\{0,0,0,0\},\{1,3,0,2\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{2,3,0,1\},\{2,3,1,0\},\n    \{1,0,2,3\},\{1,0,3,2\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{2,0,3,1\},\{0,0,0,0\},\{2,1,3,0\},\n    \{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\n    \{2,0,1,3\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{3,0,1,2\},\{3,0,2,1\},\{0,0,0,0\},\{3,1,2,0\},\n    \{2,1,0,3\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{3,1,0,2\},\{0,0,0,0\},\{3,2,0,1\},\{3,2,1,0\}\n\};\n    int perm\[512] = \{\n        151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,\n        8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,\n        35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,\n        134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,\n        55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208, 89,\n        18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,\n        250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,\n        189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,\n        172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,\n        228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,\n        107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,\n        138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180,\n\n        151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,\n        8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,\n        35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,\n        134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,\n        55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208, 89,\n        18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,\n        250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,\n        189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,\n        172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,\n        228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,\n        107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,\n        138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180\n    \};\n   int grad4\[32]\[4]= \{\n    \{0,1,1,1\},  \{0,1,1,-1\},  \{0,1,-1,1\},  \{0,1,-1,-1\},\n    \{0,-1,1,1\}, \{0,-1,1,-1\}, \{0,-1,-1,1\}, \{0,-1,-1,-1\},\n    \{1,0,1,1\},  \{1,0,1,-1\},  \{1,0,-1,1\},  \{1,0,-1,-1\},\n    \{-1,0,1,1\}, \{-1,0,1,-1\}, \{-1,0,-1,1\}, \{-1,0,-1,-1\},\n    \{1,1,0,1\},  \{1,1,0,-1\},  \{1,-1,0,1\},  \{1,-1,0,-1\},\n    \{-1,1,0,1\}, \{-1,1,0,-1\}, \{-1,-1,0,1\}, \{-1,-1,0,-1\},\n    \{1,1,1,0\},  \{1,1,-1,0\},  \{1,-1,1,0\},  \{1,-1,-1,0\},\n    \{-1,1,1,0\}, \{-1,1,-1,0\}, \{-1,-1,1,0\}, \{-1,-1,-1,0\}\n   \};\n    float F4 = (sqrt(5.0f)-1.0f)/4.0f;\n    float G4 = (5.0f-sqrt(5.0f))/20.0f;\n    float n0, n1, n2, n3, n4;\n    float s = (x + y + z + w) * F4;\n    int i = fastfloor(x + s);\n    int j = fastfloor(y + s);\n    int k = fastfloor(z + s);\n    int l = fastfloor(w + s);\n    float t = (i + j + k + l) * G4;\n    float X0 = i - t;\n    float Y0 = j - t;\n    float Z0 = k - t;\n    float W0 = l - t;\n\n    float x0 = x - X0;\n    float y0 = y - Y0;\n    float z0 = z - Z0;\n    float w0 = w - W0;\n    int c1 = (x0 > y0) ? 32 : 0;\n    int c2 = (x0 > z0) ? 16 : 0;\n    int c3 = (y0 > z0) ? 8 : 0;\n    int c4 = (x0 > w0) ? 4 : 0;\n    int c5 = (y0 > w0) ? 2 : 0;\n    int c6 = (z0 > w0) ? 1 : 0;\n    int c = c1 + c2 + c3 + c4 + c5 + c6;\n\n    int i1, j1, k1, l1;\n    int i2, j2, k2, l2;\n    int i3, j3, k3, l3;\n    i1 = simplex\[c]\[0]>=3 ? 1 : 0;\n    j1 = simplex\[c]\[1]>=3 ? 1 : 0;\n    k1 = simplex\[c]\[2]>=3 ? 1 : 0;\n    l1 = simplex\[c]\[3]>=3 ? 1 : 0;\n    i2 = simplex\[c]\[0]>=2 ? 1 : 0;\n    j2 = simplex\[c]\[1]>=2 ? 1 : 0;\n    k2 = simplex\[c]\[2]>=2 ? 1 : 0;\n    l2 = simplex\[c]\[3]>=2 ? 1 : 0;\n    i3 = simplex\[c]\[0]>=1 ? 1 : 0;\n    j3 = simplex\[c]\[1]>=1 ? 1 : 0;\n    k3 = simplex\[c]\[2]>=1 ? 1 : 0;\n    l3 = simplex\[c]\[3]>=1 ? 1 : 0;\n    float x1 = x0 - i1 + G4;\n    float y1 = y0 - j1 + G4;\n    float z1 = z0 - k1 + G4;\n    float w1 = w0 - l1 + G4;\n    float x2 = x0 - i2 + 2.0*G4;\n    float y2 = y0 - j2 + 2.0*G4;\n    float z2 = z0 - k2 + 2.0*G4;\n    float w2 = w0 - l2 + 2.0*G4;\n    float x3 = x0 - i3 + 3.0*G4;\n    float y3 = y0 - j3 + 3.0*G4;\n    float z3 = z0 - k3 + 3.0*G4;\n    float w3 = w0 - l3 + 3.0*G4;\n    float x4 = x0 - 1.0 + 4.0*G4;\n    float y4 = y0 - 1.0 + 4.0*G4;\n    float z4 = z0 - 1.0 + 4.0*G4;\n    float w4 = w0 - 1.0 + 4.0*G4;\n    int ii = i & 255;\n    int jj = j & 255;\n    int kk = k & 255;\n    int ll = l & 255;\n    int gi0 = perm\[ii+perm\[jj+perm\[kk+perm\[ll]]]] % 32;\n    int gi1 = perm\[ii+i1+perm\[jj+j1+perm\[kk+k1+perm\[ll+l1]]]] % 32;\n    int gi2 = perm\[ii+i2+perm\[jj+j2+perm\[kk+k2+perm\[ll+l2]]]] % 32;\n    int gi3 = perm\[ii+i3+perm\[jj+j3+perm\[kk+k3+perm\[ll+l3]]]] % 32;\n    int gi4 = perm\[ii+1+perm\[jj+1+perm\[kk+1+perm\[ll+1]]]] % 32;\n    float t0 = 0.6 - x0*x0 - y0*y0 - z0*z0 - w0*w0;\n    if(t0<0) n0 = 0.0;\n    else \{\n        t0 *= t0;\n        n0 = t0 * t0 * dot(float4(grad4\[gi0]\[0],grad4\[gi0]\[2],grad4\[gi0]\[3],grad4\[gi0]\[3]), float4(x0, y0, z0, w0));\n    \}\n    float t1 = 0.6 - x1*x1 - y1*y1 - z1*z1 - w1*w1;\n    if(t1<0) n1 = 0.0;\n    else \{\n        t1 *= t1;\n        n1 = t1 * t1 * dot(float4(grad4\[gi1]\[0],grad4\[gi1]\[2],grad4\[gi1]\[3],grad4\[gi1]\[3]), float4(x1, y1, z1, w1));\n    \}\n    float t2 = 0.6 - x2*x2 - y2*y2 - z2*z2 - w2*w2;\n    if(t2<0) n2 = 0.0;\n    else \{\n        t2 *= t2;\n        n2 = t2 * t2 * dot(float4(grad4\[gi2]\[0],grad4\[gi2]\[2],grad4\[gi2]\[3],grad4\[gi2]\[3]), float4(x2, y2, z2, w2));\n    \}\n    float t3 = 0.6 - x3*x3 - y3*y3 - z3*z3 - w3*w3;\n    if(t3<0) n3 = 0.0;\n    else \{\n        t3 *= t3;\n        n3 = t3 * t3 * dot(float4(grad4\[gi3]\[0],grad4\[gi3]\[2],grad4\[gi3]\[3],grad4\[gi3]\[3]), float4(x3, y3, z3, w3));\n    \}\n    float t4 = 0.6 - x4*x4 - y4*y4 - z4*z4 - w4*w4;\n    if(t4<0) n4 = 0.0;\n    else \{\n        t4 *= t4;\n        n4 = t4 * t4 * dot(float4(grad4\[gi4]\[0],grad4\[gi4]\[2],grad4\[gi4]\[3],grad4\[gi4]\[3]), float4(x4, y4, z4, w4));\n    \}\n    return 27.0 * (n0 + n1 + n2 + n3 + n4);\n\}\n\n\n\n\nkernel Noise4D : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n  Image<eWrite, eAccessPoint> dst;\nparam:\n    bool absNoise;\n    bool curveNoise;\n    bool curveInvert;\n    float curveGain;\n    float curveOffset;\n    int octaves;\n    float gain;\n    float lacunarity;\n    float gamma;\n    float3 amplitude;\n    int itterations;\n    float4 offset;\n    float4 scale;\n    float4 suboffset;\n    float4 topoffset;\n    float4 subscale;\n    float4 topscale;\n\n\n  void define() \{\n        defineParam (absNoise, \"absNoise\", false);    \n        defineParam (curveNoise, \"curveNoise\", false);    \n        defineParam (curveInvert, \"curveInvert\", false);   \n        defineParam (curveGain, \"curveGain\", 1.0f);\n        defineParam (curveOffset, \"curveOffset\", 1.0f);\n        defineParam (octaves, \"Octaves\", 10);\n        defineParam (gain, \"Gain\", 0.5f);\n        defineParam (lacunarity, \"Lacunarity\", 2.0f);\n        defineParam (gamma, \"Gamma\", 0.5f);\n        defineParam (amplitude, \"amplitude\", float3(0.5f));\n        defineParam (itterations, \"itterations\", 1);\n        defineParam(offset, \"Offset\", float4(0.0f, 0.0f, 0.0f,0.0f));\n        defineParam(scale, \"Scale\", float4(1.0f, 1.0f, 1.0f,1.0f));\n        defineParam(suboffset, \"suboffset\", float4(1.0f, 1.0f, 1.0f,1.0f));\n        defineParam(topoffset, \"topoffset\", float4(1.0f, 1.0f, 1.0f,1.0f));\n        defineParam(subscale, \"subscale\", float4(1.0f, 1.0f, 1.0f,1.0f));\n        defineParam(topscale, \"topscale\", float4(1.0f, 1.0f, 1.0f,1.0f));        \n  \}\n\nfloat octave_noise_4d( const float octaves, const float persistence, const float scale, const float x, const float y, const float z, const float w ) \n\{\n    float total = 0.0f;\n    float current;\n    float last = 1.0f;\n    float frequency = scale;\n    float amplitude = 1.0f;\n    float maxAmplitude = 0.0f;\n    float4 Tempoffset;\n    float4 Tempscale;\n\n\n    for( int i=0; i < octaves; i++ ) \{\n\n        /*\n        if (i == 0) \{\n            total += (float)raw_noise_4d( (x+suboffset.x) * frequency, (y+suboffset.y) * frequency, (z+suboffset.z) * frequency, (w+suboffset.w) * frequency ) * amplitude;\n        \}\n        else if (i == octaves-1) \{\n            total += (float)raw_noise_4d( (x+topoffset.x) * frequency, (y+topoffset.y) * frequency, (z+topoffset.z) * frequency, (w+topoffset.w) * frequency ) * amplitude;\n        \}\n        else \{\n            total += (float)raw_noise_4d( x * frequency, y * frequency, z * frequency, w * frequency ) * amplitude;\n        \}\n        */\n\n\n        Tempscale = (topscale * (i/(octaves-1.0f)))+(subscale * (1-(i/(octaves-1.0f))));       \n        Tempoffset = (topoffset * (i/(octaves-1.0f)))+(suboffset * (1-(i/(octaves-1.0f))));\n        current = (float)raw_noise_4d(   ((x*Tempscale.x)+Tempoffset.x) * frequency, \n                                        ((y*Tempscale.y)+Tempoffset.y) * frequency, \n                                        ((z*Tempscale.z)+Tempoffset.z) * frequency, \n                                        ((w*Tempscale.w)+Tempoffset.w) * frequency \n                                        ) * amplitude;\n        if (i == 0 && curveNoise)\{\n            if (curveInvert)\{\n                last = 0.5f-current;  \n            \}\n            else\{\n                last = current;  \n            \}\n               \n        \}\n        current = curveNoise?current*((last+curveOffset)*curveGain):current;\n        total += absNoise?fabs(current):current;\n        frequency *= 2.0f;\n        maxAmplitude += amplitude;\n        amplitude *= persistence;\n\n    \}\n    return float(total / maxAmplitude);\n\}\n\n\n\n\n  void process() \{\n    float4 srcSample = float4(src(0),src(1),src(2),src(3));\n    float sampleR,sampleG,sampleB;\n    for( int i=0; i < itterations; i++ ) \{\n        sampleR = (float)octave_noise_4d(float(octaves), gain, lacunarity, ( srcSample.x * scale.x ) + offset.x, ( srcSample.y * scale.y ) + offset.y,  ( srcSample.z * scale.z ) + offset.z, ( srcSample.w * scale.w ) + offset.w) * amplitude.x;\n        sampleG = (float)octave_noise_4d(float(octaves), gain, lacunarity, ( srcSample.x * scale.x ) + offset.x, ( srcSample.y * scale.y ) + offset.y,  ( srcSample.z * scale.z ) + offset.z, ( srcSample.w * scale.w ) + offset.w - 100.0f) * amplitude.y;\n        sampleB = (float)octave_noise_4d(float(octaves), gain, lacunarity, ( srcSample.x * scale.x ) + offset.x, ( srcSample.y * scale.y ) + offset.y,  ( srcSample.z * scale.z ) + offset.z, ( srcSample.w * scale.w ) + offset.w + 200.0f) * amplitude.z;\n        srcSample = float4(srcSample.x+sampleR,srcSample.y+sampleG,srcSample.z+sampleB,srcSample.w);\n    \}\n    dst() = float4(srcSample.x,srcSample.y,srcSample.z,1.0f);\n\}\n\};"
  rebuild ""
  Noise4D_curveNoise {{parent.CurveNoise_Enable}}
  Noise4D_curveInvert {{parent.CurveNoise_Invert}}
  Noise4D_curveGain {{parent.CurveGain}}
  Noise4D_curveOffset {{parent.CurveOffset}}
  Noise4D_Octaves {{parent.Noise_Octaves}}
  Noise4D_Gain {{parent.Noise_Gain}}
  Noise4D_Lacunarity {{parent.Noise_Lacunarity}}
  Noise4D_Gamma 0.79
  Noise4D_amplitude {{parent.Amplitude.r} {parent.Amplitude.g} {parent.Amplitude.b}}
  Noise4D_itterations {{parent.Itterations}}
  Noise4D_Offset {{parent.Freq_Offset} {parent.Freq_Offset} {parent.Freq_Offset} {parent.Freq_Offset}}
  Noise4D_Scale {{parent.Freq_GeneralScale} {parent.Freq_GeneralScale} {parent.Freq_GeneralScale} {parent.Freq_GeneralScale}}
  Noise4D_suboffset {{(frame*parent.Freq_EvolveLow.r)/50} {(frame*parent.Freq_EvolveLow.g)/50} {(frame*parent.Freq_EvolveLow.b)/50} {(frame*parent.Freq_EvolveLow.a)/50}}
  Noise4D_topoffset {{(frame*parent.Freq_EvolveHigh.r)/10} {(frame*parent.Freq_EvolveHigh.g)/10} {(frame*parent.Freq_EvolveHigh.b)/10} {(frame*parent.Freq_EvolveHigh.a)/10}}
  Noise4D_subscale {{parent.Freq_ScaleLow} {parent.Freq_ScaleLow} {parent.Freq_ScaleLow} {parent.Freq_ScaleLow}}
  Noise4D_topscale {{parent.Freq_ScaleHigh} {parent.Freq_ScaleHigh} {parent.Freq_ScaleHigh} {parent.Freq_ScaleHigh}}
  rebuild_finalise ""
  name Noise4D1
  xpos -470
  ypos 267
 }
 Switch {
  inputs 2
  which {{parent.EnableOffset}}
  name Switch1
  xpos -470
  ypos 325
 }
 Expression {
  expr0 abs(r)
  expr1 abs(g)
  expr2 abs(b)
  name Expression2
  xpos -470
  ypos 349
  disable {{!parent.Noise_Absolute}}
 }
 Shuffle {
  out pos
  name Shuffle2
  xpos -470
  ypos 420
 }
push $N455dbb50
 Merge2 {
  inputs 2+1
  operation copy
  bbox B
  Achannels {pos.red pos.green pos.blue -pos.alpha}
  Bchannels {pos.red pos.green pos.blue -pos.alpha}
  output {pos.red pos.green pos.blue -pos.alpha}
  maskChannelMask -rgba.alpha
  name Merge1
  xpos -582
  ypos 416
 }
 Output {
  name Output1
  xpos -582
  ypos 587
 }
push $N455dbb50
 Crop {
  box {0 0 {width} {height}}
  reformat true
  crop false
  name InputFormat
  xpos -713
  ypos 111
 }
 StickyNote {
  inputs 0
  name StickyNote1
  label "These two noise scripts are alsmost identical.\nThe problem is that adding 1 extra input does eat up a lot of performence,\nso when we don't need the input we should avoid using it."
  xpos -239
  ypos 269
 }
end_group
Group {
 inputs 2
 name Point_Render13
 tile_color 0x434343ff
 note_font_color 0x7dadf9ff
 selected true
 xpos 14744
 ypos 33233
 addUserKnob {20 User l "Point Render" t dd}
 addUserKnob {26 info_header l "" +STARTLINE T "Point Render v1.0"}
 addUserKnob {26 devider_general l "<b><font color=#7DADF9>General</font><b>"}
 addUserKnob {4 RenderMode l "Render Mode" t "Some generators support multiple render modes other than just point rendering. This should be considered a experimental feature, but can be used to great effect.\n\nIn the Render Settings tab you can find more controls relating to Wire and Facet rendering modes.\n\nNote that Facet Render can be slow when really close to a object. " M {"Point Render" "Wire Render" "Facet Render (experimental)" "" "" ""}}
 RenderMode "Wire Render"
 addUserKnob {7 FocalLength l "Focal Length" t "The point render does not take the focal length from the input camera, so if you want to match it to a camera you should link the focal length from the camera to this." R 0 200}
 FocalLength 50
 addUserKnob {7 horizontalApeture l "Horiz Apeture" R 0 100}
 horizontalApeture 24.576
 addUserKnob {7 AlphaMultiplier l Exposure t "This is a general exposure modifier that lets you adjust the overall brightness of the render." R 0 2}
 AlphaMultiplier 0.15
 addUserKnob {6 UseOcclusionMap l "Use Occlusion Map" t "Enable the Occlusion map input. This lets you use a depth map as a holdout.\n\nNote:\nThe Red channal should contain the depth (absolute distance, not 1/depth)\nThe Alpha channal must be 1 for the areas that you want to holdout." +STARTLINE}
 addUserKnob {26 devider_cc l "<b><font color=#7DADF9>Preview</font><b>"}
 addUserKnob {6 FastPreview l "Fast Preview" t "Reduce the number of points for a quick preview of the final render." +STARTLINE}
 addUserKnob {6 HighlightCompression l "Hilight Compression" t "Compresses the highlights to make it easier to see bright details." +STARTLINE}
 addUserKnob {7 HighlightCeiling l "Highlight Ceiling" t "Adjust the cealing for the highlight compression." R 1 10}
 HighlightCeiling 1.15
 addUserKnob {7 Compression t "The compression amount." -STARTLINE R 0 5}
 Compression 1
 addUserKnob {26 devider_format l "<b><font color=#7DADF9>Format</font><b>"}
 addUserKnob {41 format l "output format" T Settings_Format.format}
 addUserKnob {20 WireRender l "Render Settings"}
 addUserKnob {26 devider_wirerender l "<b><font color=#7DADF9>Wire Rendering</font><b>"}
 addUserKnob {4 wire_type l "Connection Mode" t "*Normal\nConnect lines between the local neigbours of the 2d position map\n\n*Nearest\nConnect lines to the nearest points (in 3D space). This mode is limited to 100x100 points for performence reasons!" M {Normal Nearest "" "" "" "" "" "" "" ""}}
 addUserKnob {26 text l "Normal Mode Wires" T " "}
 addUserKnob {6 connect_x l x t "Connect wires in the (uv) X axis." -STARTLINE}
 connect_x true
 addUserKnob {6 connect_xy l xy t "Connect wires in the (uv) XY axis." -STARTLINE}
 connect_xy true
 addUserKnob {6 connect_y l y t "Connect wires in the (uv) Y axis." -STARTLINE}
 connect_y true
 addUserKnob {6 connect_aux l aux t "If you input a vector map into the Aux input for this node, and enable this option, you will get a wire from each point along that vector." -STARTLINE}
 addUserKnob {7 wire_maxdistance l "Max Distance" t "The maximum distance that the wires connect." R 0 10}
 wire_maxdistance 2.9
 addUserKnob {7 wire_Threshold l "Distance Threshold" t "Control the max distance threshold" R 0 2}
 wire_Threshold 0.5
 addUserKnob {3 wire_connections l "Max Connections" t "The maximum number of connections (Not Yet Implemented)"}
 wire_connections 2
 addUserKnob {7 maxSamples l "Max Line Samples" t "The maximum length of a line. Once a line is longer than this, it will start break up. \nThis can also be used as a creative effect if you set it low, try setting it to 10 in wire mode to get dotted lines" R 0 10000}
 maxSamples 10000
 addUserKnob {7 lineoffset l "Line Offset" t "Expand or contract the lines."}
 lineoffset 5
 addUserKnob {7 inGain l "In Gain" t "Gain the brightness of the in-point of the lines"}
 inGain 1
 addUserKnob {7 outGain l "Out Gain" t "Gain the brightness of the out-point of the lines" -STARTLINE}
 outGain 1
 addUserKnob {26 devider_facet l "<b><font color=#7DADF9>Facet Rendering</font><b>"}
 addUserKnob {4 renderMode l "Render Mode" t "Pick the desidered render mode." M {Diffuse "Local ST" Normal "Facing Ratio" UV ST "View Normal" "World Position" "" ""}}
 addUserKnob {6 facet_flatShading l "Flat Shading" t "Flat shading" +STARTLINE}
 addUserKnob {6 facet_depth l "Depth Buffer" t "Enable depth sorting to avoid additive surfaces." -STARTLINE}
 addUserKnob {6 facet_front l "Front Face" t "Render front facing facets" +STARTLINE}
 facet_front true
 addUserKnob {6 facet_backface l "Back Face" t "Render backfacing faces" -STARTLINE}
 facet_backface true
 addUserKnob {26 _1 l "<b><font color=#7DADF9>Other</font><b>"}
 addUserKnob {6 CloseX l "Close X" t "On spheres or round objects this closes the loop" +STARTLINE}
 addUserKnob {6 CloseY l "Close Y" t "On spheres or round objects this closes the loop" -STARTLINE}
 addUserKnob {20 Fog_1 l Fog}
 addUserKnob {26 Devider_Fog l "<b><font color=#7DADF9>Fog</font><b>"}
 addUserKnob {6 Fog t "Fog reduces the brightness of poins far from the camera." +STARTLINE}
 addUserKnob {7 FogNear l "Fog Near" R 0 200}
 FogNear 6
 addUserKnob {7 FogFar l "Fog Far" R 0 200}
 FogFar 29.5
 addUserKnob {7 FogExponent l "Fog Exponent" R 0 8}
 FogExponent 8
 addUserKnob {20 DepthOfField l "Depth of Field"}
 addUserKnob {26 devider_dof l "<b><font color=#7DADF9>Depth Of Field</font><b>"}
 addUserKnob {6 dof_enable l Enable +STARTLINE}
 addUserKnob {7 dof_focaldepth l "Focal Depth" R 0 40}
 dof_focaldepth 5
 addUserKnob {7 dof_dof l "Depth of Field" R 0 10}
 dof_dof 2
 addUserKnob {7 dof_maxSize l "Max Size"}
 dof_maxSize 0.5
 addUserKnob {7 dof_Aspect l "Aspect Ratio"}
 dof_Aspect 1
 addUserKnob {7 dof_bias l Bias R -3 3}
 dof_bias -0.2
 addUserKnob {4 Dof_Quality l Quality M {Low Medium High Extreme}}
 addUserKnob {20 MotionBlur}
 addUserKnob {26 devider_MotionBlur l "<b><font color=#7DADF9>Motion Blur</font><b>"}
 addUserKnob {6 mb_enable l Enable +STARTLINE}
 addUserKnob {6 Fast l "Fast (Interpolated)" -STARTLINE}
 Fast true
 addUserKnob {3 Samples}
 Samples 6
 addUserKnob {7 Shutter R 0 2}
 Shutter 0.5
 addUserKnob {4 pulldown l "Shutter Offset" M {Centered Start End ""}}
 addUserKnob {20 preview_3d l "3D Preview"}
 addUserKnob {6 Enable3DPreview l "Enable 3D Preview" t "Display a preview of the points in the Nuke 3D view." +STARTLINE}
 addUserKnob {41 pointSize l "point size" T PreviewNode.pointSize}
 addUserKnob {41 detail l "point detail" T PreviewNode.detail}
}
 BackdropNode {
  inputs 0
  name BackdropNode1
  tile_color 0x388e8e00
  label "Output Format Manager"
  note_font_size 22
  xpos -1491
  ypos 149
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode10
  tile_color 0x388e8e00
  label "AUX Input"
  note_font_size 22
  xpos -385
  ypos 178
  bdwidth 207
  bdheight 178
 }
 BackdropNode {
  inputs 0
  name BackdropNode11
  tile_color 0x388e8e00
  label "Point Render"
  note_font_size 22
  xpos -96
  ypos 99
  bdwidth 198
  bdheight 135
 }
 BackdropNode {
  inputs 0
  name BackdropNode12
  tile_color 0x388e8e00
  label "Normal Generator\nFor Vertex Normals"
  note_font_size 22
  xpos -616
  ypos 243
  bdwidth 191
  bdheight 122
 }
 BackdropNode {
  inputs 0
  name BackdropNode13
  tile_color 0x388e8e00
  label "Ensure output format"
  note_font_size 22
  xpos -622
  ypos -41
  bdwidth 198
  bdheight 135
 }
 BackdropNode {
  inputs 0
  name BackdropNode14
  tile_color 0x388e8e00
  label "Motion Blur"
  note_font_size 22
  xpos -85
  ypos 526
  bdwidth 193
  bdheight 91
 }
 BackdropNode {
  inputs 0
  name BackdropNode15
  tile_color 0x388e8e00
  label "Soft Preview"
  note_font_size 22
  xpos -83
  ypos 414
  bdwidth 191
  bdheight 94
 }
 BackdropNode {
  inputs 0
  name BackdropNode16
  tile_color 0x388e8e00
  label "Final format"
  note_font_size 22
  xpos -84
  ypos 295
  bdwidth 192
  bdheight 95
 }
 BackdropNode {
  inputs 0
  name BackdropNode17
  tile_color 0x388e8e00
  label "No Clue =)"
  note_font_size 22
  xpos -385
  ypos -41
  bdwidth 160
  bdheight 87
 }
 BackdropNode {
  inputs 0
  name BackdropNode2
  tile_color 0x388e8e00
  label Motionblur
  note_font_size 22
  xpos -672
  ypos -781
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode3
  tile_color 0x388e8e00
  label "Fast Preview"
  note_font_size 22
  xpos -669
  ypos -971
  bdwidth 254
  bdheight 138
 }
 BackdropNode {
  inputs 0
  name BackdropNode4
  tile_color 0x388e8e00
  label "Nearest Wire Mode Clamp"
  note_font_size 22
  xpos -666
  ypos -1184
  bdwidth 253
  bdheight 111
 }
 BackdropNode {
  inputs 0
  name BackdropNode5
  tile_color 0x388e8e00
  label Occlution
  note_font_size 22
  xpos 208
  ypos 27
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode6
  tile_color 0x388e8e00
  label "Input Camera Container"
  note_font_size 22
  xpos -1215
  ypos 148
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode7
  tile_color 0x388e8e00
  label "3D Preview"
  note_font_size 22
  xpos -88
  ypos -45
  bdwidth 207
  bdheight 102
 }
 BackdropNode {
  inputs 0
  name BackdropNode8
  tile_color 0x388e8e00
  label "Input Format Manager"
  note_font_size 22
  xpos -526
  ypos -459
  bdwidth 208
  bdheight 97
 }
 BackdropNode {
  inputs 0
  name BackdropNode9
  tile_color 0x388e8e00
  label FOG
  note_font_size 22
  xpos -602
  ypos -253
  bdwidth 370
  bdheight 152
 }
 Input {
  inputs 0
  name InputPointData
  xpos -584
  ypos -1321
 }
 Dot {
  name Dot4
  xpos -550
  ypos -1234
 }
set N4530a010 [stack 0]
 Reformat {
  type "to box"
  box_width 100
  box_height 100
  box_fixed true
  scale 0.1
  resize fill
  filter impulse
  black_outside true
  name Reformat5
  xpos -584
  ypos -906
  disable {{!parent.FastPreview==1}}
 }
 Grade {
  white 10
  name Grade2
  xpos -584
  ypos -874
  disable {{!parent.FastPreview}}
 }
 Dot {
  name Dot2
  xpos -550
  ypos -712
 }
set N4532f470 [stack 0]
 Group {
  name FrameHold3
  tile_color 0xb0a45dff
  label "(frame \[value first_frames])"
  xpos -501
  ypos -719
  disable {{1-parent.mb_enable}}
  addUserKnob {20 User}
  addUserKnob {3 first_frames l "first frame"}
  first_frames {{frame+1}}
  addUserKnob {41 increment T FrameHold2.increment}
  addUserKnob {22 SetCurrentFrame l "Set This Frame" T "nuke.thisNode()\[\"first_frames\"].setValue(nuke.frame())" +STARTLINE}
 }
  Input {
   inputs 0
   name Input1
   xpos -7
   ypos -154
  }
  FrameHold {
   first_frame {{parent.knob.first_frames}}
   name FrameHold2
   xpos -7
   ypos -114
  }
  Output {
   name Output1
   xpos -7
   ypos -14
  }
 end_group
 Dot {
  name Dot6
  xpos -467
  ypos -659
 }
push $N4532f470
 Group {
  name FrameHold2
  tile_color 0xb0a45dff
  label "(frame \[value first_frames])"
  xpos -660
  ypos -719
  disable {{1-parent.mb_enable}}
  addUserKnob {20 User}
  addUserKnob {3 first_frames l "first frame"}
  first_frames {{frame}}
  addUserKnob {41 increment T FrameHold2.increment}
  addUserKnob {22 SetCurrentFrame l "Set This Frame" T "nuke.thisNode()\[\"first_frames\"].setValue(nuke.frame())" +STARTLINE}
 }
  Input {
   inputs 0
   name Input1
   xpos -7
   ypos -154
  }
  FrameHold {
   first_frame {{parent.knob.first_frames}}
   name FrameHold2
   xpos -7
   ypos -114
  }
  Output {
   name Output1
   xpos -7
   ypos -14
  }
 end_group
 Dot {
  name Dot5
  xpos -626
  ypos -659
 }
 Dissolve {
  inputs 2
  which {{frame-floor(frame)}}
  name Dissolve1
  xpos -582
  ypos -666
  disable {{1-parent.mb_enable}}
 }
push $N4532f470
 Switch {
  inputs 2
  which {{parent.Fast}}
  name Switch2
  xpos -582
  ypos -619
 }
 Dot {
  name DataFetch
  label "data fetch\t"
  note_font_color 0xff21ff
  xpos -550
  ypos -513
  addUserKnob {20 User}
  addUserKnob {3 n_particles l "Number of Particles"}
  n_particles {{"\[metadata pointrender/n_points]"}}
  addUserKnob {3 gentype l "Type Of Generator"}
  gentype {{"\[metadata pointrender/gen_type]"}}
  addUserKnob {26 info l "" -STARTLINE T "0 = unknown, 1 = Card, 2 = Sphere, 3 = Grid"}
 }
set N4538b110 [stack 0]
 Dot {
  name Dot3
  xpos -635
  ypos -513
 }
 Dot {
  name Dot1
  xpos -635
  ypos 676
 }
 Input {
  inputs 0
  name InputOcclution
  xpos 238
  ypos 75
  number 2
 }
 Constant {
  inputs 0
  channels rgb
  color 1
  name Empty
  xpos 371
  ypos 139
 }
 Switch {
  inputs 2
  which {{parent.UseOcclusionMap}}
  name Switch1
  xpos 238
  ypos 163
 }
 Input {
  inputs 0
  name Aux
  xpos -324
  ypos 214
  number 3
 }
 Reformat {
  type "to box"
  format "1280 720 0 0 1280 720 1 HD_720"
  box_width {{input.width>Settings_Format.format.width?input.width:Settings_Format.format.width}}
  box_height {{input.height>Settings_Format.format.height?input.height:Settings_Format.format.height}}
  box_fixed true
  resize none
  center false
  filter impulse
  black_outside true
  name Reformat2
  xpos -324
  ypos 238
 }
 Crop {
  box {0 0 {input.width} {input.height}}
  name Crop1
  xpos -324
  ypos 275
 }
push $N4538b110
 Shuffle {
  in pos
  name Shuffle1
  xpos -584
  ypos -192
 }
set N453d0230 [stack 0]
 Reformat {
  type "to box"
  format "1280 720 0 0 1280 720 1 HD_720"
  box_width {{input.width>Settings_Format.format.width?input.width:Settings_Format.format.width}}
  box_height {{input.height>Settings_Format.format.height?input.height:Settings_Format.format.height}}
  box_fixed true
  resize none
  center false
  filter impulse
  black_outside true
  name Reformat4
  xpos -584
  ypos 18
 }
 Crop {
  box {0 0 {input.width} {input.height}}
  name Crop2
  xpos -584
  ypos 48
 }
 Dot {
  name Dot8
  xpos -550
  ypos 166
 }
set N451fb190 [stack 0]
 Group {
  name Point_Normal2
  tile_color 0x434343ff
  note_font_color 0x55ffffff
  xpos -584
  ypos 311
  disable {{!(renderMode==2&&RenderMode==2)}}
  addUserKnob {20 User}
  addUserKnob {26 info l "" +STARTLINE T "Point Normal v1.0"}
  addUserKnob {26 devider_general l "<b><font color=#7DADF9>General</font><b>"}
  addUserKnob {26 info_1 l "" +STARTLINE T "well, not much to do here =)"}
 }
  Input {
   inputs 0
   name Input1
   xpos 389
   ypos 207
  }
  Shuffle {
   in pos
   name Shuffle1
   xpos 389
   ypos 294
  }
  BlinkScript {
   kernelSourceFile /Users/madshagbarth/Github/Nuke-Private/Blink/PointRender/Modify/BasicLight.cpp
   recompileCount 69
   ProgramGroup 1
   KernelDescription "2 \"PointRender3D\" iterate pixelWise d5452fe7b684561fcfa5182d0c789025a037cc4fe4474c24e065e3fa53fcd8ce 2 \"ppos\" Read Random \"dst\" Write Point 9 \"cam_Matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== \"focallength\" Float 1 AAA4QQ== \"hapeture\" Float 1 ppvEQQ== \"format\" Int 2 AAgAAAAIAAA= \"Zoom\" Float 1 AACAPw== \"half Lambert\" Bool 1 AQ== \"light Mode\" Int 1 AAAAAA== \"light_position\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"light_color\" Float 3 AACAPwAAgD8AAIA/AAAAAA== 9 \"cam_Matrix\" 16 1 \"cam_Focal\" 1 1 \"cam_Hapeture\" 1 1 \"WHformat\" 2 1 \"zoom\" 1 1 \"halfLambert\" 1 1 \"lightMode\" 1 1 \"lightPos\" 3 1 \"lightcolor\" 3 1 10 \"vRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"pRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"tRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"vWorld\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"canvasWidth\" Float 1 1 AAAAAA== \"canvasHeight\" Float 1 1 AAAAAA== \"matrixData\" Float 1 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cameraToWorld\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"worldToCamera\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"namount\" Float 1 1 AAAAAA=="
   kernelSource "inline float Frac(float a_X)\n\{\n    return a_X-floor(a_X);\n\}\n\ninline float Fmax(float a_X,float b_X,float c_X)\n\{\n    return max(c_X,max(a_X,b_X));\n\}\ninline float Fmin(float a_X,float b_X,float c_X)\n\{\n    return min(c_X,min(a_X,b_X));\n\}\n\ninline float saturate(float _in)\n\{\n    return max(0.0f,min(1.0f,_in));\n\}\n\ninline float3 reflect(float3 incidence,float3 normal)\n\{\n  return incidence - 2.f * dot(incidence, normal) * normal;\n\}\n\n//This function is used to multiply a float3 by a matrix4x4\ninline float3 multVecMatrix( float3 src, float4x4 matrix)\n\{\n    float   x,y,z,w;\n    \n    x = src\[0]*matrix\[0]\[0] + src\[1]*matrix\[1]\[0] +\n    src\[2]*matrix\[2]\[0] + matrix\[3]\[0];\n    y = src\[0]*matrix\[0]\[1] + src\[1]*matrix\[1]\[1] +\n    src\[2]*matrix\[2]\[1] + matrix\[3]\[1];\n    z = src\[0]*matrix\[0]\[2] + src\[1]*matrix\[1]\[2] +\n    src\[2]*matrix\[2]\[2] + matrix\[3]\[2];\n    w = src\[0]*matrix\[0]\[3] + src\[1]*matrix\[1]\[3] +\n    src\[2]*matrix\[2]\[3] + matrix\[3]\[3];\n    \n    return float3(x/w, y/w, z/w);\n\}\n\n//This function is used to calculate the screenspace coordinates.\ninline bool computePixelCoordinates( \n    const float3 pWorld, \n    float3 &pRaster, \n    const float4x4 &worldToCamera, \n    const float &canvasWidth, \n    const float &canvasHeight, \n    const int &imageWidth, \n    const int &imageHeight\n) \n\{ \n    float3 pCamera; \n    pCamera = multVecMatrix(pWorld, worldToCamera); \n    float2 pScreen; \n    pScreen.x = pCamera.x / -pCamera.z; \n    pScreen.y = pCamera.y / -pCamera.z; \n    if (fabs(pScreen.x) > canvasWidth || fabs(pScreen.y) > canvasHeight) \n         return false; \n    float2 pNDC; \n    pNDC.x = (pScreen.x + canvasWidth * 0.5f) / canvasWidth; \n    pNDC.y = (pScreen.y + canvasHeight * 0.5f) / canvasHeight; \n    pRaster.x = (pNDC.x * imageWidth); \n    pRaster.y = ((pNDC.y) * imageHeight); \n    pRaster.z = -pCamera.z; \n    if (pRaster.x < 0.0f || pRaster.x > imageWidth || \n       pRaster.y < 0.0f || pRaster.y > imageHeight) \{\n       return false;  \n    \}\n    return true;\n\} \n\n\n\nkernel PointRender3D : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessRandom, eEdgeClamped> ppos;    //The point position map\n  Image<eWrite> dst;                 //the output image\n\n  param: //Parameters available to the user\n    float4x4 cam_Matrix;    //The world matrix of the camera\n    float cam_Focal;        //The focal length of the camera\n    float cam_Hapeture;     //The horizontal apeture of the camera\n    int2 WHformat;          //The format of the output image\n    float zoom;             //A \"post\" zoom function\n    bool halfLambert;\n    int lightMode;\n    float3 lightPos;\n    float3 lightcolor;\n\n\n  local: //Local variables\n    float3 vRaster;\n    float3 pRaster;\n    float3 tRaster;    \n    float3 vWorld;\n    float canvasWidth;\n    float canvasHeight; \n    float matrixData\[4]\[4];\n    float4x4 cameraToWorld;\n    float4x4 worldToCamera;\n    float namount; //dither amount\n\n\n  void define() \{\n    defineParam(cam_Matrix, \"cam_Matrix\", float4x4( 1.0f,0.0f,0.0f,0.0f,\n                                                    0.0f,1.0f,0.0f,0.0f,\n                                                    0.0f,0.0f,1.0f,0.0f,\n                                                    0.0f,0.0f,0.0f,1.0f));\n    defineParam(cam_Focal,      \"focallength\", 11.5f);\n    defineParam(cam_Hapeture,      \"hapeture\", 24.576f);\n    defineParam(WHformat,      \"format\", int2(2048,2048));\n    defineParam(zoom, \"Zoom\", 1.0f);\n    defineParam(halfLambert, \"half Lambert\", true);\n    defineParam(lightMode, \"light Mode\", 0);\n    defineParam(lightPos,      \"light_position\", float3(0,0,0));  \n    defineParam(lightcolor,      \"light_color\", float3(1.0,1.0,1.0)); \n  \}\n\n\n  //The init() function is run before any calls to process().\n  void init() \{\n    canvasWidth = ((cam_Hapeture)/cam_Focal);\n    canvasHeight = ((cam_Hapeture)/cam_Focal)*float(float(WHformat.y)/float(WHformat.x)); \n    float matrixData\[] = \{cam_Matrix\[0]\[0], cam_Matrix\[1]\[0], cam_Matrix\[2]\[0], cam_Matrix\[3]\[0], \n                          cam_Matrix\[0]\[1], cam_Matrix\[1]\[1], cam_Matrix\[2]\[1], cam_Matrix\[3]\[1], \n                          cam_Matrix\[0]\[2], cam_Matrix\[1]\[2], cam_Matrix\[2]\[2], cam_Matrix\[3]\[2], \n                          cam_Matrix\[0]\[3], cam_Matrix\[1]\[3], cam_Matrix\[2]\[3], cam_Matrix\[3]\[3]\};\n    cameraToWorld.setArray(matrixData); //This is a workaround. Due to the buggy matrix implementation, we pass the matrix on from another structure.\n    worldToCamera = cameraToWorld.invert();\n    namount = 0.0001; //dither amount\n  \}\n\n\n\nfloat3 Reconsile3D(float3 _PointPos)\{\n    vWorld = float3(_PointPos.x,_PointPos.y,_PointPos.z)*(zoom);\n    int ret = computePixelCoordinates(vWorld, tRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1]);\n    return tRaster;\n\}\n\n\n\n//-------------------------------------\n// Facet_Render\n//-------------------------------------\n//This function is used to calculate what triangels to draw\nfloat3 facet_render(int2 pos, float3 _vWorld)\{\n\n    float3 screen_pos = Reconsile3D(_vWorld);\n    bool insideX = ppos.bounds.inside(pos.x+1,pos.y );\n    bool insideY = ppos.bounds.inside(pos.x,pos.y-1 );\n    bool insideYtop = ppos.bounds.inside(pos.x,pos.y+1);\n    float2 fpos = float2(pos.x,pos.y);\n    float3 V1_Pos,V2_Pos,V1_wPos,V2_wPos;\n    float4 V0_Sample,V1_Sample,V2_Sample;\n    float3 normal0,normal1,normal2;\n\n    //for area calculation\n    float area;\n    float3 V0,V1,V2;\n    float3 output = float3(0.0f);\n  if (insideX) \{\n    V2_Sample = ppos(pos.x+1,pos.y);\n    V2_wPos = float3(V2_Sample.x,V2_Sample.y,V2_Sample.z);\n    V2_Pos = Reconsile3D(V2_wPos);\n    if (V2_Sample.w != 0.0f) \{ \n\n      if (insideY) \{\n        V1_Sample = ppos(pos.x+1,pos.y-1);\n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (V1_Sample.w != 0.0f) \{ \n            float3 Normal = CalculateVertexNormals(_vWorld,V2_wPos,V1_wPos);\n\n            //Calculate Area for density:\n            V0 = screen_pos;\n            V1 = V1_Pos;\n            V2 = V2_Pos;\n            V0.z = 1.0f / V0.z, V1.z = 1.0f / V1.z, V2.z = 1.0f / V2.z; \n            area = length(V0-V1)+length(V0-V2)+length(V1-V2);\n\n          //write output\n          output +=  float3(Normal.x,Normal.y,Normal.z);\n        \}\n      \}\n      if (insideYtop) \{\n        V1_Sample = ppos(pos.x,pos.y+1);\n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (V1_Sample.w != 0.0f) \{ \n          float3 Normal = CalculateVertexNormals(_vWorld,V1_wPos,V2_wPos);\n\n            //Calculate Area for density:\n            V0 = screen_pos;\n            V1 = V1_Pos;\n            V2 = V2_Pos;\n            V0.z = 1.0f / V0.z, V1.z = 1.0f / V1.z, V2.z = 1.0f / V2.z; \n            area = length(V0-V1)+length(V0-V2)+length(V1-V2);\n\n          output += float3(Normal.x,Normal.y,Normal.z);\n\n        \}\n      \}\n    \}\n  \}\n  return output;\n\}\n\n\n\nfloat3 CalculateSurfaceNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat3 CalculateVertexNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 hitNormal = cross((V1 - V0),(V2 - V0)); \n        return hitNormal;\n\}\n\n\n\n//-------------------------------------\n// Process\n//-------------------------------------\n  void process(int2 pos) \{\n    float3 output = float3(0.0f);\n    float4 _sample = ppos(pos.x,pos.y); //Get the XYZ Coordinates\n    float3 point_pos = float3(_sample.x,_sample.y,_sample.z);\n    if (_sample.w != 0.0f) \{  //No need to process if there is no data.\n      dst() = float4(0.0f);\n      output+=facet_render(pos,float3(_sample.x,_sample.y,_sample.z))*2.0f;\n      _sample = ppos(pos.x-1,pos.y); //Get the XYZ Coordinates\n      output+=facet_render(int2(pos.x-1,pos.y),float3(_sample.x,_sample.y,_sample.z));\n\n      _sample = ppos(pos.x-1,pos.y+1); //Get the XYZ Coordinates\n      output+=facet_render(int2(pos.x-1,pos.y+1),float3(_sample.x,_sample.y,_sample.z));\n\n      _sample = ppos(pos.x,pos.y-1); //Get the XYZ Coordinates\n      output+=facet_render(int2(pos.x,pos.y-1),float3(_sample.x,_sample.y,_sample.z));\n\n      output = normalize(output);\n      float3 normal = -output;\n\n      \n\n\n      dst() = float4(normal.x,normal.y,normal.z,1.0f);\n    \}\n  \} //----> process\n\};\n"
   rebuild ""
   "PointRender3D_half Lambert" false
   "PointRender3D_light Mode" {{parent.LightFalloff}}
   PointRender3D_light_position {{parent.Axis1.translate} {parent.Axis1.translate} {parent.Axis1.translate}}
   PointRender3D_light_color {{parent.LightColor} {parent.LightColor} {parent.LightColor}}
   rebuild_finalise ""
   name BlinkScript1
   xpos 389
   ypos 344
  }
  Grade {
   multiply 0.5
   add 0.5
   black_clamp false
   name Grade1
   xpos 389
   ypos 376
   disable true
  }
  Output {
   name Output1
   xpos 389
   ypos 459
  }
  Axis2 {
   inputs 0
   translate {0.5 0.5 0.5}
   name Axis1
   xpos 661
   ypos 318
   addUserKnob {20 Ivy}
   addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.toolbox.v1.nodes.docs', fromlist=\['open_docs_name']).open_docs_name('IvyTab')" +STARTLINE}
   addUserKnob {26 divider4 l "" +STARTLINE}
   addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
   _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
   addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
   addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
   addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
   _expressions {{curve}}
   addUserKnob {26 divider0 l "" +STARTLINE}
   addUserKnob {20 dbinfo l "DB Info" n 1}
   dbinfo 0
   addUserKnob {1 twig_dnuuid l "Twig Id"}
   addUserKnob {1 stalk_dnuuid l "Stalk Id"}
   addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
   addUserKnob {1 leaf_dnuuid l "Leaf Id"}
   addUserKnob {26 divider1 l "" +STARTLINE}
   addUserKnob {1 twigtype l "Twig Type"}
   addUserKnob {1 leaf_label l Leaf}
   addUserKnob {1 ivy_version l Version}
   addUserKnob {43 ivy_notes l Notes}
   addUserKnob {26 divider2 l "" +STARTLINE}
   addUserKnob {1 build_label l "Build Label"}
   addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
  }
 end_group
 Switch {
  inputs 2
  which {{parent.connect_aux}}
  name Switch3
  xpos -324
  ypos 311
 }
push $N453d0230
 Expression {
  temp_name0 xd
  temp_expr0 red-Camera1.world_matrix.3
  temp_name1 yd
  temp_expr1 green-Camera1.world_matrix.7
  temp_name2 zd
  temp_expr2 blue-Camera1.world_matrix.11
  temp_name3 Distance
  temp_expr3 "sqrt(xd*xd + yd*yd + zd*zd)"
  expr0 Distance
  expr1 Distance
  expr2 Distance
  expr3 Distance
  name Expression1
  xpos -456
  ypos -192
 }
 Grade {
  channels rgba
  blackpoint {{parent.FogFar}}
  whitepoint {{parent.FogNear}}
  gamma {{1/(parent.FogExponent+0.000000001)}}
  white_clamp true
  name Grade1
  xpos -456
  ypos -168
 }
push $N4538b110
 Dot {
  name Dot7
  xpos -307
  ypos -513
 }
 Merge2 {
  inputs 2
  operation multiply
  name Merge1
  xpos -341
  ypos -168
  disable {{!parent.Fog}}
 }
 Shuffle {
  name Shuffle3
  xpos -341
  ypos 8
 }
set N452b1580 [stack 0]
push $N451fb190
 BlinkScript {
  inputs 4
  kernelSourceFile /Users/madshagbarth/Github/Nuke-Private/Blink/PointRender/Render/3D_PointRender_v15.cpp
  recompileCount 792
  ProgramGroup 1
  KernelDescription "2 \"PointRender3D\" iterate pixelWise e0ecbbf4cba39730471d23bc9f9ec846fcae1bbb869971a11b15641cf6fd5620 5 \"ppos\" Read Random \"src\" Read Random \"normals\" Read Random \"occlusion\" Read Random \"dst\" Write Random 48 \"cam_Matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== \"focallength\" Float 1 AAA4QQ== \"hapeture\" Float 1 ppvEQQ== \"format\" Int 2 AAgAAAAIAAA= \"vertexformat\" Int 2 CgAAAAoAAAA= \"Zoom\" Float 1 AACAPw== \"Filtering Method\" Int 1 AQAAAA== \"_alphaMultiplier\" Float 1 AACAPw== \"_pointRender\" Bool 1 AQ== \"_wireRender\" Bool 1 AQ== \"_facetRender\" Bool 1 AQ== \"_maxLDistance\" Float 1 AACAPw== \"_maxLConnections\" Int 1 AQAAAA== \"_maxPlexType\" Int 1 AAAAAA== \"_plexLinedefXY\" Bool 1 AA== \"_plexLinedefX\" Bool 1 AA== \"_plexLinedefY\" Bool 1 AA== \"_plexLinedefXtoY\" Bool 1 AA== \"_plexLinedefAUX\" Bool 1 AA== \"_plexConnectX\" Bool 1 AA== \"_plexConnectY\" Bool 1 AA== \"_L_gamma\" Float 1 AACAPw== \"Enable Depth of Field\" Bool 1 AA== \"samples\" Int 1 AwAAAA== \"rings\" Int 1 BQAAAA== \"focalDepth\" Float 1 AACAPw== \"_depthOfField\" Float 1 AACAQA== \"_depthMult\" Float 1 zczMPQ== \"_maxDofSize\" Float 1 AAAAQQ== \"dof_aspect\" Float 1 AACAPw== \"dof_threshold\" Float 1 AACAPw== \"dof_gain\" Float 1 AAAAAA== \"dof_bias\" Float 1 AAAAwA== \"dof_fringe\" Float 1 AAAAAA== \"_flatshading\" Bool 1 AQ== \"_backfacing\" Bool 1 AQ== \"_frontfacing\" Bool 1 AQ== \"_vertexMode\" Int 1 AAAAAA== \"_depthBuffer\" Bool 1 AQ== \"_texoffset\" Float 2 AAAAPwAAAD8= \"_pointSize\" Int 1 AQAAAA== \"_gaussigma\" Float 1 AACAPw== \"_depthOcclusion\" Bool 1 AQ== \"depthMultiplier\" Float 1 AACAPw== \"_maxLineSteps\" Float 1 AAB6RQ== \"_lineOffset\" Float 1 AACAPw== \"_lineInMultiplier\" Float 1 AACAPw== \"_lineOutMultiplier\" Float 1 AACAPw== 48 \"cam_Matrix\" 16 1 \"cam_Focal\" 1 1 \"cam_Hapeture\" 1 1 \"WHformat\" 2 1 \"Vformat\" 2 1 \"zoom\" 1 1 \"_filtering\" 1 1 \"_alphaMultiplier\" 1 1 \"_pointRender\" 1 1 \"_wireRender\" 1 1 \"_facetRender\" 1 1 \"_maxPlexDistance\" 1 1 \"_maxPlexConnections\" 1 1 \"_maxPlexType\" 1 1 \"_plexLinedefXY\" 1 1 \"_plexLinedefX\" 1 1 \"_plexLinedefY\" 1 1 \"_plexLinedefXtoY\" 1 1 \"_plexLinedefAUX\" 1 1 \"_plexConnectX\" 1 1 \"_plexConnectY\" 1 1 \"_plex_gamma\" 1 1 \"_dof_enable\" 1 1 \"_dof_samples\" 1 1 \"_dof_rings\" 1 1 \"focalDepth\" 1 1 \"_depthOfField\" 1 1 \"_depthMult\" 1 1 \"_maxDofSize\" 1 1 \"dof_aspect\" 1 1 \"dof_threshold\" 1 1 \"dof_gain\" 1 1 \"dof_bias\" 1 1 \"dof_fringe\" 1 1 \"_flatshading\" 1 1 \"_backfacing\" 1 1 \"_frontfacing\" 1 1 \"_vertexMode\" 1 1 \"_depthBuffer\" 1 1 \"_texoffset\" 2 1 \"_pointSize\" 1 1 \"_gaussigma\" 1 1 \"_depthOcclusion\" 1 1 \"depthMultiplier\" 1 1 \"_maxLineSteps\" 1 1 \"_lineOffset\" 1 1 \"_lineInMultiplier\" 1 1 \"_lineOutMultiplier\" 1 1 10 \"max_line_connections\" Int 1 1 AAAAAA== \"vRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"pRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"tRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"vWorld\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"canvasWidth\" Float 1 1 AAAAAA== \"canvasHeight\" Float 1 1 AAAAAA== \"matrixData\" Float 1 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cameraToWorld\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"worldToCamera\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "//Some basic generic functions.\ninline float Frac(float a_X)\n\{\n    return a_X-floor(a_X);\n\}\n\ninline float3 Cross(float3 A,float3 B)\n\{\n    return float3(A.y*B.z - A.z*B.y,A.z*B.x - A.x*B.z,A.x*B.y - A.y*B.x);\n\}\n\ninline float Fmax(float a_X,float b_X,float c_X)\n\{\n    return max(c_X,max(a_X,b_X));\n\}\ninline float Fmin(float a_X,float b_X,float c_X)\n\{\n    return min(c_X,min(a_X,b_X));\n\}     \n\ninline float3 mix(float3 _X,float3 _Y,float _A)\{\n  return _X*(1.0f-_A)+_Y*_A;\n\}\ninline float mix(float _X,float _Y,float _A)\{\n  return _X*(1.0f-_A)+_Y*_A;\n\}                                                                                              \n\n//This function is used to multiply a float3 by a matrix4x4\ninline float3 multVecMatrix( float3 src, float4x4 matrix)\n\{\n    float   x,y,z,w;\n\n    x = src\[0]*matrix\[0]\[0] + src\[1]*matrix\[1]\[0] +\n    src\[2]*matrix\[2]\[0] + matrix\[3]\[0];\n    y = src\[0]*matrix\[0]\[1] + src\[1]*matrix\[1]\[1] +\n    src\[2]*matrix\[2]\[1] + matrix\[3]\[1];\n    z = src\[0]*matrix\[0]\[2] + src\[1]*matrix\[1]\[2] +\n    src\[2]*matrix\[2]\[2] + matrix\[3]\[2];\n    w = src\[0]*matrix\[0]\[3] + src\[1]*matrix\[1]\[3] +\n    src\[2]*matrix\[2]\[3] + matrix\[3]\[3];\n    \n    return float3(x/w, y/w, z/w);\n\}\n\n//This function is used to calculate the screenspace coordinates.\ninline bool computePixelCoordinates( \n    const float3 pWorld, \n    float3 &pRaster, \n    const float4x4 &worldToCamera, \n    const float &canvasWidth, \n    const float &canvasHeight, \n    const int &imageWidth, \n    const int &imageHeight\n) \n\{ \n    float3 pCamera; \n    pCamera = multVecMatrix(pWorld, worldToCamera); \n    float2 pScreen; \n    pScreen.x = pCamera.x / -pCamera.z; \n    pScreen.y = pCamera.y / -pCamera.z; \n    float2 pNDC; \n    pNDC.x = (pScreen.x + canvasWidth * 0.5f) / canvasWidth; \n    pNDC.y = (pScreen.y + canvasHeight * 0.5f) / canvasHeight; \n    pRaster.x = (pNDC.x * imageWidth); \n    pRaster.y = ((pNDC.y) * imageHeight); \n    pRaster.z = -pCamera.z; \n    if (pRaster.x < 0.0f || pRaster.x > imageWidth || \n       pRaster.y < 0.0f || pRaster.y > imageHeight || pRaster.z < 0.0f) \{\n       return false;  \n    \}\n    return true;\n\} \n\n\nkernel PointRender3D : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessRandom, eEdgeClamped> ppos;    //The point position map\n  Image<eRead, eAccessRandom, eEdgeClamped> src;     //The texture map\n  Image<eRead, eAccessRandom, eEdgeClamped> normals;     //The texture map  \n  Image<eRead, eAccessRandom, eEdgeClamped> occlusion;     //The texture map \n  Image<eWrite, eAccessRandom> dst;                 //the output image\n\n  param: //Parameters available to the user\n    float4x4 cam_Matrix;    //The world matrix of the camera\n    float cam_Focal;        //The focal length of the camera\n    float cam_Hapeture;     //The horizontal apeture of the camera\n    int2 WHformat,Vformat;          //The format of the output image\n    float zoom;             //A \"post\" zoom function\n    int _filtering;        //Filter method\n    float _alphaMultiplier; //Additive multiplier\n    bool _pointRender,_wireRender,_facetRender;\n    float _maxPlexDistance; //Additive multiplier\n    int _maxPlexConnections;\n    int _maxPlexType; // 0==Grid, -1==Nearest\n    bool _plexLinedefXY,_plexLinedefX,_plexLinedefY,_plexLinedefXtoY,_plexLinedefAUX; // Define what connections NOT to include\n    bool _plexConnectX,_plexConnectY; //Connect from the edge of x to 0, or edge of y to 0, usually for spheres\n    float _plex_gamma; //The threshold making shorter paths bright and longer paths dark\n    bool _dof_enable; // Enable DOF\n    int _dof_samples; // How many samples per DOF ring\n    int _dof_rings; // How many rings \n    float focalDepth,_depthOfField,_depthMult,_maxDofSize; //DOF Settings\n    float dof_aspect; //Pixel aspect ratio\n    float dof_threshold;\n    float dof_gain;\n    float dof_bias; //bokeh edge bias\n    float dof_fringe; //bokeh chromatic aberration/fringing\n    bool _flatshading,_backfacing,_frontfacing; //Vertex rendering settings\n    int _vertexMode;  //The rendering output mode, (think AOV)\n    bool _depthBuffer; //Non-additive, only render front most pixel\n    float2 _texoffset;\n    int _pointSize;\n    float _gaussigma;\n    bool _depthOcclusion;\n    float depthMultiplier;\n    float _maxLineSteps; //cap the line length to avoid process lock\n    float _lineOffset; //Alow you to shrink or extend the lines\n    float _lineInMultiplier,_lineOutMultiplier; //Control the brightness of the wires at the tips.\n\n  local: //Local variables\n    int max_line_connections;\n    float3 vRaster;\n    float3 pRaster;\n    float3 tRaster;    \n    float3 vWorld;\n    float canvasWidth;\n    float canvasHeight; \n    float matrixData\[4]\[4];\n    float4x4 cameraToWorld;\n    float4x4 worldToCamera;\n\n  void define() \{\n    defineParam(cam_Matrix, \"cam_Matrix\", float4x4( 1.0f,0.0f,0.0f,0.0f,\n                                                    0.0f,1.0f,0.0f,0.0f,\n                                                    0.0f,0.0f,1.0f,0.0f,\n                                                    0.0f,0.0f,0.0f,1.0f));\n    defineParam(cam_Focal,      \"focallength\", 11.5f);\n    defineParam(cam_Hapeture,      \"hapeture\", 24.576f);\n    defineParam(WHformat,      \"format\", int2(2048,2048));\n    defineParam(Vformat,      \"vertexformat\", int2(10,10));\n    defineParam(zoom, \"Zoom\", 1.0f);\n    defineParam(_filtering, \"Filtering Method\", 1); \n    defineParam(_alphaMultiplier, \"_alphaMultiplier\", 1.0f);     \n    defineParam(_pointRender, \"_pointRender\", true);  \n    defineParam(_wireRender, \"_wireRender\", true);\n    defineParam(_facetRender, \"_facetRender\", true);\n    defineParam(_maxPlexDistance, \"_maxLDistance\", 1.0f);    \n    defineParam(_maxPlexConnections, \"_maxLConnections\", 1);    \n    defineParam(_maxPlexType, \"_maxPlexType\", 0); \n    defineParam(_plexLinedefXY, \"_plexLinedefXY\", false);      \n    defineParam(_plexLinedefXtoY, \"_plexLinedefXtoY\", false); //NYI\n    defineParam(_plexLinedefAUX, \"_plexLinedefAUX\", false); \n    defineParam(_plexLinedefX, \"_plexLinedefX\", false);  \n    defineParam(_plexLinedefY, \"_plexLinedefY\", false);  \n    defineParam(_plexConnectX, \"_plexConnectX\", false);      \n    defineParam(_plexConnectY, \"_plexConnectY\", false);   \n    defineParam(_plex_gamma, \"_L_gamma\", 1.0f);\n    //DOF SETTINGS   \n    defineParam(_dof_enable, \"Enable Depth of Field\", false);   \n    defineParam(_dof_samples, \"samples\", 3);    \n    defineParam(_dof_rings, \"rings\", 5);   \n    defineParam(focalDepth, \"focalDepth\", 1.0f);  \n    defineParam(_depthOfField, \"_depthOfField\", 4.0f);  \n    defineParam(_depthMult, \"_depthMult\", 0.1f);  \n    defineParam(_maxDofSize, \"_maxDofSize\", 8.0f);  \n    defineParam(dof_aspect, \"dof_aspect\", 1.0f);  \n    defineParam(dof_threshold, \"dof_threshold\", 1.0f);  \n    defineParam(dof_gain, \"dof_gain\", 0.0f);  \n    defineParam(dof_bias, \"dof_bias\", -2.0f);  \n    defineParam(dof_fringe, \"dof_fringe\", 0.0f); \n    //SHADING SETTINGS \n    defineParam(_flatshading, \"_flatshading\", true);  \n    defineParam(_vertexMode, \"_vertexMode\", 0);  \n    defineParam(_backfacing, \"_backfacing\", true);    \n    defineParam(_frontfacing, \"_frontfacing\", true);        \n    defineParam(_depthBuffer, \"_depthBuffer\", true);  \n    defineParam(_texoffset, \"_texoffset\", float2(0.5f,0.5f)); \n    defineParam(_pointSize, \"_pointSize\", 1); \n    defineParam(_gaussigma, \"_gaussigma\", 1.0f); \n    defineParam(_depthOcclusion, \"_depthOcclusion\", true); \n    defineParam(depthMultiplier, \"depthMultiplier\", 1.0f); \n    defineParam(_maxLineSteps, \"_maxLineSteps\", 4000.0f); \n    defineParam(_lineOffset, \"_lineOffset\", 1.0f); \n    defineParam(_lineInMultiplier, \"_lineInMultiplier\", 1.0f);   \n    defineParam(_lineOutMultiplier, \"_lineOutMultiplier\", 1.0f);     \n\n  \}\n\n  //The init() function is run before any calls to process().\n  void init() \{\n    max_line_connections = 80;\n    canvasWidth = ((cam_Hapeture)/cam_Focal);\n    canvasHeight = ((cam_Hapeture)/cam_Focal)*float(float(WHformat.y)/float(WHformat.x)); \n    float matrixData\[] = \{cam_Matrix\[0]\[0], cam_Matrix\[1]\[0], cam_Matrix\[2]\[0], cam_Matrix\[3]\[0], \n                          cam_Matrix\[0]\[1], cam_Matrix\[1]\[1], cam_Matrix\[2]\[1], cam_Matrix\[3]\[1], \n                          cam_Matrix\[0]\[2], cam_Matrix\[1]\[2], cam_Matrix\[2]\[2], cam_Matrix\[3]\[2], \n                          cam_Matrix\[0]\[3], cam_Matrix\[1]\[3], cam_Matrix\[2]\[3], cam_Matrix\[3]\[3]\};\n    cameraToWorld.setArray(matrixData); //This is a workaround. Due to the buggy matrix implementation, we pass the matrix on from another structure.\n    worldToCamera = cameraToWorld.invert();\n  \}\n\n  //Convert a 3d point position into a 2d raster position.\n  float3 Reconsile3D(float3 _PointPos)\{\n      vWorld = float3(_PointPos.x,_PointPos.y,_PointPos.z)*(zoom);\n      int ret = computePixelCoordinates(vWorld, tRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1]);\n      return tRaster;\n  \}\n\n//------------------------------\n//-------DRAW FUNCTIONS---------\n//------------------------------\n  //Write pixels to output.\n  void writepixel(float posx,float posy, float4 color,int index,float weight=1.0f)\n  \{ \n      if (_depthOcclusion)\{\n        float4 depthSample = occlusion(posx,posy);\n        if (depthSample.x<=vRaster.z && depthSample.w>0.0f)\{\n\n          float depth = (vRaster.z-depthSample.x);\n          color = color*(1.0f-depthSample.w);\n          color = color / (((depth*depth)*depthMultiplier)+1.0f);\n          //return;\n        \}\n      \}\n      float4 finalOutput; //This is used to store the final output\n      float4 dstSample; //This is used to store a sample of the destination\n      if ( dst.bounds.inside( posx, posy ) ) \{ //Test if the pixel written to is inside the output image. \n        if (_depthBuffer) \{\n          dstSample = (float4)dst(posx,posy); //Sample the destination image\n          if ((dstSample.w>color.w)||dstSample.w==0.0f) \{\n            dst(posx,posy) = color;\n          \}\n        \}\n        else \{\n          dstSample = (float4)dst(posx,posy); //Sample the destination image\n          finalOutput = dstSample + (color*_alphaMultiplier*weight);\n          finalOutput.w = dstSample.w + ((color.w*_alphaMultiplier*weight));\n\n          finalOutput.w = (dstSample.w + ((color.w*_alphaMultiplier*weight)))-(dstSample.w * ((color.w*_alphaMultiplier*weight)));\n\n          dst(posx,posy) = finalOutput;\n        \}\n      \} \n  \}\n\n  //Calculate a Bilinear Plot\n  void bilinear_Plot(float2 temppos,float4 color,int index)\n  \{\n    float2 p;\n    p.x=Frac(temppos.x);\n    p.y=Frac(temppos.y);\n    float weights\[] = \{(1.0f-p.x)*(1.0f-p.y), p.x*(1.0f-p.y), (1.0f-p.x)*p.y, p.x*p.y\};\n    int2 _position = int2(floor(temppos.x)-0,floor(temppos.y)-0); \n    writepixel(_position.x,_position.y,color,index,weights\[0]);\n    writepixel(_position.x+1,_position.y,color,index,weights\[1]);\n    writepixel(_position.x,_position.y+1,color,index,weights\[2]);\n    writepixel(_position.x+1,_position.y+1,color,index,weights\[3]);\n  \}\n\n  //NYI, unused!\n  void gaussian(float2 temppos,float4 color,int index)\{\n    float in_x = temppos.x;\n    float in_y = temppos.y;\n    int kernelSize = (_pointSize+1)*2;\n    int subsize = (kernelSize /2)-1;\n    float gKernel\[64]\[64];\n    float sigma = _gaussigma;\n    float intSigma = float(_pointSize);\n    float r, s = intSigma * sigma * sigma;\n\n    float sum = 0.0f;\n\n    // generate 5x5 kernel\n    for (int x = -subsize; x <= subsize; x++)\n    \{\n        for(int y = -subsize; y <= subsize; y++)\n        \{\n            r = float(sqrt(x*x + y*y));\n            gKernel\[x + subsize]\[y + subsize] = (exp(-(r*r)/s))/(3.141592654f * s);\n            sum += gKernel\[x + subsize]\[y + subsize];\n        \}\n    \}\n\n    // normalize the Kernel\n    for (int x = -subsize; x <= subsize; x++)\n    \{\n        for(int y = -subsize; y <= subsize; y++)\n        \{\n            gKernel\[x + subsize]\[y + subsize] /= sum;\n            writepixel(in_x+x,in_y+y,color,index,gKernel\[x + subsize]\[y + subsize]);\n        \}\n    \}\n  \}\n\n//-------------------------------------\n// DrawLine\n// ----------\n// Draw a line between two points, \n// x,y being 2d screenspace pos and z being depth.\n//-------------------------------------\n  void DrawLine(float3 origin, float3 endpoint,float4 _colorA,float4 _colorB) \{\n    float4 _color;\n    float3 delta = origin-endpoint;\n    float3 curPoint = origin;\n    float mag = sqrt(delta.x*delta.x+delta.y*delta.y);\n    mag = min(mag,_maxLineSteps); //Lets not go crazy, we cap it at 10.000 to avoid insane unwated processing time \n    for( float a = 0; a < mag*_lineOffset; a = a + 1.0f )\{\n      curPoint -= (delta/mag);\n      _color = (_colorA*(1.0f-(a/mag*1.0f)))+(_colorB*(a/mag*1.00f));\n      if (_dof_enable)\{\n        Bokeh(curPoint,_color);\n      \}\n      else \{\n        bilinear_Plot(float2(curPoint.x,curPoint.y),_color,1);\n      \}\n      \n    \}\n  \}\n\n//-------------------------------------\n// Point_Render\n//-------------------------------------\nvoid point_render(int2 pos, float3 screen_pos)\{\n  float4 color = src(pos.x,pos.y);\n\n  if (_filtering == 1)\{\n      if (_dof_enable)\{\n        Bokeh(screen_pos,color);\n      \}\n      else \{\n        bilinear_Plot(float2(screen_pos.x,screen_pos.y),color,1);\n      \}\n  \}\n  /*\n  //THIS PART NEEDS TO BE RE-WRITTEN.\n  else if (_filtering == 2)\{ \n      if (_dof_enable)\{\n        Bokeh(screen_pos,color);\n      \}\n      else \{\n        gaussian(float2(screen_pos.x,screen_pos.y),color,1);\n      \}\n  \}\n  */\n  else \{\n      int2 _position = int2(floor(screen_pos.x),floor(screen_pos.y)); \n      if (_depthBuffer) \{color.w = screen_pos.z;\}\n      writepixel(_position.x,_position.y, color,1,1.0f); //OutputSample\n  \}\n\n\}\n\n//-------------------------------------\n// Facet_Render\n//-------------------------------------\n//This function is used to calculate what triangels to draw\nvoid facet_render(int2 pos, float3 _vWorld)\{\n\n    float3 screen_pos = Reconsile3D(_vWorld);\n\n    bool insideX = ppos.bounds.inside(pos.x+1,pos.y );\n    bool insideY = ppos.bounds.inside(pos.x+1,pos.y-1 );\n    bool insideYtop = ppos.bounds.inside(pos.x,pos.y+1);\n    float2 fpos = float2(pos.x,pos.y);\n    float3 V1_Pos,V2_Pos,V1_wPos,V2_wPos,V0_N,V1_N,V2_N;\n    float2 V0_ST,V1_ST,V2_ST;\n    float4 V1_Sample,V2_Sample;\n    float4 _tn;\n    float3 normal0,normal1,normal2;\n    float2 UV_Format = float2(Vformat.x,Vformat.y);\n\n\n    int2 P0 = int2(pos.x-1,pos.y-1);\n    int2 P1 = int2(pos.x+1,pos.y+1);\n    if (_plexConnectX && pos.x == int(Vformat.x))\{\n      insideX == true;\n      P1 = int2(0.0f,pos.y+1);\n    \}\n    if (_plexConnectY && pos.y == int(Vformat.y))\{\n      insideYtop == true;\n      P1 = int2(pos.x+1,0);\n    \} \n\n    if (_plexConnectY && pos.y == 0)\{\n      insideY == true;\n      P0 = int2(pos.x-1,int(UV_Format.y));\n    \} \n\n    if (!_flatshading) \{\n      _tn = normals(pos.x,pos.y);\n      V0_N =float3(_tn.x,_tn.y,_tn.z);\n    \}\n    V0_ST = float2(pos.x,pos.y)/UV_Format;\n\n  if (insideX) \{\n    V2_Sample = ppos(P1.x,pos.y);\n    V2_ST = float2(P1.x,pos.y)/UV_Format;\n    V2_wPos = float3(V2_Sample.x,V2_Sample.y,V2_Sample.z);\n    V2_Pos = Reconsile3D(V2_wPos);\n    if (!_flatshading) \{\n      _tn = normals(P1.x,pos.y);\n      V2_N =float3(_tn.x,_tn.y,_tn.z);\n    \}\n        \n\n    if (V2_Sample.w != 0.0f) \{ \n\n      if (insideY) \{\n        V1_Sample = ppos(P1.x,P0.y);\n        V1_ST = float2(P1.x,P0.y)/UV_Format;\n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (!_flatshading) \{\n          _tn = normals(P1.x,P0.y);\n          V1_N =float3(_tn.x,_tn.y,_tn.z);\n        \}\n        if (V1_Sample.w != 0.0f) \{ \n          DrawTriangle(screen_pos,V2_Pos,V1_Pos,_vWorld,V2_wPos,V1_wPos,V0_N,V2_N,V1_N,V0_ST,V2_ST,V1_ST);\n        \}\n      \}\n      if (insideYtop) \{\n        V1_Sample = ppos(pos.x,P1.y);\n        V1_ST = float2(pos.x,P1.y)/UV_Format;        \n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (!_flatshading) \{\n          _tn = normals(pos.x,P1.y);\n          V1_N =float3(_tn.x,_tn.y,_tn.z);\n        \}        \n        if (V1_Sample.w != 0.0f) \{ \n          DrawTriangle(screen_pos,V1_Pos,V2_Pos,_vWorld,V1_wPos,V2_wPos,V0_N,V1_N,V2_N,V0_ST,V1_ST,V2_ST);\n        \}\n      \}\n    \}\n  \}\n\}\n\n\n\n//This function will calculate if pixel C is inside the triangle\nfloat edgeFunction(float3 a, float3 b, float3 c) \n\{ \n    return ((c.x - a.x) * (b.y - a.y) - (c.y - a.y) * (b.x - a.x)); \n\} \n\nfloat3 CalculateSurfaceNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat3 CalculateVertexNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat Distance(float3 _a,float3 _b)\n\{\n          float xd = _a.x - _b.x;\n          float yd = _a.y - _b.y;\n          float zd = _a.z - _b.z;\n          return sqrt(xd*xd + yd*yd + zd*zd);\n\}\n\nvoid DrawTriangle(float3 V0, float3 V1, float3 V2,float3 WP0, float3 WP1, float3 WP2,float3 N0, float3 N1, float3 N2, float2 st0,float2 st1,float2 st2) \{\n\n  // Precompute reciprocal of vertex z-coordinate \n  V0.z = 1.0f / V0.z, V1.z = 1.0f / V1.z, V2.z = 1.0f / V2.z; \n\n  float2 st0n = st0 * V0.z;\n  float2 st1n = st1 * V1.z; \n  float2 st2n = st2 * V2.z; //Normal version of ST\n\n  bool inside; \n  float X0 = Fmin(V0.x,V1.x,V2.x)-1.0f;\n  float X1 = Fmax(V0.x,V1.x,V2.x)+1.0f;\n  float Y0 = Fmin(V0.y,V1.y,V2.y)-1.0f;\n  float Y1 = Fmax(V0.y,V1.y,V2.y)+1.0f;\n  float area = edgeFunction(V2, V1, V0);\n\n\n  float2 sampos = float2(st0.x*float(Vformat.x),st0.y*float(Vformat.y));\n  float4 text0 = src(sampos.x,sampos.y);\n  sampos = float2(st1.x*float(Vformat.x),st1.y*float(Vformat.y));\n  float4 text1 = src(sampos.x,sampos.y);\n  sampos = float2(st2.x*float(Vformat.x),st2.y*float(Vformat.y));  //Why do we have to do this? =(\n  float4 text2 = src(sampos.x,sampos.y);\n  sampos = float2(min(min(st0.x,st1.x),st2.x)*float(Vformat.x),min(min(st0.y,st1.y),st2.y)*float(Vformat.y));\n  float4 text3 = src(sampos.x,sampos.y);\n\n\n  for( int x = X0; x < X1 ; x++) \{\n    for( int y = Y0; y < Y1 ; y++) \{\n      float3 pixelSample(x + _texoffset.x, y + _texoffset.y,0.0f); \n\n      //This is the part where we test if the current pixel is inside the triangle\n      //We check both for front facing and back faing options\n      float w0 = edgeFunction(V1, V0, pixelSample); //Front Facing\n      float w1 = edgeFunction(V2, V1, pixelSample); \n      float w2 = edgeFunction(V0, V2, pixelSample); \n      float w3 = edgeFunction(V0, V1, pixelSample); //Back Facing\n      float w4 = edgeFunction(V1, V2, pixelSample); \n      float w5 = edgeFunction(V2, V0, pixelSample);\n\n      //writepixel(x,y, float4(w1),1,1.0f);\n      if ((w0 >= 0 && w1 >= 0 && w2 >= 0 && _frontfacing) || (w3 >= 0 && w4 >= 0 && w5 >= 0 && _backfacing)) \{ //The curent pixel is inside the triangle\n\n       // calculate vectors from point f to vertices p1, p2 and p3:\n       float3 f1 = V0-pixelSample;\n       float3 f2 = V1-pixelSample;\n       float3 f3 = V2-pixelSample;\n       // calculate the areas and factors (order of parameters doesn't matter):\n       float a = length(cross(V0-V1,V0-V2 )); // main triangle area a\n       area = length(V0-V1)+length(V0-V2)+length(V1-V2);\n\n        w0 /= area; \n        w1 /= area; \n        w2 /= area; \n\n        w3 /= area; \n        w4 /= area; \n        w5 /= area; \n\n       float a1 = length(cross(f2, f3)) / a; // p1's triangle area / a\n       float a2 = length(cross(f3, f1)) / a; // p2's triangle area / a \n       float a3 = length(cross(f1, f2)) / a; // p3's triangle area / a\n       float a_magnitude = a1+a2+a3;\n       a1 = a1/a_magnitude;\n       a2 = a2/a_magnitude;\n       a3 = a3/a_magnitude;\n       float z = 1.0f / (V0.z * a1 + V1.z * a2 + V2.z * a3); \n\n\n        // find the uv corresponding to point f (uv1/uv2/uv3 are associated to p1/p2/p3):\n        float2 uv = st0 * a1 + st1 * a2 + st2 * a3;\n        float2 st = st0 * w0 + st1 * w1 + st2 * w2; \n        st *= z;      \n\n\n        //Calculate normals. Eighter we have flat shading, else we calculate a normal per pixel\n        float3 normalB;\n        if (_flatshading) \{\n          normalB = CalculateSurfaceNormals(WP0,WP1,WP2);\n\n        \}\n        else \{\n          float3 c0 = N2/float3(V0.z); \n          float3 c1 = N0/float3(V1.z); \n          float3 c2 = N1/float3(V2.z);  \n\n          normalB.x = w0 * c0.x + w1 * c1.x + w2 * c2.x; \n          normalB.y = w0 * c0.y + w1 * c1.y + w2 * c2.y; \n          normalB.z = w0 * c0.z + w1 * c1.z + w2 * c2.z; \n\n          normalB.x *= z, normalB.y *= z, normalB.z *= z; \n        \}\n        normalB = normalize(normalB);\n\n        //CALCULATE THE OBJECT TEXTURE COORDINATES\n        float zn = 1.0f / (V0.z * w0 + V1.z * w1 + V2.z * w2); \n        st = st0n * w0 + st1n * w1 + st2n * w2; \n        st *= zn;   \n        //--END \n\n        float3 Wpos = WP0*a1 + WP1*a2 + WP2*a3; //World Position.\n        float3 ViewNormal = normalize(float3(cameraToWorld\[3]\[0],cameraToWorld\[3]\[1],cameraToWorld\[3]\[2])-Wpos);\n\n        float nDotView =  dot(normalB,ViewNormal);\n        nDotView = 1.0f-fabs(nDotView); //make sure that the view normal ramps back around when doing backface\n        float4 tempout;\n\n        //Flatshading or regular?\n        if (!_flatshading) \{\n          tempout = text0 * a1 + text1 * a2 + text2 * a3; \n        \}\n        else\{\n          tempout = text3;\n        \}\n\n        //Additional Render Modes\n        if (_vertexMode == 1)\{\n          tempout = float4(a1,a2,a3,1.0f);\n        \}\n        else if (_vertexMode == 2)\{\n          tempout = float4(normalB.x,normalB.y,normalB.z,1.0f);\n        \}\n        else if (_vertexMode == 3)\{\n          tempout = float4(nDotView,nDotView,nDotView,1.0f);\n        \}\n        else if (_vertexMode == 4)\{\n          tempout = float4(uv.x,uv.y,0.0f,1.0f);\n        \}       \n        else if (_vertexMode == 5)\{\n          tempout = float4(st.x,st.y,0.0f,1.0f);\n        \}               \n        else if (_vertexMode == 6)\{\n          tempout = float4(ViewNormal.x,ViewNormal.y,ViewNormal.z,1.0f);\n        \}             \n        else if (_vertexMode == 7)\{\n          tempout = float4(Wpos.x,Wpos.y,Wpos.z,1.0f);\n        \}   \n\n        if (_depthBuffer)\{\n          writepixel(x,y, float4(tempout.x,tempout.y,tempout.z,z),1,1.0f);  \n        \}\n        else \{\n          if (_dof_enable)\{\n            Bokeh(float3(x,y,z),float4(tempout.x,tempout.y,tempout.z,z));\n          \}\n          else \{\n            bilinear_Plot(float2(x,y),float4(tempout.x,tempout.y,tempout.z,z),1);\n          \}\n        \}\n\n      \}  \n\n    \}\n  \}\n\}\n\n//-------------------------------------\n// Wire_Render\n//-------------------------------------\nvoid wire_render(int2 pos) \{\n  float4 temp = float4(0.0f,0.0f,0.0f,FLT_MAX);\n  float4 wire_ref_sample;\n  int2 tempXY = int2(0,0);\n  float4 plexlist\[11] = \{temp,temp,temp,temp,temp,temp,temp,temp,temp,temp,temp\}; \n  int2 plexlistXY\[11] = \{tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY\};\n  int plex_count = 0; //We use this to figure how many points that should connect.\n  float plex_dist;\n  float3 plex_position,plex_position_b;\n  float4 temp_pos, temp_pos_b; //Temporary Position Containers\n  if (_maxPlexType == -1) \{ //Used for random connection types\n    for( int x = 0; x < max_line_connections ; x++)\{ //THIS 80 NUMBER IS THE LIMIT TO AVOID TOO SLOW PROCESSING!\n      for( int y = 0; y < max_line_connections ; y++)\{\n        wire_ref_sample = ppos(x,y);\n        if (wire_ref_sample.w != 0.0f && pos.x!=x && pos.y != y) \{ \n          plex_position = float3(wire_ref_sample.x,wire_ref_sample.y,wire_ref_sample.z)*(zoom);\n          float xd = plex_position.x - vWorld.x;\n          float yd = plex_position.y - vWorld.y;\n          float zd = plex_position.z - vWorld.z;\n          float plex_dist = sqrt(xd*xd + yd*yd + zd*zd);\n          if (plex_dist<_maxPlexDistance)\{\n            plex_count = min(10,plex_count+1); //Add one to the count\n            for( int h = 0; h < plex_count+1 ; h++) \{ //Loop thought all the points. If the distance is shorter then insert it into the array and push the rest of the array down\n              if (plex_dist < plexlist\[h].w) \{                  \n                for( int i = plex_count+1; i > h ; i--) \{\n                  plexlist\[i] = plexlist\[i-1];\n                  plexlistXY\[i] = plexlistXY\[i-1];\n                \}\n                plexlist\[h] = float4(plex_position.x,plex_position.y,plex_position.z,plex_dist);\n                plexlistXY\[h] = int2(x,y);\n                break;        \n              \}\n            \}\n          \} \n        \}\n      \}\n    \}\n  \}\n  else\{ //Used for standard connection types\n    float4 temp_pos;\n    bool insideX = !(Vformat.x < pos.x+1);\n    bool insideY = !(Vformat.y < pos.y+1);\n\n\n    if (!_plexLinedefAUX)\{\n      temp_pos = normals(pos.x,pos.y);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,vWorld+plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    if ( insideX && !_plexLinedefX) \{\n      temp_pos = ppos(pos.x+1,pos.y );\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && !_plexLinedefX) \{\n      temp_pos = ppos(0,pos.y);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    if ( insideY && !_plexLinedefY) \{\n      temp_pos = ppos(pos.x,pos.y+1);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\}                          \n    \}\n    else if ( _plexConnectY  && !_plexLinedefY) \{\n      temp_pos = ppos(pos.x,0);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    //_plexConnect\n    if ( insideX && insideY && !_plexLinedefXY) \{              \n      temp_pos = ppos(pos.x+1,pos.y+1);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && _plexConnectY && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && insideY && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectY && insideX && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n  \}   \n\n  //now that all the connections have been sorted by distance then we connect the dots.\n  for( int x = 0; x < min(_maxPlexConnections,plex_count) ; x++)\{\n    plex_position = float3(plexlist\[x].x,plexlist\[x].y,plexlist\[x].z);\n    plex_dist = plexlist\[x].w;\n\n\n    float plex_distribution = 1.0f-((plexlist\[x].w-plexlist\[0].w)/((plexlist\[min(_maxPlexConnections,plex_count)].w-plexlist\[0].w)+0.00001f)); //Where does it lie between the best and the worst distance?\n    //plexlistXY\n\n    float4 plex_col = float4(pow(1.0f-(plex_dist/_maxPlexDistance),1.0f/_plex_gamma))*float4(plex_distribution); //This one is quite cool aswell, but does leave the center ones a bit too focused \n    float4 plex_colorA = src(pos.x,pos.y);\n    float4 plex_colorB = src( plexlistXY\[x].x,plexlistXY\[x].y);\n    plex_col *= 0.1f;\n\n    computePixelCoordinates(plex_position, pRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1]);\n    if (dst.bounds.inside(int(vRaster.x),int(vRaster.y)) || dst.bounds.inside(int(pRaster.x),int(pRaster.y)))\{\n        DrawLine(vRaster,pRaster,(plex_colorA*plex_col)*_lineInMultiplier,(plex_colorB*plex_col)*_lineOutMultiplier);\n    \}\n  \}\n\}\n\nvoid wire_connection(float3 p_source,float3 p_target, float4 (&p_plexlist)\[11], int2 (&p_plexlistXY)\[11],int &p_plexcount,int2 position) \{\n  float xd = p_target.x - p_source.x;\n  float yd = p_target.y - p_source.y;\n  float zd = p_target.z - p_source.z;\n  float plex_dist = sqrt(xd*xd + yd*yd + zd*zd);\n  if (plex_dist<_maxPlexDistance)\{\n    p_plexcount = min(11,p_plexcount+1); //Add one to the count\n    for( int h = 0; h < p_plexcount+1 ; h++) \{ //Loop thought all the points. If the distance is shorter then insert it into the array and push the rest of the array down\n      if (plex_dist < p_plexlist\[h].w) \{                  \n        for( int i = p_plexcount+1; i > h ; i--) \{\n          p_plexlist\[i] = p_plexlist\[i-1];\n          p_plexlistXY\[i] = p_plexlistXY\[i-1];\n        \}\n        p_plexlist\[h] = float4(p_target.x,p_target.y,p_target.z,plex_dist);\n        p_plexlistXY\[h] = int2(position.x,position.y);\n        break;        \n      \}\n    \}  \n  \}\n\}\n//-------END OF WIRE RENDER FUNCTIONS---------\n\n\n\n\n//-------------------------------\n//-------BOKEH FUNCTIONS---------\n//thanks to: http://devlog-martinsh.blogspot.dk/2011/11/glsl-depth-of-field-with-bokeh-v21.html\nfloat2 rand(float2 coord) //generating noise/pattern texture for dithering\n\{\n  float noiseX = ((Frac(1.0-coord.x*(WHformat\[0]/2.0))*0.25)+(Frac(coord.y*(WHformat\[1]/2.0))*0.75))*2.0-1.0;\n  float noiseY = ((Frac(1.0-coord.x*(WHformat\[0]/2.0))*0.75)+(Frac(coord.y*(WHformat\[1]/2.0))*0.25))*2.0-1.0;\n  noiseX = clamp(Frac(sin(dot(coord ,float2(12.9898f,78.233f))) * 43758.5453f),0.0f,1.0f)*2.0f-1.0f;\n  noiseY = clamp(Frac(sin(dot(coord ,float2(12.9898f,78.233f)*2.0f)) * 43758.5453f),0.0f,1.0f)*2.0-1.0f;\n  return float2(noiseX,noiseY);\n\}\n//-------------------------------------\n// Bokeh\n//-------------------------------------\nvoid Bokeh(float3 pos,float4 color)\{\n  float blur = 0.0;\n  blur = clamp((fabs(pos.z - focalDepth)/_depthOfField)*100.0f,-_maxDofSize,_maxDofSize);\n  \n  float w = (1.0/WHformat.x)*blur;//+noise.x;\n  float h = (1.0/(WHformat.x*dof_aspect))*blur;//+noise.y;\n  float3 v3_col = float3(color.x,color.y,color.z);\n  int ringsamples;\n  float s = 1.0;  \n\n  for (int i = 1; i <= _dof_rings; i += 1)\n  \{   \n    ringsamples = i * _dof_samples; \n    for (int j = 0 ; j < ringsamples ; j += 1)  \n    \{ \n      s += (1.0f*mix(1.0f,(float(i))/(float(_dof_rings)),dof_bias)*1.0f); //No need to do this in the loop\n    \}\n  \}\n\n  for (int i = 1; i <= _dof_rings; i += 1)\n  \{   \n    ringsamples = i * _dof_samples;\n     \n    for (int j = 0 ; j < ringsamples ; j += 1)   \n    \{\n      float step = PI*2.0 / float(ringsamples);\n      float pw = (cos(float(j)*step)*(float(i)/_dof_rings));\n      float ph = (sin(float(j)*step)*(float(i)/_dof_rings));\n      float p = 1.0;\n\n      float posx = pos.x+((pw*w)*blur);\n      float posy = pos.y+((ph*h)*blur);\n\n\n      float3 lumcoeff = float3(0.299,0.587,0.114);\n      float lum = dot(v3_col, lumcoeff);\n      float thresh = max((lum-dof_threshold)*dof_gain, 0.0f);\n      v3_col+mix(float3(0.0),v3_col,thresh*blur);\n\n      float3 col = (v3_col*mix(1.0,(float(i))/(float(_dof_rings)),dof_bias)*p)/s; \n      bilinear_Plot(float2(posx,posy),float4(col.x,col.y,col.z,color.w/(_dof_rings*_dof_rings)),1);\n    \}\n  \}\n\}\n//-------END OF BOKEH FUNCTIONS---------\n\n\n\n//-------------------------------------\n// Process\n//-------------------------------------\n  void process(int2 pos) \{\n    float4 _sample = ppos(pos.x,pos.y); //Get the XYZ Coordinates\n    float2 posf = float2(pos.x,pos.y);\n\n    if (_sample.w != 0.0f) \{  //No need to process if there is no data.\n\n      //Convert worldspace coordinates to screenspcace coordinates.\n      vWorld = float3(_sample.x,_sample.y,_sample.z)*(zoom);\n      int ret = computePixelCoordinates(vWorld, vRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1]);\n      if (ret) \{ //Only create points that are visible on screen\n        if (_pointRender)\{\n          point_render(pos,vRaster);\n        \}\n      \} //Pointrender over\n\n      if (_wireRender && _maxPlexConnections>=1) \{\n        if (max(pos.x,pos.y)<=max_line_connections || (_maxPlexType==0))\{ // Don't process more wires than allowed in nearest mode.\n          wire_render(pos);\n        \}\n      \} //WireRender over\n\n      if (_facetRender) \{\n        facet_render(pos,float3(_sample.x,_sample.y,_sample.z));\n      \}  //FacetRender over\n      \n    \}\n  \} //----> process\n\};\n"
  useGPUIfAvailable false
  rebuild ""
  PointRender3D_cam_Matrix {
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
    }
  PointRender3D_focallength {{parent.Camera1.focal}}
  PointRender3D_hapeture {{parent.Camera1.haperture}}
  PointRender3D_format {{Settings_Format.width} {Settings_Format.height}}
  PointRender3D_vertexformat {{parent.InputFormat.box.r-1} {parent.InputFormat.box.t-1}}
  PointRender3D__alphaMultiplier {{parent.AlphaMultiplier}}
  PointRender3D__pointRender {{parent.RenderMode==0}}
  PointRender3D__wireRender {{parent.RenderMode==1}}
  PointRender3D__facetRender {{parent.RenderMode==2}}
  PointRender3D__maxLDistance {{parent.wire_maxdistance}}
  PointRender3D__maxLConnections {{parent.wire_connections}}
  PointRender3D__maxPlexType {{-parent.wire_type}}
  PointRender3D__plexLinedefXY {{!parent.connect_xy}}
  PointRender3D__plexLinedefX {{!parent.connect_x}}
  PointRender3D__plexLinedefY {{!parent.connect_y}}
  PointRender3D__plexLinedefAUX {{!connect_aux}}
  PointRender3D__plexConnectX {{parent.CloseX}}
  PointRender3D__plexConnectY {{parent.CloseY}}
  PointRender3D__L_gamma {{parent.wire_Threshold}}
  "PointRender3D_Enable Depth of Field" {{parent.dof_enable}}
  PointRender3D_samples {{3*(parent.Dof_Quality*parent.Dof_Quality+1)}}
  PointRender3D_rings {{3*(parent.Dof_Quality*parent.Dof_Quality+1)}}
  PointRender3D_focalDepth {{parent.dof_focaldepth}}
  PointRender3D__depthOfField {{parent.dof_dof}}
  PointRender3D__depthMult {{parent.DofMultiplier}}
  PointRender3D__maxDofSize {{parent.dof_maxSize*400}}
  PointRender3D_dof_aspect {{parent.dof_Aspect}}
  PointRender3D_dof_bias {{parent.dof_bias}}
  PointRender3D__flatshading {{parent.facet_flatShading}}
  PointRender3D__backfacing {{parent.facet_backface}}
  PointRender3D__frontfacing {{parent.facet_front}}
  PointRender3D__vertexMode {{parent.renderMode}}
  PointRender3D__depthBuffer {{parent.facet_depth}}
  PointRender3D__texoffset {-0.5 0.5}
  PointRender3D__pointSize 0
  PointRender3D__depthOcclusion {{parent.UseOcclusionMap}}
  PointRender3D__maxLineSteps {{parent.maxSamples}}
  PointRender3D__lineOffset {{parent.lineoffset}}
  PointRender3D__lineInMultiplier {{parent.inGain}}
  PointRender3D__lineOutMultiplier {{parent.outGain}}
  format "1280 720 0 0 1280 720 1 HD_720"
  rebuild_finalise ""
  name BlinkScript1
  selected true
  xpos -27
  ypos 159
 }
 Reformat {
  format {{{Settings_Format.format}}}
  resize none
  center false
  name Reformat1
  xpos -27
  ypos 343
 }
 Group {
  name SoftLook
  xpos -27
  ypos 460
  disable {{!parent.HighlightCompression}}
  addUserKnob {20 User}
  addUserKnob {26 ""}
  addUserKnob {7 Add R 0 4}
  Add {{parent.HighlightCeiling}}
  addUserKnob {7 Offset R 0 4}
  Offset {{parent.Compression}}
 }
  Input {
   inputs 0
   name Input1
   xpos -248
   ypos 500
  }
set N450ec980 [stack 0]
  Expression {
   expr0 r/(r+parent.Offset)*parent.Add
   expr1 g/(g+parent.Offset)*parent.Add
   expr2 b/(b+parent.Offset)*parent.Add
   expr3 a/(a+parent.Offset)*parent.Add
   name Expression1
   xpos -339
   ypos 576
  }
push $N450ec980
  ShuffleCopy {
   inputs 2
   red red
   green green
   blue blue
   alpha alpha2
   name ShuffleCopy1
   xpos -248
   ypos 576
  }
  Output {
   name Output1
   xpos -248
   ypos 651
  }
 end_group
 TimeBlur {
  divisions {{parent.Samples}}
  shutter {{parent.Shutter}}
  shutteroffset centred
  shuttercustomoffset 0
  name MotionBlur
  xpos -27
  ypos 581
  disable {{1-parent.mb_enable x89 0}}
 }
 ShuffleCopy {
  inputs 2
  in pos
  red red
  green green
  blue blue
  out pos
  name ShuffleCopy1
  xpos -27
  ypos 673
  disable true
 }
 Output {
  name Output1
  xpos -27
  ypos 710
 }
 Input {
  inputs 0
  name InputCamera
  xpos -1129
  ypos 116
  number 1
 }
 Camera2 {
  focal {{parent.FocalLength}}
  haperture {{parent.horizontalApeture}}
  name Camera1
  xpos -1119
  ypos 223
  addUserKnob {20 Ivy}
  addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.toolbox.v1.nodes.docs', fromlist=\['open_docs_name']).open_docs_name('IvyTab')" +STARTLINE}
  addUserKnob {26 divider4 l "" +STARTLINE}
  addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
  _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
  addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
  addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
  addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
  _expressions {{curve}}
  addUserKnob {26 divider0 l "" +STARTLINE}
  addUserKnob {20 dbinfo l "DB Info" n 1}
  dbinfo 0
  addUserKnob {1 twig_dnuuid l "Twig Id"}
  addUserKnob {1 stalk_dnuuid l "Stalk Id"}
  addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
  addUserKnob {1 leaf_dnuuid l "Leaf Id"}
  addUserKnob {26 divider1 l "" +STARTLINE}
  addUserKnob {1 twigtype l "Twig Type"}
  addUserKnob {1 leaf_label l Leaf}
  addUserKnob {1 ivy_version l Version}
  addUserKnob {43 ivy_notes l Notes}
  addUserKnob {26 divider2 l "" +STARTLINE}
  addUserKnob {1 build_label l "Build Label"}
  addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
 }
 Reformat {
  inputs 0
  format "3840 2160 0 0 3840 2160 1 Alexa LF UHD"
  resize none
  center false
  name Settings_Format
  xpos -1404
  ypos 241
 }
push $N452b1580
 PositionToPoints2 {
  display textured
  render_mode textured
  P_channel pos
  detail 0.25
  pointSize 0.6
  name PreviewNode
  xpos -22
  ypos 8
  disable {{!parent.Enable3DPreview}}
 }
push $N4530a010
 Reformat {
  type "to box"
  box_width 100
  box_height 100
  box_fixed true
  scale 0.1
  resize none
  filter impulse
  black_outside true
  name Reformat3
  xpos -633
  ypos -1109
  disable {{!wire_type==1}}
 }
push $N4538b110
 Crop {
  box {0 0 {width} {height}}
  reformat true
  crop false
  name InputFormat
  xpos -456
  ypos -402
 }
end_group
Reformat {
 name Reformat21
 selected true
 xpos 14744
 ypos 33303
}
FileOut {
 name FileOut23
 tile_color 0xbfbf00ff
 label evolve05
 selected true
 xpos 14744
 ypos 33418
 channels rgba
 _destination /jobs
 _stemstatus ""
 file ""
 proxy ""
 fileProxy ""
 views {main}
 first 1001
 last 1053
 pbb true
 dw_compression_level 0
 interleave channels
 tex_metadata "default metadata and exr/*"
 disable_autolabel_format true
 _defaults "\{'smart_grade': 0, 'compression': 1, 'tile_color': 3216965887, 'dw_compression_level': 0, 'pbb': True, 'label': u'evolve05'\}"
 _format ""
 _generator "NukeRenderGenerator dnnuke.core.render.v1"
 _ivyVals "\{'variant': None, 'host': None, 'versionNum': '1', 'twigType': 'spider://query@TwigType.one?TwigType.code==2d', 'twigNameTags': \{'subtask': u'precomp', 'task': u'comp', 'label': u'evolve05', 'out_dir': u'ELEMENT'\}, 'job': 'STONE', 'stalk': None, 'stalkAttrs': \{'framerange': '1017-1053'\}, 'twig': None, 'stem': 'spider://query@Stem.one?Stem.dnuuid==cfb45239-1375-4623-b0a4-12b2a5fba3d0&Stem.stemname==110_fof_0010&Stem.stemtype==shot'\}"
 _old_filetype exr
 _stalkname E_110_fof_0010_comp_precomp_evolve05_v001
 _twigtype 2d
 _wrapper "FileOut dnnuke.nodes.file_out.wrapper"
 beforeRender ""
 beforeFrameRender ""
 afterFrameRender ""
 afterRender ""
 renderProgress ""
 _invert_grade /tools/STONE/ivyasset/110_fof_0010/ivy/grade/GRD_110_fof_0010_neutral_v001/GRD_110_fof_0010_neutral_v001.grade
}
BagAndTagKeep {
 name BagAndTagKeep30
 selected true
 xpos 14744
 ypos 33500
}
push $cut_paste_input
Shuffle {
 name Shuffle32
 selected true
 xpos 14895
 ypos 32909
}
